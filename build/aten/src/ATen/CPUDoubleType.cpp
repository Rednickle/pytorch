// required for old g++ to compile PRId64 macros, see
// https://github.com/pytorch/pytorch/issues/3571
// for context
#define __STDC_FORMAT_MACROS

#include "ATen/CPUDoubleType.h"

// @generated by aten/src/ATen/gen.py

#include <TH/TH.h>
#include <TH/THTensor.hpp>
#include <THNN/THNN.h>
#undef THNN_
#include "ATen/core/TensorImpl.h"
#include "ATen/CPUGenerator.h"
#include "ATen/Allocator.h"
#include "ATen/DeviceGuard.h"
#include "ATen/NativeFunctions.h"
#include "ATen/Utils.h"
#include "ATen/WrapDimUtils.h"
#include "ATen/core/Half.h"
#include "ATen/core/TensorImpl.h"
#include "ATen/core/UndefinedTensorImpl.h"
#include "c10/util/Optional.h"

#include <cstddef>
#include <functional>
#include <memory>
#include <utility>

#include "ATen/Config.h"


namespace at {

CPUDoubleType::CPUDoubleType()
  : CPUTypeDefault(CPUTensorId(), /*is_variable=*/false, /*is_undefined=*/false) {}

ScalarType CPUDoubleType::scalarType() const {
  return ScalarType::Double;
}

caffe2::TypeMeta CPUDoubleType::typeMeta() const {
    return caffe2::TypeMeta::Make<double>();
}

Backend CPUDoubleType::backend() const {
  return Backend::CPU;
}

const char * CPUDoubleType::toString() const {
  return "CPUDoubleType";
}

TypeID CPUDoubleType::ID() const {
  return TypeID::CPUDouble;
}

size_t CPUDoubleType::elementSizeInBytes() const {
  return sizeof(double);
}

/* example
Tensor * CPUDoubleType::add(Tensor & a, Tensor & b) {
  std::cout << "add CPUDoubleTensor\n";
  return &a;
}
*/

int64_t CPUDoubleType::_th_storage_offset(const Tensor & self) const {
    // DeviceGuard omitted
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    return static_cast<int64_t>(THDoubleTensor_storageOffset(self_));
}
int64_t CPUDoubleType::_th_ndimension(const Tensor & self) const {
    // DeviceGuard omitted
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    return static_cast<int64_t>(THDoubleTensor_nDimension(self_));
}
Tensor & CPUDoubleType::_th_set_(Tensor & self, Storage source) const {
    // DeviceGuard omitted
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto source_ = checked_storage(source,"source",2, DeviceType::CPU, at::scalarTypeToDataType(ScalarType::Double));
    THDoubleTensor_setStorage(self_, source_.unsafeGetStorageImpl(), 0, {static_cast<int64_t>(source.size())}, {});
    self_->maybe_zero_dim(false);
    return self;
}
Tensor & CPUDoubleType::_th_set_(Tensor & self, Storage source, int64_t storage_offset, IntList size, IntList stride) const {
    // DeviceGuard omitted
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto source_ = checked_storage(source,"source",2, DeviceType::CPU, at::scalarTypeToDataType(ScalarType::Double));
    THDoubleTensor_setStorage(self_, source_.unsafeGetStorageImpl(), storage_offset, size, stride);
    self_->maybe_zero_dim(size.size() == 0);
    return self;
}
Tensor & CPUDoubleType::_th_set_(Tensor & self, const Tensor & source) const {
    // DeviceGuard omitted
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto source_ = checked_tensor_unwrap(source,"source",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_set(self_, source_);
    self_->maybe_zero_dim(source_->dim() == 0);
    return self;
}
Tensor & CPUDoubleType::_th_set_(Tensor & self) const {
    // DeviceGuard omitted
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_setStorage(self_, NULL, 0, {0}, {});
    self_->maybe_zero_dim(false);
    return self;
}
Tensor & CPUDoubleType::_fill_(Tensor & self, Scalar value) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto value_ = value.toDouble();
    THDoubleTensor_fill(self_, value_);
    return self;
}
Tensor & CPUDoubleType::_fill_(Tensor & self, const Tensor & value) const {
    const DeviceGuard device_guard(self);
    if (value.dim() == 0) {
        return static_cast<const TypeExtendedInterface*>(this)->_fill_(self, at::_local_scalar(value));
    }
    AT_ERROR("_fill_ only supports a 0-dimensional value tensor, but got tensor "
        "with ", value.dim(), " dimension(s).");
}
bool CPUDoubleType::_th_is_contiguous(const Tensor & self) const {
    // DeviceGuard omitted
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    return THDoubleTensor_isContiguous(self_);
}
bool CPUDoubleType::_th_is_set_to(const Tensor & self, const Tensor & tensor) const {
    // DeviceGuard omitted
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto tensor_ = checked_tensor_unwrap(tensor,"tensor",2, false, Backend::CPU, ScalarType::Double);
    return THDoubleTensor_isSetTo(self_, tensor_);
}
Tensor & CPUDoubleType::s__th_masked_fill_(Tensor & self, const Tensor & mask, Scalar value) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto mask_ = checked_tensor_unwrap(mask,"mask",2, false, Backend::CPU, ScalarType::Byte);
    auto value_ = value.toDouble();
    THDoubleTensor_maskedFill(self_, mask_, value_);
    return self;
}
Tensor & CPUDoubleType::s__th_masked_fill_(Tensor & self, const Tensor & mask, const Tensor & value) const {
    const DeviceGuard device_guard(self);
    if (value.dim() == 0) {
        return static_cast<const TypeExtendedInterface*>(this)->_th_masked_fill_(self, mask, at::_local_scalar(value));
    }
    AT_ERROR("_th_masked_fill_ only supports a 0-dimensional value tensor, but got tensor "
        "with ", value.dim(), " dimension(s).");
}
Tensor & CPUDoubleType::s__th_masked_scatter_(Tensor & self, const Tensor & mask, const Tensor & source) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto mask_ = checked_tensor_unwrap(mask,"mask",2, false, Backend::CPU, ScalarType::Byte);
    auto source_ = checked_tensor_unwrap(source,"source",3, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_maskedCopy(self_, mask_, source_);
    return self;
}
Tensor & CPUDoubleType::s__th_masked_select_out(Tensor & result, const Tensor & self, const Tensor & mask) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto mask_ = checked_tensor_unwrap(mask,"mask",2, false, Backend::CPU, ScalarType::Byte);
    THDoubleTensor_maskedSelect(result_, self_, mask_);
    result_->maybe_zero_dim(self_->dim() == 0 && mask_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::s__th_masked_select(const Tensor & self, const Tensor & mask) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto mask_ = checked_tensor_unwrap(mask,"mask",2, false, Backend::CPU, ScalarType::Byte);
    THDoubleTensor_maskedSelect(result_, self_, mask_);
    result_->maybe_zero_dim(self_->dim() == 0 && mask_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_th_nonzero_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Long);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_nonzero(result_, self_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_nonzero(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), scalarTypeToTypeMeta(ScalarType::Long), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_nonzero(result_, self_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_clone(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    return Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim((THDoubleTensor_newClone(self_))->maybe_zero_dim(self_->dim() == 0)));
}
Tensor CPUDoubleType::_th_view(const Tensor & self, IntList size) const {
    // DeviceGuard omitted
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    return Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim((THDoubleTensor_newView(self_, size))->maybe_zero_dim(size.size() == 0)));
}
Tensor & CPUDoubleType::_th_resize_as_(Tensor & self, const Tensor & the_template) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto the_template_ = checked_tensor_unwrap(the_template,"the_template",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_resizeAs(self_, the_template_);
    self_->maybe_zero_dim(the_template_->dim() == 0);
    return self;
}
Tensor & CPUDoubleType::_th_index_select_out(Tensor & result, const Tensor & self, int64_t dim, const Tensor & index) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    auto index_ = checked_tensor_unwrap(index,"index",3, false, Backend::CPU, ScalarType::Long);
    THDoubleTensor_indexSelect(result_, self_, dim, index_);
    result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_index_select(const Tensor & self, int64_t dim, const Tensor & index) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    auto index_ = checked_tensor_unwrap(index,"index",3, false, Backend::CPU, ScalarType::Long);
    THDoubleTensor_indexSelect(result_, self_, dim, index_);
    result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_indexCopy_(Tensor & self, int64_t dim, const Tensor & index, const Tensor & source) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    auto index_ = checked_tensor_unwrap(index,"index",3, false, Backend::CPU, ScalarType::Long);
    auto source_ = checked_tensor_unwrap(source,"source",4, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_indexCopy(self_, dim, index_, source_);
    return self;
}
Tensor & CPUDoubleType::_th_take_out(Tensor & result, const Tensor & self, const Tensor & index) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto index_ = checked_tensor_unwrap(index,"index",2, false, Backend::CPU, ScalarType::Long);
    THDoubleTensor_take(result_, self_, index_);
    result_->maybe_zero_dim(index_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_take(const Tensor & self, const Tensor & index) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto index_ = checked_tensor_unwrap(index,"index",2, false, Backend::CPU, ScalarType::Long);
    THDoubleTensor_take(result_, self_, index_);
    result_->maybe_zero_dim(index_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_th_put_(Tensor & self, const Tensor & index, const Tensor & source, bool accumulate) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto index_ = checked_tensor_unwrap(index,"index",2, false, Backend::CPU, ScalarType::Long);
    auto source_ = checked_tensor_unwrap(source,"source",3, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_put(self_, index_, source_, accumulate);
    return self;
}
Tensor & CPUDoubleType::_th_index_add_(Tensor & self, int64_t dim, const Tensor & index, const Tensor & source) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    auto index_ = checked_tensor_unwrap(index,"index",3, false, Backend::CPU, ScalarType::Long);
    auto source_ = checked_tensor_unwrap(source,"source",4, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_indexAdd(self_, dim, index_, source_);
    return self;
}
Tensor & CPUDoubleType::_th_index_fill_(Tensor & self, int64_t dim, const Tensor & index, Scalar value) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    auto index_ = checked_tensor_unwrap(index,"index",3, false, Backend::CPU, ScalarType::Long);
    auto value_ = value.toDouble();
    THDoubleTensor_indexFill(self_, dim, index_, value_);
    return self;
}
Tensor & CPUDoubleType::_th_index_fill_(Tensor & self, int64_t dim, const Tensor & index, const Tensor & value) const {
    const DeviceGuard device_guard(self);
    if (value.dim() == 0) {
        return static_cast<const TypeExtendedInterface*>(this)->_th_index_fill_(self, dim, index, at::_local_scalar(value));
    }
    AT_ERROR("_th_index_fill_ only supports a 0-dimensional value tensor, but got tensor "
        "with ", value.dim(), " dimension(s).");
}
Tensor CPUDoubleType::_th_unfold(const Tensor & self, int64_t dimension, int64_t size, int64_t step) const {
    // DeviceGuard omitted
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    dimension = maybe_wrap_dim(dimension, self_);
    THDoubleTensor_unfold(result_, self_, dimension, size, step);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_range_out(Tensor & result, Scalar start, Scalar end, Scalar step) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto start_ = start.toDouble();
    auto end_ = end.toDouble();
    auto step_ = step.toDouble();
    THDoubleTensor_range(result_, start_, end_, step_);
    return result;
}
Tensor CPUDoubleType::_range(Scalar start, Scalar end, Scalar step) const {
    // DeviceGuard omitted
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto start_ = start.toDouble();
    auto end_ = end.toDouble();
    auto step_ = step.toDouble();
    THDoubleTensor_range(result_, start_, end_, step_);
    return result;
}
Tensor & CPUDoubleType::_arange_out(Tensor & result, Scalar start, Scalar end, Scalar step) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto start_ = start.toDouble();
    auto end_ = end.toDouble();
    auto step_ = step.toDouble();
    THDoubleTensor_arange(result_, start_, end_, step_);
    return result;
}
Tensor CPUDoubleType::_arange(Scalar start, Scalar end, Scalar step) const {
    // DeviceGuard omitted
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto start_ = start.toDouble();
    auto end_ = end.toDouble();
    auto step_ = step.toDouble();
    THDoubleTensor_arange(result_, start_, end_, step_);
    return result;
}
Tensor & CPUDoubleType::_arange_out(Tensor & result, Scalar end) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto end_ = end.toDouble();
    THDoubleTensor_arange(result_, 0, end_, 1);
    return result;
}
Tensor CPUDoubleType::_arange(Scalar end) const {
    // DeviceGuard omitted
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto end_ = end.toDouble();
    THDoubleTensor_arange(result_, 0, end_, 1);
    return result;
}
Tensor & CPUDoubleType::_th_scatter_(Tensor & self, int64_t dim, const Tensor & index, const Tensor & src) const {
    const DeviceGuard device_guard(self);
    if (src.dim() == 0) {
        return static_cast<const TypeExtendedInterface*>(this)->_th_scatter_(self, dim, index, at::_local_scalar(src));
    }
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    auto index_ = checked_tensor_unwrap(index,"index",3, false, Backend::CPU, ScalarType::Long);
    auto src_ = checked_tensor_unwrap(src,"src",4, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_scatter(self_, dim, index_, src_);
    return self;
}
Tensor & CPUDoubleType::_th_scatter_(Tensor & self, int64_t dim, const Tensor & index, Scalar value) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    auto index_ = checked_tensor_unwrap(index,"index",3, false, Backend::CPU, ScalarType::Long);
    auto value_ = value.toDouble();
    THDoubleTensor_scatterFill(self_, dim, index_, value_);
    return self;
}
Tensor & CPUDoubleType::_th_scatter_add_(Tensor & self, int64_t dim, const Tensor & index, const Tensor & src) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    auto index_ = checked_tensor_unwrap(index,"index",3, false, Backend::CPU, ScalarType::Long);
    auto src_ = checked_tensor_unwrap(src,"src",4, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_scatterAdd(self_, dim, index_, src_);
    return self;
}
Tensor & CPUDoubleType::_th_gather_out(Tensor & result, const Tensor & self, int64_t dim, const Tensor & index) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    result.resize_(index.sizes());
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    auto index_ = checked_tensor_unwrap(index,"index",3, false, Backend::CPU, ScalarType::Long);
    THDoubleTensor_gather(result_, self_, dim, index_);
    result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_gather(const Tensor & self, int64_t dim, const Tensor & index) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    result.resize_(index.sizes());
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    auto index_ = checked_tensor_unwrap(index,"index",3, false, Backend::CPU, ScalarType::Long);
    THDoubleTensor_gather(result_, self_, dim, index_);
    result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
    return result;
}
void* CPUDoubleType::data_ptr(const Tensor & self) const {
    // DeviceGuard omitted
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    return THDoubleTensor_data(self_);
}
bool CPUDoubleType::_th_equal(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    return THDoubleTensor_equal(self_, other_);
}
Tensor & CPUDoubleType::__and___out(Tensor & result, const Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_bitand(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::__and__(const Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_bitand(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::s___and___out(Tensor & result, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_cbitand(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::s___and__(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_cbitand(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::__iand__(Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_bitand(self_, self_, other_);
    return self;
}
Tensor & CPUDoubleType::s___iand__(Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",3, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_cbitand(self_, self_, other_);
    return self;
}
Tensor & CPUDoubleType::__or___out(Tensor & result, const Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_bitor(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::__or__(const Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_bitor(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::s___or___out(Tensor & result, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_cbitor(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::s___or__(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_cbitor(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::__ior__(Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_bitor(self_, self_, other_);
    return self;
}
Tensor & CPUDoubleType::s___ior__(Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",3, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_cbitor(self_, self_, other_);
    return self;
}
Tensor & CPUDoubleType::__xor___out(Tensor & result, const Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_bitxor(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::__xor__(const Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_bitxor(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::s___xor___out(Tensor & result, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_cbitxor(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::s___xor__(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_cbitxor(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::__ixor__(Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_bitxor(self_, self_, other_);
    return self;
}
Tensor & CPUDoubleType::s___ixor__(Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",3, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_cbitxor(self_, self_, other_);
    return self;
}
Tensor & CPUDoubleType::__lshift___out(Tensor & result, const Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_lshift(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::__lshift__(const Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_lshift(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::s___lshift___out(Tensor & result, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_clshift(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::s___lshift__(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_clshift(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::__ilshift__(Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_lshift(self_, self_, other_);
    return self;
}
Tensor & CPUDoubleType::s___ilshift__(Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",3, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_clshift(self_, self_, other_);
    return self;
}
Tensor & CPUDoubleType::__rshift___out(Tensor & result, const Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_rshift(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::__rshift__(const Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_rshift(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::s___rshift___out(Tensor & result, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_crshift(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::s___rshift__(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_crshift(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::__irshift__(Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_rshift(self_, self_, other_);
    return self;
}
Tensor & CPUDoubleType::s___irshift__(Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",3, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_crshift(self_, self_, other_);
    return self;
}
Tensor & CPUDoubleType::_th_lt_out(Tensor & result, const Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Byte);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_ltValue(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_lt(const Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), scalarTypeToTypeMeta(ScalarType::Byte), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_ltValue(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::s__th_lt_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Byte);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_ltTensor(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::s__th_lt(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), scalarTypeToTypeMeta(ScalarType::Byte), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_ltTensor(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_th_lt_(Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_ltValueT(self_, self_, other_);
    return self;
}
Tensor & CPUDoubleType::s__th_lt_(Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",3, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_ltTensorT(self_, self_, other_);
    return self;
}
Tensor & CPUDoubleType::_th_gt_out(Tensor & result, const Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Byte);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_gtValue(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_gt(const Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), scalarTypeToTypeMeta(ScalarType::Byte), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_gtValue(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::s__th_gt_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Byte);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_gtTensor(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::s__th_gt(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), scalarTypeToTypeMeta(ScalarType::Byte), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_gtTensor(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_th_gt_(Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_gtValueT(self_, self_, other_);
    return self;
}
Tensor & CPUDoubleType::s__th_gt_(Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",3, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_gtTensorT(self_, self_, other_);
    return self;
}
Tensor & CPUDoubleType::_th_le_out(Tensor & result, const Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Byte);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_leValue(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_le(const Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), scalarTypeToTypeMeta(ScalarType::Byte), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_leValue(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::s__th_le_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Byte);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_leTensor(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::s__th_le(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), scalarTypeToTypeMeta(ScalarType::Byte), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_leTensor(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_th_le_(Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_leValueT(self_, self_, other_);
    return self;
}
Tensor & CPUDoubleType::s__th_le_(Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",3, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_leTensorT(self_, self_, other_);
    return self;
}
Tensor & CPUDoubleType::_th_ge_out(Tensor & result, const Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Byte);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_geValue(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_ge(const Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), scalarTypeToTypeMeta(ScalarType::Byte), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_geValue(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::s__th_ge_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Byte);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_geTensor(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::s__th_ge(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), scalarTypeToTypeMeta(ScalarType::Byte), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_geTensor(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_th_ge_(Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_geValueT(self_, self_, other_);
    return self;
}
Tensor & CPUDoubleType::s__th_ge_(Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",3, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_geTensorT(self_, self_, other_);
    return self;
}
Tensor & CPUDoubleType::_th_eq_out(Tensor & result, const Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Byte);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_eqValue(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_eq(const Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), scalarTypeToTypeMeta(ScalarType::Byte), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_eqValue(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::s__th_eq_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Byte);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_eqTensor(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::s__th_eq(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), scalarTypeToTypeMeta(ScalarType::Byte), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_eqTensor(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_th_eq_(Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_eqValueT(self_, self_, other_);
    return self;
}
Tensor & CPUDoubleType::s__th_eq_(Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",3, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_eqTensorT(self_, self_, other_);
    return self;
}
Tensor & CPUDoubleType::_th_ne_out(Tensor & result, const Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Byte);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_neValue(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_ne(const Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), scalarTypeToTypeMeta(ScalarType::Byte), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_neValue(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::s__th_ne_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Byte);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_neTensor(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::s__th_ne(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), scalarTypeToTypeMeta(ScalarType::Byte), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_neTensor(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_th_ne_(Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_neValueT(self_, self_, other_);
    return self;
}
Tensor & CPUDoubleType::s__th_ne_(Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",3, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_neTensorT(self_, self_, other_);
    return self;
}
Tensor & CPUDoubleType::s__th_min_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_cmin(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::s__th_min(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_cmin(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_min(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    return scalarTensor(convert<double>(THDoubleTensor_minall(self_)));
}
std::tuple<Tensor &,Tensor &> CPUDoubleType::_th_min_out(Tensor & min, Tensor & min_indices, const Tensor & self, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(min);
    auto min_ = checked_tensor_unwrap(min,"min",0, false, Backend::CPU, ScalarType::Double);
    auto min_indices_ = checked_tensor_unwrap(min_indices,"min_indices",0, false, Backend::CPU, ScalarType::Long);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    THDoubleTensor_min(min_, min_indices_, self_, dim, keepdim);
    bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
    min_->maybe_zero_dim(maybe_scalar);
    min_indices_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor &, Tensor &>(min, min_indices);
}
std::tuple<Tensor,Tensor> CPUDoubleType::_th_min(const Tensor & self, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(self);
    auto min_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto min = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(min_));
    auto min_indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), scalarTypeToTypeMeta(ScalarType::Long), allocator(), false).release();
    auto min_indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(min_indices_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    THDoubleTensor_min(min_, min_indices_, self_, dim, keepdim);
    bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
    min_->maybe_zero_dim(maybe_scalar);
    min_indices_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor, Tensor>(min, min_indices);
}
Tensor & CPUDoubleType::s__th_max_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_cmax(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::s__th_max(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_cmax(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_max(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    return scalarTensor(convert<double>(THDoubleTensor_maxall(self_)));
}
std::tuple<Tensor &,Tensor &> CPUDoubleType::_th_max_out(Tensor & max, Tensor & max_indices, const Tensor & self, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(max);
    auto max_ = checked_tensor_unwrap(max,"max",0, false, Backend::CPU, ScalarType::Double);
    auto max_indices_ = checked_tensor_unwrap(max_indices,"max_indices",0, false, Backend::CPU, ScalarType::Long);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    THDoubleTensor_max(max_, max_indices_, self_, dim, keepdim);
    bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
    max_->maybe_zero_dim(maybe_scalar);
    max_indices_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor &, Tensor &>(max, max_indices);
}
std::tuple<Tensor,Tensor> CPUDoubleType::_th_max(const Tensor & self, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(self);
    auto max_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto max = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(max_));
    auto max_indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), scalarTypeToTypeMeta(ScalarType::Long), allocator(), false).release();
    auto max_indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(max_indices_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    THDoubleTensor_max(max_, max_indices_, self_, dim, keepdim);
    bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
    max_->maybe_zero_dim(maybe_scalar);
    max_indices_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor, Tensor>(max, max_indices);
}
std::tuple<Tensor &,Tensor &> CPUDoubleType::_th_kthvalue_out(Tensor & values, Tensor & indices, const Tensor & self, int64_t k, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(values);
    auto values_ = checked_tensor_unwrap(values,"values",0, false, Backend::CPU, ScalarType::Double);
    auto indices_ = checked_tensor_unwrap(indices,"indices",0, false, Backend::CPU, ScalarType::Long);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    THDoubleTensor_kthvalue(values_, indices_, self_, k, dim, keepdim);
    bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
    values_->maybe_zero_dim(maybe_scalar);
    indices_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor &, Tensor &>(values, indices);
}
std::tuple<Tensor,Tensor> CPUDoubleType::_th_kthvalue(const Tensor & self, int64_t k, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(self);
    auto values_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto values = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(values_));
    auto indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), scalarTypeToTypeMeta(ScalarType::Long), allocator(), false).release();
    auto indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(indices_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    THDoubleTensor_kthvalue(values_, indices_, self_, k, dim, keepdim);
    bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
    values_->maybe_zero_dim(maybe_scalar);
    indices_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor, Tensor>(values, indices);
}
std::tuple<Tensor &,Tensor &> CPUDoubleType::_th_mode_out(Tensor & values, Tensor & indices, const Tensor & self, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(values);
    auto values_ = checked_tensor_unwrap(values,"values",0, false, Backend::CPU, ScalarType::Double);
    auto indices_ = checked_tensor_unwrap(indices,"indices",0, false, Backend::CPU, ScalarType::Long);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    THDoubleTensor_mode(values_, indices_, self_, dim, keepdim);
    bool maybe_scalar = self_->dim() == 0|| (keepdim == false && self_->dim() == 1);
    values_->maybe_zero_dim(maybe_scalar);
    indices_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor &, Tensor &>(values, indices);
}
std::tuple<Tensor,Tensor> CPUDoubleType::_th_mode(const Tensor & self, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(self);
    auto values_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto values = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(values_));
    auto indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), scalarTypeToTypeMeta(ScalarType::Long), allocator(), false).release();
    auto indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(indices_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    THDoubleTensor_mode(values_, indices_, self_, dim, keepdim);
    bool maybe_scalar = self_->dim() == 0|| (keepdim == false && self_->dim() == 1);
    values_->maybe_zero_dim(maybe_scalar);
    indices_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor, Tensor>(values, indices);
}
Tensor CPUDoubleType::_th_median(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    return scalarTensor(convert<double>(THDoubleTensor_medianall(self_)));
}
std::tuple<Tensor &,Tensor &> CPUDoubleType::_th_median_out(Tensor & values, Tensor & indices, const Tensor & self, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(values);
    auto values_ = checked_tensor_unwrap(values,"values",0, false, Backend::CPU, ScalarType::Double);
    auto indices_ = checked_tensor_unwrap(indices,"indices",0, false, Backend::CPU, ScalarType::Long);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    THDoubleTensor_median(values_, indices_, self_, dim, keepdim);
    bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
    values_->maybe_zero_dim(maybe_scalar);
    indices_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor &, Tensor &>(values, indices);
}
std::tuple<Tensor,Tensor> CPUDoubleType::_th_median(const Tensor & self, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(self);
    auto values_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto values = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(values_));
    auto indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), scalarTypeToTypeMeta(ScalarType::Long), allocator(), false).release();
    auto indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(indices_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    THDoubleTensor_median(values_, indices_, self_, dim, keepdim);
    bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
    values_->maybe_zero_dim(maybe_scalar);
    indices_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor, Tensor>(values, indices);
}
std::tuple<Tensor &,Tensor &> CPUDoubleType::_th_sort_out(Tensor & values, Tensor & indices, const Tensor & self, int64_t dim, bool descending) const {
    const DeviceGuard device_guard(values);
    auto values_ = checked_tensor_unwrap(values,"values",0, false, Backend::CPU, ScalarType::Double);
    auto indices_ = checked_tensor_unwrap(indices,"indices",0, false, Backend::CPU, ScalarType::Long);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    THDoubleTensor_sort(values_, indices_, self_, dim, descending);
    bool maybe_scalar = self_->dim() == 0;
    values_->maybe_zero_dim(maybe_scalar);
    indices_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor &, Tensor &>(values, indices);
}
std::tuple<Tensor,Tensor> CPUDoubleType::_th_sort(const Tensor & self, int64_t dim, bool descending) const {
    const DeviceGuard device_guard(self);
    auto values_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto values = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(values_));
    auto indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), scalarTypeToTypeMeta(ScalarType::Long), allocator(), false).release();
    auto indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(indices_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    THDoubleTensor_sort(values_, indices_, self_, dim, descending);
    bool maybe_scalar = self_->dim() == 0;
    values_->maybe_zero_dim(maybe_scalar);
    indices_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor, Tensor>(values, indices);
}
std::tuple<Tensor &,Tensor &> CPUDoubleType::_th_topk_out(Tensor & values, Tensor & indices, const Tensor & self, int64_t k, int64_t dim, bool largest, bool sorted) const {
    const DeviceGuard device_guard(values);
    auto values_ = checked_tensor_unwrap(values,"values",0, false, Backend::CPU, ScalarType::Double);
    auto indices_ = checked_tensor_unwrap(indices,"indices",0, false, Backend::CPU, ScalarType::Long);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    THDoubleTensor_topk(values_, indices_, self_, k, dim, largest, sorted);
    bool maybe_scalar = self_->dim() == 0;
    values_->maybe_zero_dim(maybe_scalar);
    indices_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor &, Tensor &>(values, indices);
}
std::tuple<Tensor,Tensor> CPUDoubleType::_th_topk(const Tensor & self, int64_t k, int64_t dim, bool largest, bool sorted) const {
    const DeviceGuard device_guard(self);
    auto values_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto values = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(values_));
    auto indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), scalarTypeToTypeMeta(ScalarType::Long), allocator(), false).release();
    auto indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(indices_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    THDoubleTensor_topk(values_, indices_, self_, k, dim, largest, sorted);
    bool maybe_scalar = self_->dim() == 0;
    values_->maybe_zero_dim(maybe_scalar);
    indices_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor, Tensor>(values, indices);
}
Tensor & CPUDoubleType::_abs_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_abs(result_, self_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_abs(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_abs(result_, self_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_log10_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_log10(result_, self_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_log10(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_log10(result_, self_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_log2_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_log2(result_, self_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_log2(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_log2(result_, self_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_th_lgamma_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_lgamma(result_, self_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_lgamma(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_lgamma(result_, self_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_th_lgamma_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_lgamma(self_, self_);
    return self;
}
Tensor & CPUDoubleType::_th_digamma_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_digamma(result_, self_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_digamma(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_digamma(result_, self_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_th_digamma_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_digamma(self_, self_);
    return self;
}
Tensor & CPUDoubleType::_th_polygamma_out(Tensor & result, int64_t n, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_polygamma(result_, n, self_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_polygamma(int64_t n, const Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_polygamma(result_, n, self_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_th_polygamma_(Tensor & self, int64_t n) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_polygamma(self_, n, self_);
    return self;
}
Tensor & CPUDoubleType::_cosh_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_cosh(result_, self_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_cosh(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_cosh(result_, self_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_sinh_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_sinh(result_, self_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_sinh(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_sinh(result_, self_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_th_erfinv_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_erfinv(self_, self_);
    return self;
}
Tensor & CPUDoubleType::_th_erfinv_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_erfinv(result_, self_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_erfinv(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_erfinv(result_, self_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_th_frac_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_frac(self_, self_);
    return self;
}
Tensor & CPUDoubleType::_th_frac_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_frac(result_, self_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_frac(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_frac(result_, self_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_th_var_out(Tensor & result, const Tensor & self, int64_t dim, bool unbiased, bool keepdim) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    THDoubleTensor_var(result_, self_, dim, (unbiased) ? 0 : 1, keepdim);
    result_->maybe_zero_dim(self_->dim() == 0 || (keepdim == false && self_->dim() == 1));
    return result;
}
Tensor CPUDoubleType::_th_var(const Tensor & self, int64_t dim, bool unbiased, bool keepdim) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    THDoubleTensor_var(result_, self_, dim, (unbiased) ? 0 : 1, keepdim);
    result_->maybe_zero_dim(self_->dim() == 0 || (keepdim == false && self_->dim() == 1));
    return result;
}
Tensor CPUDoubleType::_th_var(const Tensor & self, bool unbiased) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    return scalarTensor(convert<double>(THDoubleTensor_varall(self_, (unbiased) ? 0 : 1)));
}
Tensor & CPUDoubleType::_th_std_out(Tensor & result, const Tensor & self, int64_t dim, bool unbiased, bool keepdim) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    THDoubleTensor_std(result_, self_, dim, (unbiased) ? 0 : 1, keepdim);
    result_->maybe_zero_dim(self_->dim() == 0 || (keepdim == false && self_->dim() == 1));
    return result;
}
Tensor CPUDoubleType::_th_std(const Tensor & self, int64_t dim, bool unbiased, bool keepdim) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    THDoubleTensor_std(result_, self_, dim, (unbiased) ? 0 : 1, keepdim);
    result_->maybe_zero_dim(self_->dim() == 0 || (keepdim == false && self_->dim() == 1));
    return result;
}
Tensor CPUDoubleType::_th_std(const Tensor & self, bool unbiased) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    return scalarTensor(convert<double>(THDoubleTensor_stdall(self_, (unbiased) ? 0 : 1)));
}
Tensor CPUDoubleType::_th_norm(const Tensor & self, Scalar p) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto p_ = p.toDouble();
    return scalarTensor(convert<double>(THDoubleTensor_normall(self_, p_)));
}
Tensor & CPUDoubleType::_th_norm_out(Tensor & result, const Tensor & self, Scalar p, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto p_ = p.toDouble();
    dim = maybe_wrap_dim(dim, self_);
    THDoubleTensor_norm(result_, self_, p_, dim, keepdim);
    result_->maybe_zero_dim(self_->dim() == 0 || (keepdim == false && self_->dim() == 1));
    return result;
}
Tensor CPUDoubleType::_th_norm(const Tensor & self, Scalar p, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto p_ = p.toDouble();
    dim = maybe_wrap_dim(dim, self_);
    THDoubleTensor_norm(result_, self_, p_, dim, keepdim);
    result_->maybe_zero_dim(self_->dim() == 0 || (keepdim == false && self_->dim() == 1));
    return result;
}
Tensor & CPUDoubleType::_th_renorm_out(Tensor & result, const Tensor & self, Scalar p, int64_t dim, Scalar maxnorm) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto p_ = p.toDouble();
    dim = maybe_wrap_dim(dim, self_);
    auto maxnorm_ = maxnorm.toDouble();
    THDoubleTensor_renorm(result_, self_, p_, dim, maxnorm_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_renorm(const Tensor & self, Scalar p, int64_t dim, Scalar maxnorm) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto p_ = p.toDouble();
    dim = maybe_wrap_dim(dim, self_);
    auto maxnorm_ = maxnorm.toDouble();
    THDoubleTensor_renorm(result_, self_, p_, dim, maxnorm_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_th_renorm_(Tensor & self, Scalar p, int64_t dim, Scalar maxnorm) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto p_ = p.toDouble();
    dim = maybe_wrap_dim(dim, self_);
    auto maxnorm_ = maxnorm.toDouble();
    THDoubleTensor_renorm(self_, self_, p_, dim, maxnorm_);
    return self;
}
Tensor CPUDoubleType::s__th_dist(const Tensor & self, const Tensor & other, Scalar p) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    auto p_ = p.toDouble();
    return scalarTensor(convert<double>(THDoubleTensor_dist(self_, other_, p_)));
}
Tensor & CPUDoubleType::_th_reciprocal_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_cinv(result_, self_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_reciprocal(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_cinv(result_, self_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_th_reciprocal_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_cinv(self_, self_);
    return self;
}
Tensor & CPUDoubleType::_th_neg_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_neg(result_, self_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_neg(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_neg(result_, self_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_th_neg_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_neg(self_, self_);
    return self;
}
Tensor & CPUDoubleType::s__th_atan2_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_atan2(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::s__th_atan2(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_atan2(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::s__th_atan2_(Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",3, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_atan2(self_, self_, other_);
    return self;
}
Tensor & CPUDoubleType::_th_pow_out(Tensor & result, const Tensor & self, Scalar exponent) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto exponent_ = exponent.toDouble();
    THDoubleTensor_pow(result_, self_, exponent_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_pow(const Tensor & self, Scalar exponent) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto exponent_ = exponent.toDouble();
    THDoubleTensor_pow(result_, self_, exponent_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::s__th_pow_out(Tensor & result, const Tensor & self, const Tensor & exponent) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto exponent_ = checked_tensor_unwrap(exponent,"exponent",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_cpow(result_, self_, exponent_);
    result_->maybe_zero_dim(self_->dim() == 0 && exponent_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::s__th_pow(const Tensor & self, const Tensor & exponent) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto exponent_ = checked_tensor_unwrap(exponent,"exponent",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_cpow(result_, self_, exponent_);
    result_->maybe_zero_dim(self_->dim() == 0 && exponent_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_th_pow_out(Tensor & result, Scalar self, const Tensor & exponent) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = self.toDouble();
    auto exponent_ = checked_tensor_unwrap(exponent,"exponent",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_tpow(result_, self_, exponent_);
    result_->maybe_zero_dim(exponent_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_pow(Scalar self, const Tensor & exponent) const {
    const DeviceGuard device_guard(exponent);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = self.toDouble();
    auto exponent_ = checked_tensor_unwrap(exponent,"exponent",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_tpow(result_, self_, exponent_);
    result_->maybe_zero_dim(exponent_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_th_pow_(Tensor & self, Scalar exponent) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto exponent_ = exponent.toDouble();
    THDoubleTensor_pow(self_, self_, exponent_);
    return self;
}
Tensor & CPUDoubleType::s__th_pow_(Tensor & self, const Tensor & exponent) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto exponent_ = checked_tensor_unwrap(exponent,"exponent",3, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_cpow(self_, self_, exponent_);
    return self;
}
Tensor & CPUDoubleType::s__th_lerp_out(Tensor & result, const Tensor & self, const Tensor & end, Scalar weight) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto end_ = checked_tensor_unwrap(end,"end",2, false, Backend::CPU, ScalarType::Double);
    auto weight_ = weight.toDouble();
    THDoubleTensor_lerp(result_, self_, end_, weight_);
    result_->maybe_zero_dim(self_->dim() == 0 && end_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::s__th_lerp(const Tensor & self, const Tensor & end, Scalar weight) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto end_ = checked_tensor_unwrap(end,"end",2, false, Backend::CPU, ScalarType::Double);
    auto weight_ = weight.toDouble();
    THDoubleTensor_lerp(result_, self_, end_, weight_);
    result_->maybe_zero_dim(self_->dim() == 0 && end_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::s__th_lerp_(Tensor & self, const Tensor & end, Scalar weight) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto end_ = checked_tensor_unwrap(end,"end",3, false, Backend::CPU, ScalarType::Double);
    auto weight_ = weight.toDouble();
    THDoubleTensor_lerp(self_, self_, end_, weight_);
    return self;
}
Tensor & CPUDoubleType::_linspace_out(Tensor & result, Scalar start, Scalar end, int64_t steps) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto start_ = start.toDouble();
    auto end_ = end.toDouble();
    THDoubleTensor_linspace(result_, start_, end_, steps);
    return result;
}
Tensor CPUDoubleType::_linspace(Scalar start, Scalar end, int64_t steps) const {
    // DeviceGuard omitted
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto start_ = start.toDouble();
    auto end_ = end.toDouble();
    THDoubleTensor_linspace(result_, start_, end_, steps);
    return result;
}
Tensor & CPUDoubleType::_logspace_out(Tensor & result, Scalar start, Scalar end, int64_t steps) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto start_ = start.toDouble();
    auto end_ = end.toDouble();
    THDoubleTensor_logspace(result_, start_, end_, steps);
    return result;
}
Tensor CPUDoubleType::_logspace(Scalar start, Scalar end, int64_t steps) const {
    // DeviceGuard omitted
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto start_ = start.toDouble();
    auto end_ = end.toDouble();
    THDoubleTensor_logspace(result_, start_, end_, steps);
    return result;
}
Tensor & CPUDoubleType::_th_histc_out(Tensor & result, const Tensor & self, int64_t bins, Scalar min, Scalar max) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto min_ = min.toDouble();
    auto max_ = max.toDouble();
    THDoubleTensor_histc(result_, self_, bins, min_, max_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_histc(const Tensor & self, int64_t bins, Scalar min, Scalar max) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto min_ = min.toDouble();
    auto max_ = max.toDouble();
    THDoubleTensor_histc(result_, self_, bins, min_, max_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_th_zero_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_zero(self_);
    return self;
}
Tensor & CPUDoubleType::_cumsum_out(Tensor & result, const Tensor & self, int64_t dim) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    THDoubleTensor_cumsum(result_, self_, dim);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_cumsum(const Tensor & self, int64_t dim) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    THDoubleTensor_cumsum(result_, self_, dim);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_cumprod_out(Tensor & result, const Tensor & self, int64_t dim) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    THDoubleTensor_cumprod(result_, self_, dim);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_cumprod(const Tensor & self, int64_t dim) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    THDoubleTensor_cumprod(result_, self_, dim);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_th_sign_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_sign(result_, self_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_sign(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_sign(result_, self_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_th_sign_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_sign(self_, self_);
    return self;
}
Tensor CPUDoubleType::_th_trace(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    return scalarTensor(convert<double>(THDoubleTensor_trace(self_)));
}
Tensor & CPUDoubleType::_th_fmod_out(Tensor & result, const Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_fmod(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_fmod(const Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_fmod(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::s__th_fmod_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_cfmod(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::s__th_fmod(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_cfmod(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_th_fmod_(Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_fmod(self_, self_, other_);
    return self;
}
Tensor & CPUDoubleType::s__th_fmod_(Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",3, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_cfmod(self_, self_, other_);
    return self;
}
Tensor & CPUDoubleType::_th_remainder_out(Tensor & result, const Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_remainder(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_remainder(const Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_remainder(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::s__th_remainder_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_cremainder(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::s__th_remainder(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_cremainder(result_, self_, other_);
    result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_th_remainder_(Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = other.toDouble();
    THDoubleTensor_remainder(self_, self_, other_);
    return self;
}
Tensor & CPUDoubleType::s__th_remainder_(Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",3, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_cremainder(self_, self_, other_);
    return self;
}
Tensor & CPUDoubleType::_th_clamp_out(Tensor & result, const Tensor & self, Scalar min, Scalar max) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto min_ = min.toDouble();
    auto max_ = max.toDouble();
    THDoubleTensor_clamp(result_, self_, min_, max_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_clamp(const Tensor & self, Scalar min, Scalar max) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto min_ = min.toDouble();
    auto max_ = max.toDouble();
    THDoubleTensor_clamp(result_, self_, min_, max_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_th_clamp_min_out(Tensor & result, const Tensor & self, Scalar min) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto min_ = min.toDouble();
    THDoubleTensor_cmaxValue(result_, self_, min_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_clamp_min(const Tensor & self, Scalar min) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto min_ = min.toDouble();
    THDoubleTensor_cmaxValue(result_, self_, min_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_th_clamp_max_out(Tensor & result, const Tensor & self, Scalar max) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto max_ = max.toDouble();
    THDoubleTensor_cminValue(result_, self_, max_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_clamp_max(const Tensor & self, Scalar max) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto max_ = max.toDouble();
    THDoubleTensor_cminValue(result_, self_, max_);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_dot(const Tensor & self, const Tensor & tensor) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto tensor_ = checked_tensor_unwrap(tensor,"tensor",2, false, Backend::CPU, ScalarType::Double);
    return scalarTensor(convert<double>(THDoubleTensor_dot(self_, tensor_)));
}
Tensor & CPUDoubleType::_th_tril_out(Tensor & result, const Tensor & self, int64_t diagonal) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_tril(result_, self_, diagonal);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_tril(const Tensor & self, int64_t diagonal) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_tril(result_, self_, diagonal);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_th_tril_(Tensor & self, int64_t diagonal) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_tril(self_, self_, diagonal);
    return self;
}
Tensor & CPUDoubleType::_th_triu_out(Tensor & result, const Tensor & self, int64_t diagonal) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_triu(result_, self_, diagonal);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_triu(const Tensor & self, int64_t diagonal) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_triu(result_, self_, diagonal);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_th_triu_(Tensor & self, int64_t diagonal) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_triu(self_, self_, diagonal);
    return self;
}
Tensor & CPUDoubleType::_th_cross_out(Tensor & result, const Tensor & self, const Tensor & other, int64_t dim) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_cross(result_, self_, other_, dim);
    result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_cross(const Tensor & self, const Tensor & other, int64_t dim) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto other_ = checked_tensor_unwrap(other,"other",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_cross(result_, self_, other_, dim);
    result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_th_diag_out(Tensor & result, const Tensor & self, int64_t diagonal) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    if (self_->dim() == 0) {
      throw std::runtime_error("Input must be 1-d or 2-d");
    }
    THDoubleTensor_diag(result_, self_, diagonal);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_diag(const Tensor & self, int64_t diagonal) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    if (self_->dim() == 0) {
      throw std::runtime_error("Input must be 1-d or 2-d");
    }
    THDoubleTensor_diag(result_, self_, diagonal);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::s_th_addmm_out(Tensor & result, const Tensor & self, const Tensor & mat1, const Tensor & mat2, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto beta_ = beta.toDouble();
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto alpha_ = alpha.toDouble();
    auto mat1_ = checked_tensor_unwrap(mat1,"mat1",4, false, Backend::CPU, ScalarType::Double);
    auto mat2_ = checked_tensor_unwrap(mat2,"mat2",5, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_addmm(result_, beta_, self_, alpha_, mat1_, mat2_);
    result_->maybe_zero_dim(self_->dim() == 0 && mat1_->dim() == 0 && mat2_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::s_th_addmm(const Tensor & self, const Tensor & mat1, const Tensor & mat2, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto beta_ = beta.toDouble();
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto alpha_ = alpha.toDouble();
    auto mat1_ = checked_tensor_unwrap(mat1,"mat1",4, false, Backend::CPU, ScalarType::Double);
    auto mat2_ = checked_tensor_unwrap(mat2,"mat2",5, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_addmm(result_, beta_, self_, alpha_, mat1_, mat2_);
    result_->maybe_zero_dim(self_->dim() == 0 && mat1_->dim() == 0 && mat2_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::th_addmm_(Tensor & self, const Tensor & mat1, const Tensor & mat2, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto beta_ = beta.toDouble();
    auto alpha_ = alpha.toDouble();
    auto mat1_ = checked_tensor_unwrap(mat1,"mat1",5, false, Backend::CPU, ScalarType::Double);
    auto mat2_ = checked_tensor_unwrap(mat2,"mat2",6, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_addmm(self_, beta_, self_, alpha_, mat1_, mat2_);
    return self;
}
Tensor & CPUDoubleType::s__addmv_out(Tensor & result, const Tensor & self, const Tensor & mat, const Tensor & vec, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto beta_ = beta.toDouble();
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto alpha_ = alpha.toDouble();
    auto mat_ = checked_tensor_unwrap(mat,"mat",4, false, Backend::CPU, ScalarType::Double);
    auto vec_ = checked_tensor_unwrap(vec,"vec",5, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_addmv(result_, beta_, self_, alpha_, mat_, vec_);
    result_->maybe_zero_dim(self_->dim() == 0 && mat_->dim() == 0 && vec_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::s__addmv(const Tensor & self, const Tensor & mat, const Tensor & vec, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto beta_ = beta.toDouble();
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto alpha_ = alpha.toDouble();
    auto mat_ = checked_tensor_unwrap(mat,"mat",4, false, Backend::CPU, ScalarType::Double);
    auto vec_ = checked_tensor_unwrap(vec,"vec",5, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_addmv(result_, beta_, self_, alpha_, mat_, vec_);
    result_->maybe_zero_dim(self_->dim() == 0 && mat_->dim() == 0 && vec_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_addmv_(Tensor & self, const Tensor & mat, const Tensor & vec, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto beta_ = beta.toDouble();
    auto alpha_ = alpha.toDouble();
    auto mat_ = checked_tensor_unwrap(mat,"mat",5, false, Backend::CPU, ScalarType::Double);
    auto vec_ = checked_tensor_unwrap(vec,"vec",6, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_addmv(self_, beta_, self_, alpha_, mat_, vec_);
    return self;
}
Tensor & CPUDoubleType::s__addr_out(Tensor & result, const Tensor & self, const Tensor & vec1, const Tensor & vec2, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto beta_ = beta.toDouble();
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto alpha_ = alpha.toDouble();
    auto vec1_ = checked_tensor_unwrap(vec1,"vec1",4, false, Backend::CPU, ScalarType::Double);
    auto vec2_ = checked_tensor_unwrap(vec2,"vec2",5, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_addr(result_, beta_, self_, alpha_, vec1_, vec2_);
    result_->maybe_zero_dim(self_->dim() == 0 && vec1_->dim() == 0 && vec2_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::s__addr(const Tensor & self, const Tensor & vec1, const Tensor & vec2, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto beta_ = beta.toDouble();
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto alpha_ = alpha.toDouble();
    auto vec1_ = checked_tensor_unwrap(vec1,"vec1",4, false, Backend::CPU, ScalarType::Double);
    auto vec2_ = checked_tensor_unwrap(vec2,"vec2",5, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_addr(result_, beta_, self_, alpha_, vec1_, vec2_);
    result_->maybe_zero_dim(self_->dim() == 0 && vec1_->dim() == 0 && vec2_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_addr_(Tensor & self, const Tensor & vec1, const Tensor & vec2, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto beta_ = beta.toDouble();
    auto alpha_ = alpha.toDouble();
    auto vec1_ = checked_tensor_unwrap(vec1,"vec1",5, false, Backend::CPU, ScalarType::Double);
    auto vec2_ = checked_tensor_unwrap(vec2,"vec2",6, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_addr(self_, beta_, self_, alpha_, vec1_, vec2_);
    return self;
}
Tensor & CPUDoubleType::_ger_out(Tensor & result, const Tensor & self, const Tensor & vec2) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    result.resize_({ self.dim() == 0 ? 1 : self.size(0),vec2.dim() == 0 ? 1 : vec2.size(0) });
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto vec2_ = checked_tensor_unwrap(vec2,"vec2",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_addr(result_, double(0), result_, double(1), self_, vec2_);
    result_->maybe_zero_dim(false);
    return result;
}
Tensor CPUDoubleType::_ger(const Tensor & self, const Tensor & vec2) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    result.resize_({ self.dim() == 0 ? 1 : self.size(0),vec2.dim() == 0 ? 1 : vec2.size(0) });
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto vec2_ = checked_tensor_unwrap(vec2,"vec2",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_addr(result_, double(0), result_, double(1), self_, vec2_);
    result_->maybe_zero_dim(false);
    return result;
}
Tensor & CPUDoubleType::_mv_out(Tensor & result, const Tensor & self, const Tensor & vec) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    result.resize_({ self.size(0) });
    result.zero_();
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto vec_ = checked_tensor_unwrap(vec,"vec",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_addmv(result_, double(0), result_, double(1), self_, vec_);
    result_->maybe_zero_dim(self_->dim() == 0 && vec_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_mv(const Tensor & self, const Tensor & vec) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    result.resize_({ self.size(0) });
    result.zero_();
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto vec_ = checked_tensor_unwrap(vec,"vec",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_addmv(result_, double(0), result_, double(1), self_, vec_);
    result_->maybe_zero_dim(self_->dim() == 0 && vec_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_mm_out(Tensor & result, const Tensor & self, const Tensor & mat2) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    result.resize_({ self.size(0),mat2.size(1) });
    result.zero_();
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto mat2_ = checked_tensor_unwrap(mat2,"mat2",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_addmm(result_, double(0), result_, double(1), self_, mat2_);
    result_->maybe_zero_dim(self_->dim() == 0 && mat2_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_mm(const Tensor & self, const Tensor & mat2) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    result.resize_({ self.size(0),mat2.size(1) });
    result.zero_();
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto mat2_ = checked_tensor_unwrap(mat2,"mat2",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_addmm(result_, double(0), result_, double(1), self_, mat2_);
    result_->maybe_zero_dim(self_->dim() == 0 && mat2_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::s_addbmm_out(Tensor & result, const Tensor & self, const Tensor & batch1, const Tensor & batch2, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto beta_ = beta.toDouble();
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto alpha_ = alpha.toDouble();
    auto batch1_ = checked_tensor_unwrap(batch1,"batch1",4, false, Backend::CPU, ScalarType::Double);
    auto batch2_ = checked_tensor_unwrap(batch2,"batch2",5, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_addbmm(result_, beta_, self_, alpha_, batch1_, batch2_);
    result_->maybe_zero_dim(self_->dim() == 0 && batch1_->dim() == 0 && batch2_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::s_addbmm(const Tensor & self, const Tensor & batch1, const Tensor & batch2, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto beta_ = beta.toDouble();
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto alpha_ = alpha.toDouble();
    auto batch1_ = checked_tensor_unwrap(batch1,"batch1",4, false, Backend::CPU, ScalarType::Double);
    auto batch2_ = checked_tensor_unwrap(batch2,"batch2",5, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_addbmm(result_, beta_, self_, alpha_, batch1_, batch2_);
    result_->maybe_zero_dim(self_->dim() == 0 && batch1_->dim() == 0 && batch2_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_th_addbmm_(Tensor & self, const Tensor & batch1, const Tensor & batch2, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto beta_ = beta.toDouble();
    auto alpha_ = alpha.toDouble();
    auto batch1_ = checked_tensor_unwrap(batch1,"batch1",5, false, Backend::CPU, ScalarType::Double);
    auto batch2_ = checked_tensor_unwrap(batch2,"batch2",6, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_addbmm(self_, beta_, self_, alpha_, batch1_, batch2_);
    return self;
}
Tensor & CPUDoubleType::s__th_addcmul_out(Tensor & result, const Tensor & self, const Tensor & tensor1, const Tensor & tensor2, Scalar value) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto value_ = value.toDouble();
    auto tensor1_ = checked_tensor_unwrap(tensor1,"tensor1",3, false, Backend::CPU, ScalarType::Double);
    auto tensor2_ = checked_tensor_unwrap(tensor2,"tensor2",4, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_addcmul(result_, self_, value_, tensor1_, tensor2_);
    result_->maybe_zero_dim(self_->dim() == 0 && tensor1_->dim() == 0 && tensor2_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::s__th_addcmul(const Tensor & self, const Tensor & tensor1, const Tensor & tensor2, Scalar value) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto value_ = value.toDouble();
    auto tensor1_ = checked_tensor_unwrap(tensor1,"tensor1",3, false, Backend::CPU, ScalarType::Double);
    auto tensor2_ = checked_tensor_unwrap(tensor2,"tensor2",4, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_addcmul(result_, self_, value_, tensor1_, tensor2_);
    result_->maybe_zero_dim(self_->dim() == 0 && tensor1_->dim() == 0 && tensor2_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::s__th_addcmul_(Tensor & self, const Tensor & tensor1, const Tensor & tensor2, Scalar value) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto value_ = value.toDouble();
    auto tensor1_ = checked_tensor_unwrap(tensor1,"tensor1",4, false, Backend::CPU, ScalarType::Double);
    auto tensor2_ = checked_tensor_unwrap(tensor2,"tensor2",5, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_addcmul(self_, self_, value_, tensor1_, tensor2_);
    return self;
}
Tensor & CPUDoubleType::s__th_addcdiv_out(Tensor & result, const Tensor & self, const Tensor & tensor1, const Tensor & tensor2, Scalar value) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto value_ = value.toDouble();
    auto tensor1_ = checked_tensor_unwrap(tensor1,"tensor1",3, false, Backend::CPU, ScalarType::Double);
    auto tensor2_ = checked_tensor_unwrap(tensor2,"tensor2",4, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_addcdiv(result_, self_, value_, tensor1_, tensor2_);
    result_->maybe_zero_dim(self_->dim() == 0 && tensor1_->dim() == 0 && tensor2_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::s__th_addcdiv(const Tensor & self, const Tensor & tensor1, const Tensor & tensor2, Scalar value) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto value_ = value.toDouble();
    auto tensor1_ = checked_tensor_unwrap(tensor1,"tensor1",3, false, Backend::CPU, ScalarType::Double);
    auto tensor2_ = checked_tensor_unwrap(tensor2,"tensor2",4, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_addcdiv(result_, self_, value_, tensor1_, tensor2_);
    result_->maybe_zero_dim(self_->dim() == 0 && tensor1_->dim() == 0 && tensor2_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::s__th_addcdiv_(Tensor & self, const Tensor & tensor1, const Tensor & tensor2, Scalar value) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto value_ = value.toDouble();
    auto tensor1_ = checked_tensor_unwrap(tensor1,"tensor1",4, false, Backend::CPU, ScalarType::Double);
    auto tensor2_ = checked_tensor_unwrap(tensor2,"tensor2",5, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_addcdiv(self_, self_, value_, tensor1_, tensor2_);
    return self;
}
std::tuple<Tensor &,Tensor &> CPUDoubleType::_gesv_single_out(Tensor & solution, Tensor & lu, const Tensor & self, const Tensor & A) const {
    const DeviceGuard device_guard(solution);
    auto solution_ = checked_tensor_unwrap(solution,"solution",0, false, Backend::CPU, ScalarType::Double);
    auto lu_ = checked_tensor_unwrap(lu,"lu",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto A_ = checked_tensor_unwrap(A,"A",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_gesv(solution_, lu_, self_, A_);
    bool maybe_scalar = self_->dim() == 0 && A_->dim() == 0;
    solution_->maybe_zero_dim(maybe_scalar);
    lu_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor &, Tensor &>(solution, lu);
}
std::tuple<Tensor,Tensor> CPUDoubleType::_gesv_single(const Tensor & self, const Tensor & A) const {
    const DeviceGuard device_guard(self);
    auto solution_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto solution = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(solution_));
    auto lu_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto lu = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(lu_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto A_ = checked_tensor_unwrap(A,"A",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_gesv(solution_, lu_, self_, A_);
    bool maybe_scalar = self_->dim() == 0 && A_->dim() == 0;
    solution_->maybe_zero_dim(maybe_scalar);
    lu_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor, Tensor>(solution, lu);
}
std::tuple<Tensor &,Tensor &> CPUDoubleType::_th_gels_out(Tensor & res1, Tensor & res2, const Tensor & self, const Tensor & A) const {
    const DeviceGuard device_guard(res1);
    auto res1_ = checked_tensor_unwrap(res1,"res1",0, false, Backend::CPU, ScalarType::Double);
    auto res2_ = checked_tensor_unwrap(res2,"res2",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto A_ = checked_tensor_unwrap(A,"A",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_gels(res1_, res2_, self_, A_);
    bool maybe_scalar = self_->dim() == 0 && A_->dim() == 0;
    res1_->maybe_zero_dim(maybe_scalar);
    res2_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor &, Tensor &>(res1, res2);
}
std::tuple<Tensor,Tensor> CPUDoubleType::_th_gels(const Tensor & self, const Tensor & A) const {
    const DeviceGuard device_guard(self);
    auto res1_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto res1 = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(res1_));
    auto res2_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto res2 = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(res2_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto A_ = checked_tensor_unwrap(A,"A",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_gels(res1_, res2_, self_, A_);
    bool maybe_scalar = self_->dim() == 0 && A_->dim() == 0;
    res1_->maybe_zero_dim(maybe_scalar);
    res2_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor, Tensor>(res1, res2);
}
std::tuple<Tensor &,Tensor &> CPUDoubleType::_th_trtrs_out(Tensor & res1, Tensor & res2, const Tensor & self, const Tensor & A, bool upper, bool transpose, bool unitriangular) const {
    const DeviceGuard device_guard(res1);
    auto res1_ = checked_tensor_unwrap(res1,"res1",0, false, Backend::CPU, ScalarType::Double);
    auto res2_ = checked_tensor_unwrap(res2,"res2",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto A_ = checked_tensor_unwrap(A,"A",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_trtrs(res1_, res2_, self_, A_, (upper) ? "U" : "L", (transpose) ? "T" : "N", (unitriangular) ? "U" : "N");
    bool maybe_scalar = self_->dim() == 0 && A_->dim() == 0;
    res1_->maybe_zero_dim(maybe_scalar);
    res2_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor &, Tensor &>(res1, res2);
}
std::tuple<Tensor,Tensor> CPUDoubleType::_th_trtrs(const Tensor & self, const Tensor & A, bool upper, bool transpose, bool unitriangular) const {
    const DeviceGuard device_guard(self);
    auto res1_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto res1 = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(res1_));
    auto res2_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto res2 = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(res2_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto A_ = checked_tensor_unwrap(A,"A",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_trtrs(res1_, res2_, self_, A_, (upper) ? "U" : "L", (transpose) ? "T" : "N", (unitriangular) ? "U" : "N");
    bool maybe_scalar = self_->dim() == 0 && A_->dim() == 0;
    res1_->maybe_zero_dim(maybe_scalar);
    res2_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor, Tensor>(res1, res2);
}
std::tuple<Tensor &,Tensor &> CPUDoubleType::_th_symeig_out(Tensor & res1, Tensor & res2, const Tensor & self, bool eigenvectors, bool upper) const {
    const DeviceGuard device_guard(res1);
    auto res1_ = checked_tensor_unwrap(res1,"res1",0, false, Backend::CPU, ScalarType::Double);
    auto res2_ = checked_tensor_unwrap(res2,"res2",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_syev(res1_, res2_, self_, (eigenvectors) ? "V" : "N", (upper) ? "U" : "L");
    bool maybe_scalar = self_->dim() == 0;
    res1_->maybe_zero_dim(maybe_scalar);
    res2_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor &, Tensor &>(res1, res2);
}
std::tuple<Tensor,Tensor> CPUDoubleType::_th_symeig(const Tensor & self, bool eigenvectors, bool upper) const {
    const DeviceGuard device_guard(self);
    auto res1_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto res1 = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(res1_));
    auto res2_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto res2 = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(res2_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_syev(res1_, res2_, self_, (eigenvectors) ? "V" : "N", (upper) ? "U" : "L");
    bool maybe_scalar = self_->dim() == 0;
    res1_->maybe_zero_dim(maybe_scalar);
    res2_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor, Tensor>(res1, res2);
}
std::tuple<Tensor &,Tensor &> CPUDoubleType::_th_eig_out(Tensor & res1, Tensor & res2, const Tensor & self, bool eigenvectors) const {
    const DeviceGuard device_guard(res1);
    auto res1_ = checked_tensor_unwrap(res1,"res1",0, false, Backend::CPU, ScalarType::Double);
    auto res2_ = checked_tensor_unwrap(res2,"res2",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_geev(res1_, res2_, self_, (eigenvectors) ? "V" : "N");
    bool maybe_scalar = self_->dim() == 0;
    res1_->maybe_zero_dim(maybe_scalar);
    res2_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor &, Tensor &>(res1, res2);
}
std::tuple<Tensor,Tensor> CPUDoubleType::_th_eig(const Tensor & self, bool eigenvectors) const {
    const DeviceGuard device_guard(self);
    auto res1_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto res1 = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(res1_));
    auto res2_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto res2 = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(res2_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_geev(res1_, res2_, self_, (eigenvectors) ? "V" : "N");
    bool maybe_scalar = self_->dim() == 0;
    res1_->maybe_zero_dim(maybe_scalar);
    res2_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor, Tensor>(res1, res2);
}
std::tuple<Tensor &,Tensor &,Tensor &> CPUDoubleType::_th_svd_out(Tensor & res1, Tensor & res2, Tensor & res3, const Tensor & self, bool some, bool compute_uv) const {
    const DeviceGuard device_guard(res1);
    auto res1_ = checked_tensor_unwrap(res1,"res1",0, false, Backend::CPU, ScalarType::Double);
    auto res2_ = checked_tensor_unwrap(res2,"res2",0, false, Backend::CPU, ScalarType::Double);
    auto res3_ = checked_tensor_unwrap(res3,"res3",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_gesdd(res1_, res2_, res3_, self_, (some) ? "S" : "A", (compute_uv) ? "S" : "N");
    bool maybe_scalar = self_->dim() == 0;
    res1_->maybe_zero_dim(maybe_scalar);
    res2_->maybe_zero_dim(maybe_scalar);
    res3_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor &, Tensor &, Tensor &>(res1, res2, res3);
}
std::tuple<Tensor,Tensor,Tensor> CPUDoubleType::_th_svd(const Tensor & self, bool some, bool compute_uv) const {
    const DeviceGuard device_guard(self);
    auto res1_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto res1 = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(res1_));
    auto res2_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto res2 = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(res2_));
    auto res3_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto res3 = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(res3_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_gesdd(res1_, res2_, res3_, self_, (some) ? "S" : "A", (compute_uv) ? "S" : "N");
    bool maybe_scalar = self_->dim() == 0;
    res1_->maybe_zero_dim(maybe_scalar);
    res2_->maybe_zero_dim(maybe_scalar);
    res3_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor, Tensor, Tensor>(res1, res2, res3);
}
Tensor & CPUDoubleType::_getri_out(Tensor & output, const Tensor & self) const {
    const DeviceGuard device_guard(output);
    auto output_ = checked_tensor_unwrap(output,"output",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_getri(output_, self_);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor CPUDoubleType::_getri(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_getri(output_, self_);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor & CPUDoubleType::_th_potrf_out(Tensor & output, const Tensor & self, bool upper) const {
    const DeviceGuard device_guard(output);
    auto output_ = checked_tensor_unwrap(output,"output",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_potrf(output_, self_, (upper) ? "U" : "L");
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor CPUDoubleType::_th_potrf(const Tensor & self, bool upper) const {
    const DeviceGuard device_guard(self);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_potrf(output_, self_, (upper) ? "U" : "L");
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor & CPUDoubleType::_th_potrs_out(Tensor & result, const Tensor & self, const Tensor & input2, bool upper) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto input2_ = checked_tensor_unwrap(input2,"input2",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_potrs(result_, self_, input2_, (upper) ? "U" : "L");
    result_->maybe_zero_dim(self_->dim() == 0 && input2_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_potrs(const Tensor & self, const Tensor & input2, bool upper) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto input2_ = checked_tensor_unwrap(input2,"input2",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_potrs(result_, self_, input2_, (upper) ? "U" : "L");
    result_->maybe_zero_dim(self_->dim() == 0 && input2_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_th_potri_out(Tensor & output, const Tensor & self, bool upper) const {
    const DeviceGuard device_guard(output);
    auto output_ = checked_tensor_unwrap(output,"output",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_potri(output_, self_, (upper) ? "U" : "L");
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor CPUDoubleType::_th_potri(const Tensor & self, bool upper) const {
    const DeviceGuard device_guard(self);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_potri(output_, self_, (upper) ? "U" : "L");
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
std::tuple<Tensor &,Tensor &> CPUDoubleType::_th_pstrf_out(Tensor & res1, Tensor & res2, const Tensor & self, bool upper, Scalar tol) const {
    const DeviceGuard device_guard(res1);
    auto res1_ = checked_tensor_unwrap(res1,"res1",0, false, Backend::CPU, ScalarType::Double);
    auto res2_ = checked_tensor_unwrap(res2,"res2",0, false, Backend::CPU, ScalarType::Int);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto tol_ = tol.toDouble();
    THDoubleTensor_pstrf(res1_, res2_, self_, (upper) ? "U" : "L", tol_);
    res2 -= 1;  // LAPACK returns 1-indexed pivots
    return std::tuple<Tensor &, Tensor &>(res1, res2);
}
std::tuple<Tensor,Tensor> CPUDoubleType::_th_pstrf(const Tensor & self, bool upper, Scalar tol) const {
    const DeviceGuard device_guard(self);
    auto res1_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto res1 = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(res1_));
    auto res2_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), scalarTypeToTypeMeta(ScalarType::Int), allocator(), false).release();
    auto res2 = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(res2_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto tol_ = tol.toDouble();
    THDoubleTensor_pstrf(res1_, res2_, self_, (upper) ? "U" : "L", tol_);
    res2 -= 1;  // LAPACK returns 1-indexed pivots
    return std::tuple<Tensor, Tensor>(res1, res2);
}
std::tuple<Tensor &,Tensor &> CPUDoubleType::_th_qr_out(Tensor & res1, Tensor & res2, const Tensor & self) const {
    const DeviceGuard device_guard(res1);
    auto res1_ = checked_tensor_unwrap(res1,"res1",0, false, Backend::CPU, ScalarType::Double);
    auto res2_ = checked_tensor_unwrap(res2,"res2",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_qr(res1_, res2_, self_);
    bool maybe_scalar = self_->dim() == 0;
    res1_->maybe_zero_dim(maybe_scalar);
    res2_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor &, Tensor &>(res1, res2);
}
std::tuple<Tensor,Tensor> CPUDoubleType::_th_qr(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto res1_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto res1 = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(res1_));
    auto res2_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto res2 = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(res2_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_qr(res1_, res2_, self_);
    bool maybe_scalar = self_->dim() == 0;
    res1_->maybe_zero_dim(maybe_scalar);
    res2_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor, Tensor>(res1, res2);
}
std::tuple<Tensor &,Tensor &> CPUDoubleType::_th_geqrf_out(Tensor & res1, Tensor & res2, const Tensor & self) const {
    const DeviceGuard device_guard(res1);
    auto res1_ = checked_tensor_unwrap(res1,"res1",0, false, Backend::CPU, ScalarType::Double);
    auto res2_ = checked_tensor_unwrap(res2,"res2",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_geqrf(res1_, res2_, self_);
    bool maybe_scalar = self_->dim() == 0;
    res1_->maybe_zero_dim(maybe_scalar);
    res2_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor &, Tensor &>(res1, res2);
}
std::tuple<Tensor,Tensor> CPUDoubleType::_th_geqrf(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto res1_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto res1 = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(res1_));
    auto res2_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto res2 = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(res2_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_geqrf(res1_, res2_, self_);
    bool maybe_scalar = self_->dim() == 0;
    res1_->maybe_zero_dim(maybe_scalar);
    res2_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor, Tensor>(res1, res2);
}
Tensor & CPUDoubleType::_th_orgqr_out(Tensor & result, const Tensor & self, const Tensor & input2) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto input2_ = checked_tensor_unwrap(input2,"input2",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_orgqr(result_, self_, input2_);
    result_->maybe_zero_dim(self_->dim() == 0 && input2_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_orgqr(const Tensor & self, const Tensor & input2) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto input2_ = checked_tensor_unwrap(input2,"input2",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_orgqr(result_, self_, input2_);
    result_->maybe_zero_dim(self_->dim() == 0 && input2_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_th_ormqr_out(Tensor & result, const Tensor & self, const Tensor & input2, const Tensor & input3, bool left, bool transpose) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto input2_ = checked_tensor_unwrap(input2,"input2",2, false, Backend::CPU, ScalarType::Double);
    auto input3_ = checked_tensor_unwrap(input3,"input3",3, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_ormqr(result_, self_, input2_, input3_, (left) ? "L" : "R", (transpose) ? "T" : "N");
    result_->maybe_zero_dim(self_->dim() == 0 && input2_->dim() == 0 && input3_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_ormqr(const Tensor & self, const Tensor & input2, const Tensor & input3, bool left, bool transpose) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto input2_ = checked_tensor_unwrap(input2,"input2",2, false, Backend::CPU, ScalarType::Double);
    auto input3_ = checked_tensor_unwrap(input3,"input3",3, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_ormqr(result_, self_, input2_, input3_, (left) ? "L" : "R", (transpose) ? "T" : "N");
    result_->maybe_zero_dim(self_->dim() == 0 && input2_->dim() == 0 && input3_->dim() == 0);
    return result;
}
std::tuple<Tensor &,Tensor &> CPUDoubleType::_th_btrifact_out(Tensor & result, Tensor & pivots, const Tensor & self, bool pivot) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto pivots_ = checked_tensor_unwrap(pivots,"pivots",0, false, Backend::CPU, ScalarType::Int);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_btrifact(result_, pivots_, NULL, pivot, self_);
    bool maybe_scalar = self_->dim() == 0;
    result_->maybe_zero_dim(maybe_scalar);
    pivots_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor &, Tensor &>(result, pivots);
}
std::tuple<Tensor,Tensor> CPUDoubleType::_th_btrifact(const Tensor & self, bool pivot) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto pivots_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), scalarTypeToTypeMeta(ScalarType::Int), allocator(), false).release();
    auto pivots = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(pivots_));
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_btrifact(result_, pivots_, NULL, pivot, self_);
    bool maybe_scalar = self_->dim() == 0;
    result_->maybe_zero_dim(maybe_scalar);
    pivots_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor, Tensor>(result, pivots);
}
std::tuple<Tensor &,Tensor &,Tensor &> CPUDoubleType::_th_btrifact_with_info_out(Tensor & result, Tensor & pivots, Tensor & info, const Tensor & self, bool pivot) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto pivots_ = checked_tensor_unwrap(pivots,"pivots",0, false, Backend::CPU, ScalarType::Int);
    auto info_ = checked_tensor_unwrap(info,"info",0, false, Backend::CPU, ScalarType::Int);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_btrifact(result_, pivots_, info_, pivot, self_);
    bool maybe_scalar = self_->dim() == 0;
    result_->maybe_zero_dim(maybe_scalar);
    pivots_->maybe_zero_dim(maybe_scalar);
    info_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor &, Tensor &, Tensor &>(result, pivots, info);
}
std::tuple<Tensor,Tensor,Tensor> CPUDoubleType::_th_btrifact_with_info(const Tensor & self, bool pivot) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto pivots_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), scalarTypeToTypeMeta(ScalarType::Int), allocator(), false).release();
    auto pivots = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(pivots_));
    auto info_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), scalarTypeToTypeMeta(ScalarType::Int), allocator(), false).release();
    auto info = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(info_));
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_btrifact(result_, pivots_, info_, pivot, self_);
    bool maybe_scalar = self_->dim() == 0;
    result_->maybe_zero_dim(maybe_scalar);
    pivots_->maybe_zero_dim(maybe_scalar);
    info_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor, Tensor, Tensor>(result, pivots, info);
}
Tensor & CPUDoubleType::_th_btrisolve_out(Tensor & result, const Tensor & self, const Tensor & LU_data, const Tensor & LU_pivots) const {
    const DeviceGuard device_guard(result);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto LU_data_ = checked_tensor_unwrap(LU_data,"LU_data",2, false, Backend::CPU, ScalarType::Double);
    auto LU_pivots_ = checked_tensor_unwrap(LU_pivots,"LU_pivots",3, false, Backend::CPU, ScalarType::Int);
    THDoubleTensor_btrisolve(result_, self_, LU_data_, LU_pivots_);
    result_->maybe_zero_dim(self_->dim() == 0 && LU_data_->dim() == 0 && LU_pivots_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_btrisolve(const Tensor & self, const Tensor & LU_data, const Tensor & LU_pivots) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto LU_data_ = checked_tensor_unwrap(LU_data,"LU_data",2, false, Backend::CPU, ScalarType::Double);
    auto LU_pivots_ = checked_tensor_unwrap(LU_pivots,"LU_pivots",3, false, Backend::CPU, ScalarType::Int);
    THDoubleTensor_btrisolve(result_, self_, LU_data_, LU_pivots_);
    result_->maybe_zero_dim(self_->dim() == 0 && LU_data_->dim() == 0 && LU_pivots_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_th_random_(Tensor & self, int64_t from, int64_t to, Generator * generator) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto generator_ = check_generator<CPUGenerator>(generator, &globalContext().defaultGenerator(device_type()));
    THDoubleTensor_clampedRandom(self_, generator_->generator, from, to);
    return self;
}
Tensor & CPUDoubleType::_th_random_(Tensor & self, int64_t to, Generator * generator) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto generator_ = check_generator<CPUGenerator>(generator, &globalContext().defaultGenerator(device_type()));
    THDoubleTensor_cappedRandom(self_, generator_->generator, to);
    return self;
}
Tensor & CPUDoubleType::_th_random_(Tensor & self, Generator * generator) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto generator_ = check_generator<CPUGenerator>(generator, &globalContext().defaultGenerator(device_type()));
    THDoubleTensor_random(self_, generator_->generator);
    return self;
}
Tensor & CPUDoubleType::_th_multinomial_out(Tensor & result, const Tensor & self, int64_t num_samples, bool replacement, Generator * generator) const {
    const DeviceGuard device_guard(self);
    auto result_ = checked_tensor_unwrap(result,"result",0, false, Backend::CPU, ScalarType::Long);
    auto generator_ = check_generator<CPUGenerator>(generator, &globalContext().defaultGenerator(device_type()));
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_multinomial(result_, generator_->generator, self_, num_samples, replacement);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor CPUDoubleType::_th_multinomial(const Tensor & self, int64_t num_samples, bool replacement, Generator * generator) const {
    const DeviceGuard device_guard(self);
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), scalarTypeToTypeMeta(ScalarType::Long), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto generator_ = check_generator<CPUGenerator>(generator, &globalContext().defaultGenerator(device_type()));
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_multinomial(result_, generator_->generator, self_, num_samples, replacement);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
Tensor & CPUDoubleType::_th_uniform_(Tensor & self, double from, double to, Generator * generator) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto generator_ = check_generator<CPUGenerator>(generator, &globalContext().defaultGenerator(device_type()));
    THDoubleTensor_uniform(self_, generator_->generator, from, to);
    return self;
}
Tensor & CPUDoubleType::_th_normal_out(Tensor & output, const Tensor & mean, double std, Generator * generator) const {
    const DeviceGuard device_guard(output);
    auto output_ = checked_tensor_unwrap(output,"output",0, false, Backend::CPU, ScalarType::Double);
    auto generator_ = check_generator<CPUGenerator>(generator, &globalContext().defaultGenerator(device_type()));
    auto mean_ = checked_tensor_unwrap(mean,"mean",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_normal_means(output_, generator_->generator, mean_, std);
    output_->maybe_zero_dim(mean_->dim() == 0);
    return output;
}
Tensor CPUDoubleType::_th_normal(const Tensor & mean, double std, Generator * generator) const {
    const DeviceGuard device_guard(mean);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    auto generator_ = check_generator<CPUGenerator>(generator, &globalContext().defaultGenerator(device_type()));
    auto mean_ = checked_tensor_unwrap(mean,"mean",2, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_normal_means(output_, generator_->generator, mean_, std);
    output_->maybe_zero_dim(mean_->dim() == 0);
    return output;
}
Tensor & CPUDoubleType::_th_normal_out(Tensor & output, double mean, const Tensor & std, Generator * generator) const {
    const DeviceGuard device_guard(output);
    auto output_ = checked_tensor_unwrap(output,"output",0, false, Backend::CPU, ScalarType::Double);
    auto generator_ = check_generator<CPUGenerator>(generator, &globalContext().defaultGenerator(device_type()));
    auto std_ = checked_tensor_unwrap(std,"std",3, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_normal_stddevs(output_, generator_->generator, mean, std_);
    output_->maybe_zero_dim(std_->dim() == 0);
    return output;
}
Tensor CPUDoubleType::_th_normal(double mean, const Tensor & std, Generator * generator) const {
    const DeviceGuard device_guard(std);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    auto generator_ = check_generator<CPUGenerator>(generator, &globalContext().defaultGenerator(device_type()));
    auto std_ = checked_tensor_unwrap(std,"std",3, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_normal_stddevs(output_, generator_->generator, mean, std_);
    output_->maybe_zero_dim(std_->dim() == 0);
    return output;
}
Tensor & CPUDoubleType::_th_normal_out(Tensor & output, const Tensor & mean, const Tensor & std, Generator * generator) const {
    const DeviceGuard device_guard(output);
    auto output_ = checked_tensor_unwrap(output,"output",0, false, Backend::CPU, ScalarType::Double);
    auto generator_ = check_generator<CPUGenerator>(generator, &globalContext().defaultGenerator(device_type()));
    auto mean_ = checked_tensor_unwrap(mean,"mean",2, false, Backend::CPU, ScalarType::Double);
    auto std_ = checked_tensor_unwrap(std,"std",3, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_normal_means_stddevs(output_, generator_->generator, mean_, std_);
    output_->maybe_zero_dim(mean_->dim() == 0 && std_->dim() == 0);
    return output;
}
Tensor CPUDoubleType::_th_normal(const Tensor & mean, const Tensor & std, Generator * generator) const {
    const DeviceGuard device_guard(mean);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    auto generator_ = check_generator<CPUGenerator>(generator, &globalContext().defaultGenerator(device_type()));
    auto mean_ = checked_tensor_unwrap(mean,"mean",2, false, Backend::CPU, ScalarType::Double);
    auto std_ = checked_tensor_unwrap(std,"std",3, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_normal_means_stddevs(output_, generator_->generator, mean_, std_);
    output_->maybe_zero_dim(mean_->dim() == 0 && std_->dim() == 0);
    return output;
}
Tensor & CPUDoubleType::_th_normal_(Tensor & self, double mean, double std, Generator * generator) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto generator_ = check_generator<CPUGenerator>(generator, &globalContext().defaultGenerator(device_type()));
    THDoubleTensor_normal(self_, generator_->generator, mean, std);
    return self;
}
Tensor & CPUDoubleType::_th_cauchy_(Tensor & self, double median, double sigma, Generator * generator) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto generator_ = check_generator<CPUGenerator>(generator, &globalContext().defaultGenerator(device_type()));
    THDoubleTensor_cauchy(self_, generator_->generator, median, sigma);
    return self;
}
Tensor & CPUDoubleType::_th_log_normal_(Tensor & self, double mean, double std, Generator * generator) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto generator_ = check_generator<CPUGenerator>(generator, &globalContext().defaultGenerator(device_type()));
    THDoubleTensor_logNormal(self_, generator_->generator, mean, std);
    return self;
}
Tensor & CPUDoubleType::_th_exponential_(Tensor & self, double lambd, Generator * generator) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto generator_ = check_generator<CPUGenerator>(generator, &globalContext().defaultGenerator(device_type()));
    THDoubleTensor_exponential(self_, generator_->generator, lambd);
    return self;
}
Tensor & CPUDoubleType::_th_geometric_(Tensor & self, double p, Generator * generator) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto generator_ = check_generator<CPUGenerator>(generator, &globalContext().defaultGenerator(device_type()));
    THDoubleTensor_geometric(self_, generator_->generator, p);
    return self;
}
Tensor & CPUDoubleType::_dirichlet_grad_out(Tensor & output, const Tensor & x, const Tensor & alpha, const Tensor & total) const {
    const DeviceGuard device_guard(output);
    auto output_ = checked_tensor_unwrap(output,"output",0, false, Backend::CPU, ScalarType::Double);
    auto x_ = checked_tensor_unwrap(x,"x",1, false, Backend::CPU, ScalarType::Double);
    auto alpha_ = checked_tensor_unwrap(alpha,"alpha",2, false, Backend::CPU, ScalarType::Double);
    auto total_ = checked_tensor_unwrap(total,"total",3, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_dirichlet_grad(output_, x_, alpha_, total_);
    output_->maybe_zero_dim(x_->dim() == 0 && alpha_->dim() == 0 && total_->dim() == 0);
    return output;
}
Tensor CPUDoubleType::_dirichlet_grad(const Tensor & x, const Tensor & alpha, const Tensor & total) const {
    const DeviceGuard device_guard(x);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    auto x_ = checked_tensor_unwrap(x,"x",1, false, Backend::CPU, ScalarType::Double);
    auto alpha_ = checked_tensor_unwrap(alpha,"alpha",2, false, Backend::CPU, ScalarType::Double);
    auto total_ = checked_tensor_unwrap(total,"total",3, false, Backend::CPU, ScalarType::Double);
    THDoubleTensor_dirichlet_grad(output_, x_, alpha_, total_);
    output_->maybe_zero_dim(x_->dim() == 0 && alpha_->dim() == 0 && total_->dim() == 0);
    return output;
}
Tensor CPUDoubleType::tensor(Storage storage, int64_t storageOffset, IntList size, IntList stride) const {
    // DeviceGuard omitted
    auto storage_ = checked_storage(storage,"storage",1, DeviceType::CPU, at::scalarTypeToDataType(ScalarType::Double));
    return Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim((THDoubleTensor_newWithStorage(storage_.unsafeGetStorageImpl(), storageOffset, size, stride))->maybe_zero_dim(size.size() == 0)));
}
Tensor CPUDoubleType::tensor(IntList size, IntList stride) const {
    // DeviceGuard omitted
    return Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim((THDoubleTensor_newWithSize(size, stride))->maybe_zero_dim(size.size() == 0)));
}
Tensor CPUDoubleType::_th_alias(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    return Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim((THDoubleTensor_newWithTensor(self_))->maybe_zero_dim(self_->dim() == 0)));
}
Tensor & CPUDoubleType::_cat_out(Tensor & self, TensorList tensors, int64_t dim) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",0, false, Backend::CPU, ScalarType::Double);
    auto tensors_ = checked_tensor_list_unwrap(tensors,"tensors",1, Backend::CPU, ScalarType::Double);
    THDoubleTensor_catArray(self_, tensors_.data(), tensors_.size(), dim);
    return self;
}
Tensor CPUDoubleType::_cat(TensorList tensors, int64_t dim) const {
    const DeviceGuard device_guard(tensors);
    auto self_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto self = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(self_));
    auto tensors_ = checked_tensor_list_unwrap(tensors,"tensors",1, Backend::CPU, ScalarType::Double);
    THDoubleTensor_catArray(self_, tensors_.data(), tensors_.size(), dim);
    return self;
}
Tensor & CPUDoubleType::binary_cross_entropy_forward_out(Tensor & output, const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",2, false, Backend::CPU, ScalarType::Double);
    auto weight_ = checked_tensor_unwrap(weight,"weight",3, true, Backend::CPU, ScalarType::Double);
    auto output_ = checked_tensor_unwrap(output,"output",4, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleBCECriterion_updateOutput(globalContext().getTHCState(), self_, target_, output_, reduction, weight_ ? weight_ : NULL);
    output_->maybe_zero_dim(reduction != Reduction::None || self_->dim() == 0);
    return output;
}
Tensor CPUDoubleType::binary_cross_entropy_forward(const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",2, false, Backend::CPU, ScalarType::Double);
    auto weight_ = checked_tensor_unwrap(weight,"weight",3, true, Backend::CPU, ScalarType::Double);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    THNN_DoubleBCECriterion_updateOutput(globalContext().getTHCState(), self_, target_, output_, reduction, weight_ ? weight_ : NULL);
    output_->maybe_zero_dim(reduction != Reduction::None || self_->dim() == 0);
    return output;
}
Tensor & CPUDoubleType::binary_cross_entropy_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",3, false, Backend::CPU, ScalarType::Double);
    auto weight_ = checked_tensor_unwrap(weight,"weight",4, true, Backend::CPU, ScalarType::Double);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",5, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleBCECriterion_updateGradInput(globalContext().getTHCState(), self_, target_, grad_output_, grad_input_, reduction, weight_ ? weight_ : NULL);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::binary_cross_entropy_backward(const Tensor & grad_output, const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",3, false, Backend::CPU, ScalarType::Double);
    auto weight_ = checked_tensor_unwrap(weight,"weight",4, true, Backend::CPU, ScalarType::Double);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleBCECriterion_updateGradInput(globalContext().getTHCState(), self_, target_, grad_output_, grad_input_, reduction, weight_ ? weight_ : NULL);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor & CPUDoubleType::l1_loss_forward_out(Tensor & output, const Tensor & self, const Tensor & target, int64_t reduction) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",2, false, Backend::CPU, ScalarType::Double);
    auto output_ = checked_tensor_unwrap(output,"output",3, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleAbsCriterion_updateOutput(globalContext().getTHCState(), self_, target_, output_, reduction);
    output_->maybe_zero_dim(reduction != Reduction::None || self_->dim() == 0);
    return output;
}
Tensor CPUDoubleType::l1_loss_forward(const Tensor & self, const Tensor & target, int64_t reduction) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",2, false, Backend::CPU, ScalarType::Double);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    THNN_DoubleAbsCriterion_updateOutput(globalContext().getTHCState(), self_, target_, output_, reduction);
    output_->maybe_zero_dim(reduction != Reduction::None || self_->dim() == 0);
    return output;
}
Tensor & CPUDoubleType::l1_loss_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, const Tensor & target, int64_t reduction) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",3, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",4, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleAbsCriterion_updateGradInput(globalContext().getTHCState(), self_, target_, grad_output_, grad_input_, reduction);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::l1_loss_backward(const Tensor & grad_output, const Tensor & self, const Tensor & target, int64_t reduction) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",3, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleAbsCriterion_updateGradInput(globalContext().getTHCState(), self_, target_, grad_output_, grad_input_, reduction);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor & CPUDoubleType::mse_loss_forward_out(Tensor & output, const Tensor & self, const Tensor & target, int64_t reduction) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",2, false, Backend::CPU, ScalarType::Double);
    auto output_ = checked_tensor_unwrap(output,"output",3, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleMSECriterion_updateOutput(globalContext().getTHCState(), self_, target_, output_, reduction);
    output_->maybe_zero_dim(reduction != Reduction::None || self_->dim() == 0);
    return output;
}
Tensor CPUDoubleType::mse_loss_forward(const Tensor & self, const Tensor & target, int64_t reduction) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",2, false, Backend::CPU, ScalarType::Double);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    THNN_DoubleMSECriterion_updateOutput(globalContext().getTHCState(), self_, target_, output_, reduction);
    output_->maybe_zero_dim(reduction != Reduction::None || self_->dim() == 0);
    return output;
}
Tensor & CPUDoubleType::mse_loss_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, const Tensor & target, int64_t reduction) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",3, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",4, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleMSECriterion_updateGradInput(globalContext().getTHCState(), self_, target_, grad_output_, grad_input_, reduction);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::mse_loss_backward(const Tensor & grad_output, const Tensor & self, const Tensor & target, int64_t reduction) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",3, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleMSECriterion_updateGradInput(globalContext().getTHCState(), self_, target_, grad_output_, grad_input_, reduction);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor & CPUDoubleType::multi_margin_loss_forward_out(Tensor & output, const Tensor & self, const Tensor & target, Scalar p, Scalar margin, const Tensor & weight, int64_t reduction) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",2, false, Backend::CPU, ScalarType::Long);
    auto p_ = p.toDouble();
    auto margin_ = margin.toDouble();
    auto weight_ = checked_tensor_unwrap(weight,"weight",5, true, Backend::CPU, ScalarType::Double);
    auto output_ = checked_tensor_unwrap(output,"output",6, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleMultiMarginCriterion_updateOutput(globalContext().getTHCState(), self_, target_, output_, reduction, p_, weight_ ? weight_ : NULL, margin_);
    output_->maybe_zero_dim(reduction != Reduction::None || self_->dim() == 0);
    return output;
}
Tensor CPUDoubleType::multi_margin_loss_forward(const Tensor & self, const Tensor & target, Scalar p, Scalar margin, const Tensor & weight, int64_t reduction) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",2, false, Backend::CPU, ScalarType::Long);
    auto p_ = p.toDouble();
    auto margin_ = margin.toDouble();
    auto weight_ = checked_tensor_unwrap(weight,"weight",5, true, Backend::CPU, ScalarType::Double);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    THNN_DoubleMultiMarginCriterion_updateOutput(globalContext().getTHCState(), self_, target_, output_, reduction, p_, weight_ ? weight_ : NULL, margin_);
    output_->maybe_zero_dim(reduction != Reduction::None || self_->dim() == 0);
    return output;
}
Tensor & CPUDoubleType::multi_margin_loss_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, const Tensor & target, Scalar p, Scalar margin, const Tensor & weight, int64_t reduction) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",3, false, Backend::CPU, ScalarType::Long);
    auto p_ = p.toDouble();
    auto margin_ = margin.toDouble();
    auto weight_ = checked_tensor_unwrap(weight,"weight",6, true, Backend::CPU, ScalarType::Double);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",7, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleMultiMarginCriterion_updateGradInput(globalContext().getTHCState(), self_, target_, grad_output_, grad_input_, reduction, p_, weight_ ? weight_ : NULL, margin_);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::multi_margin_loss_backward(const Tensor & grad_output, const Tensor & self, const Tensor & target, Scalar p, Scalar margin, const Tensor & weight, int64_t reduction) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",3, false, Backend::CPU, ScalarType::Long);
    auto p_ = p.toDouble();
    auto margin_ = margin.toDouble();
    auto weight_ = checked_tensor_unwrap(weight,"weight",6, true, Backend::CPU, ScalarType::Double);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleMultiMarginCriterion_updateGradInput(globalContext().getTHCState(), self_, target_, grad_output_, grad_input_, reduction, p_, weight_ ? weight_ : NULL, margin_);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
std::tuple<Tensor &,Tensor &> CPUDoubleType::multilabel_margin_loss_forward_out(Tensor & output, Tensor & is_target, const Tensor & self, const Tensor & target, int64_t reduction) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",2, false, Backend::CPU, ScalarType::Long);
    auto output_ = checked_tensor_unwrap(output,"output",3, false, Backend::CPU, ScalarType::Double);
    auto is_target_ = checked_tensor_unwrap(is_target,"is_target",3, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleMultiLabelMarginCriterion_updateOutput(globalContext().getTHCState(), self_, target_, output_, is_target_, reduction);
    output_->maybe_zero_dim(reduction != Reduction::None || self_->dim() == 0);
    is_target_->maybe_zero_dim(target_->dim() == 0);
    return std::tuple<Tensor &, Tensor &>(output, is_target);
}
std::tuple<Tensor,Tensor> CPUDoubleType::multilabel_margin_loss_forward(const Tensor & self, const Tensor & target, int64_t reduction) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",2, false, Backend::CPU, ScalarType::Long);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    auto is_target_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto is_target = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(is_target_));
    THNN_DoubleMultiLabelMarginCriterion_updateOutput(globalContext().getTHCState(), self_, target_, output_, is_target_, reduction);
    output_->maybe_zero_dim(reduction != Reduction::None || self_->dim() == 0);
    is_target_->maybe_zero_dim(target_->dim() == 0);
    return std::tuple<Tensor, Tensor>(output, is_target);
}
Tensor & CPUDoubleType::multilabel_margin_loss_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, const Tensor & target, int64_t reduction, const Tensor & is_target) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",3, false, Backend::CPU, ScalarType::Long);
    auto is_target_ = checked_tensor_unwrap(is_target,"is_target",5, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",5, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleMultiLabelMarginCriterion_updateGradInput(globalContext().getTHCState(), self_, target_, grad_output_, grad_input_, is_target_, reduction);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::multilabel_margin_loss_backward(const Tensor & grad_output, const Tensor & self, const Tensor & target, int64_t reduction, const Tensor & is_target) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",3, false, Backend::CPU, ScalarType::Long);
    auto is_target_ = checked_tensor_unwrap(is_target,"is_target",5, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleMultiLabelMarginCriterion_updateGradInput(globalContext().getTHCState(), self_, target_, grad_output_, grad_input_, is_target_, reduction);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
std::tuple<Tensor &,Tensor &> CPUDoubleType::nll_loss_forward_out(Tensor & output, Tensor & total_weight, const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction, int64_t ignore_index) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",2, false, Backend::CPU, ScalarType::Long);
    auto weight_ = checked_tensor_unwrap(weight,"weight",3, true, Backend::CPU, ScalarType::Double);
    auto output_ = checked_tensor_unwrap(output,"output",5, false, Backend::CPU, ScalarType::Double);
    auto total_weight_ = checked_tensor_unwrap(total_weight,"total_weight",5, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleClassNLLCriterion_updateOutput(globalContext().getTHCState(), self_, target_, output_, reduction, weight_ ? weight_ : NULL, total_weight_, ignore_index);
    output_->maybe_zero_dim(reduction != Reduction::None || self_->dim() == 0);
    total_weight_->maybe_zero_dim(true);
    return std::tuple<Tensor &, Tensor &>(output, total_weight);
}
std::tuple<Tensor,Tensor> CPUDoubleType::nll_loss_forward(const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction, int64_t ignore_index) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",2, false, Backend::CPU, ScalarType::Long);
    auto weight_ = checked_tensor_unwrap(weight,"weight",3, true, Backend::CPU, ScalarType::Double);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    auto total_weight_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto total_weight = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(total_weight_));
    THNN_DoubleClassNLLCriterion_updateOutput(globalContext().getTHCState(), self_, target_, output_, reduction, weight_ ? weight_ : NULL, total_weight_, ignore_index);
    output_->maybe_zero_dim(reduction != Reduction::None || self_->dim() == 0);
    total_weight_->maybe_zero_dim(true);
    return std::tuple<Tensor, Tensor>(output, total_weight);
}
Tensor & CPUDoubleType::nll_loss_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction, int64_t ignore_index, const Tensor & total_weight) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",3, false, Backend::CPU, ScalarType::Long);
    auto weight_ = checked_tensor_unwrap(weight,"weight",4, true, Backend::CPU, ScalarType::Double);
    auto total_weight_ = checked_tensor_unwrap(total_weight,"total_weight",7, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",7, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleClassNLLCriterion_updateGradInput(globalContext().getTHCState(), self_, target_, grad_output_, grad_input_, reduction, weight_ ? weight_ : NULL, total_weight_, ignore_index);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::nll_loss_backward(const Tensor & grad_output, const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction, int64_t ignore_index, const Tensor & total_weight) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",3, false, Backend::CPU, ScalarType::Long);
    auto weight_ = checked_tensor_unwrap(weight,"weight",4, true, Backend::CPU, ScalarType::Double);
    auto total_weight_ = checked_tensor_unwrap(total_weight,"total_weight",7, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleClassNLLCriterion_updateGradInput(globalContext().getTHCState(), self_, target_, grad_output_, grad_input_, reduction, weight_ ? weight_ : NULL, total_weight_, ignore_index);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
std::tuple<Tensor &,Tensor &> CPUDoubleType::nll_loss2d_forward_out(Tensor & output, Tensor & total_weight, const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction, int64_t ignore_index) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",2, false, Backend::CPU, ScalarType::Long);
    auto weight_ = checked_tensor_unwrap(weight,"weight",3, true, Backend::CPU, ScalarType::Double);
    auto output_ = checked_tensor_unwrap(output,"output",5, false, Backend::CPU, ScalarType::Double);
    auto total_weight_ = checked_tensor_unwrap(total_weight,"total_weight",5, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleSpatialClassNLLCriterion_updateOutput(globalContext().getTHCState(), self_, target_, output_, reduction, weight_ ? weight_ : NULL, total_weight_, ignore_index);
    output_->maybe_zero_dim(reduction != Reduction::None || self_->dim() == 0);
    total_weight_->maybe_zero_dim(true);
    return std::tuple<Tensor &, Tensor &>(output, total_weight);
}
std::tuple<Tensor,Tensor> CPUDoubleType::nll_loss2d_forward(const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction, int64_t ignore_index) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",2, false, Backend::CPU, ScalarType::Long);
    auto weight_ = checked_tensor_unwrap(weight,"weight",3, true, Backend::CPU, ScalarType::Double);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    auto total_weight_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto total_weight = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(total_weight_));
    THNN_DoubleSpatialClassNLLCriterion_updateOutput(globalContext().getTHCState(), self_, target_, output_, reduction, weight_ ? weight_ : NULL, total_weight_, ignore_index);
    output_->maybe_zero_dim(reduction != Reduction::None || self_->dim() == 0);
    total_weight_->maybe_zero_dim(true);
    return std::tuple<Tensor, Tensor>(output, total_weight);
}
Tensor & CPUDoubleType::nll_loss2d_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction, int64_t ignore_index, const Tensor & total_weight) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",3, false, Backend::CPU, ScalarType::Long);
    auto weight_ = checked_tensor_unwrap(weight,"weight",4, true, Backend::CPU, ScalarType::Double);
    auto total_weight_ = checked_tensor_unwrap(total_weight,"total_weight",7, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",7, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleSpatialClassNLLCriterion_updateGradInput(globalContext().getTHCState(), self_, target_, grad_output_, grad_input_, reduction, weight_ ? weight_ : NULL, total_weight_, ignore_index);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::nll_loss2d_backward(const Tensor & grad_output, const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction, int64_t ignore_index, const Tensor & total_weight) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",3, false, Backend::CPU, ScalarType::Long);
    auto weight_ = checked_tensor_unwrap(weight,"weight",4, true, Backend::CPU, ScalarType::Double);
    auto total_weight_ = checked_tensor_unwrap(total_weight,"total_weight",7, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleSpatialClassNLLCriterion_updateGradInput(globalContext().getTHCState(), self_, target_, grad_output_, grad_input_, reduction, weight_ ? weight_ : NULL, total_weight_, ignore_index);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor & CPUDoubleType::smooth_l1_loss_forward_out(Tensor & output, const Tensor & self, const Tensor & target, int64_t reduction) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",2, false, Backend::CPU, ScalarType::Double);
    auto output_ = checked_tensor_unwrap(output,"output",3, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleSmoothL1Criterion_updateOutput(globalContext().getTHCState(), self_, target_, output_, reduction);
    output_->maybe_zero_dim(reduction != Reduction::None || self_->dim() == 0);
    return output;
}
Tensor CPUDoubleType::smooth_l1_loss_forward(const Tensor & self, const Tensor & target, int64_t reduction) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",2, false, Backend::CPU, ScalarType::Double);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    THNN_DoubleSmoothL1Criterion_updateOutput(globalContext().getTHCState(), self_, target_, output_, reduction);
    output_->maybe_zero_dim(reduction != Reduction::None || self_->dim() == 0);
    return output;
}
Tensor & CPUDoubleType::smooth_l1_loss_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, const Tensor & target, int64_t reduction) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",3, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",4, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleSmoothL1Criterion_updateGradInput(globalContext().getTHCState(), self_, target_, grad_output_, grad_input_, reduction);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::smooth_l1_loss_backward(const Tensor & grad_output, const Tensor & self, const Tensor & target, int64_t reduction) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",3, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleSmoothL1Criterion_updateGradInput(globalContext().getTHCState(), self_, target_, grad_output_, grad_input_, reduction);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor & CPUDoubleType::soft_margin_loss_forward_out(Tensor & output, const Tensor & self, const Tensor & target, int64_t reduction) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",2, false, Backend::CPU, ScalarType::Double);
    auto output_ = checked_tensor_unwrap(output,"output",3, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleSoftMarginCriterion_updateOutput(globalContext().getTHCState(), self_, target_, output_, reduction);
    output_->maybe_zero_dim(reduction != Reduction::None || self_->dim() == 0);
    return output;
}
Tensor CPUDoubleType::soft_margin_loss_forward(const Tensor & self, const Tensor & target, int64_t reduction) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",2, false, Backend::CPU, ScalarType::Double);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    THNN_DoubleSoftMarginCriterion_updateOutput(globalContext().getTHCState(), self_, target_, output_, reduction);
    output_->maybe_zero_dim(reduction != Reduction::None || self_->dim() == 0);
    return output;
}
Tensor & CPUDoubleType::soft_margin_loss_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, const Tensor & target, int64_t reduction) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",3, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",4, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleSoftMarginCriterion_updateGradInput(globalContext().getTHCState(), self_, target_, grad_output_, grad_input_, reduction);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::soft_margin_loss_backward(const Tensor & grad_output, const Tensor & self, const Tensor & target, int64_t reduction) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto target_ = checked_tensor_unwrap(target,"target",3, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleSoftMarginCriterion_updateGradInput(globalContext().getTHCState(), self_, target_, grad_output_, grad_input_, reduction);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor & CPUDoubleType::elu_forward_out(Tensor & output, const Tensor & self, Scalar alpha, Scalar scale, Scalar input_scale) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto alpha_ = alpha.toDouble();
    auto scale_ = scale.toDouble();
    auto input_scale_ = input_scale.toDouble();
    auto output_ = checked_tensor_unwrap(output,"output",4, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleELU_updateOutput(globalContext().getTHCState(), self_, output_, alpha_, scale_, input_scale_, false);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor CPUDoubleType::elu_forward(const Tensor & self, Scalar alpha, Scalar scale, Scalar input_scale) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto alpha_ = alpha.toDouble();
    auto scale_ = scale.toDouble();
    auto input_scale_ = input_scale.toDouble();
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    THNN_DoubleELU_updateOutput(globalContext().getTHCState(), self_, output_, alpha_, scale_, input_scale_, false);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor & CPUDoubleType::elu_backward_out(Tensor & grad_input, const Tensor & grad_output, Scalar alpha, Scalar scale, Scalar input_scale, const Tensor & output) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto alpha_ = alpha.toDouble();
    auto scale_ = scale.toDouble();
    auto input_scale_ = input_scale.toDouble();
    auto output_ = checked_tensor_unwrap(output,"output",5, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",5, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleELU_updateGradInput(globalContext().getTHCState(), grad_output_, grad_input_, output_, alpha_, scale_, input_scale_);
    grad_input_->maybe_zero_dim(output_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::elu_backward(const Tensor & grad_output, Scalar alpha, Scalar scale, Scalar input_scale, const Tensor & output) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto alpha_ = alpha.toDouble();
    auto scale_ = scale.toDouble();
    auto input_scale_ = input_scale.toDouble();
    auto output_ = checked_tensor_unwrap(output,"output",5, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleELU_updateGradInput(globalContext().getTHCState(), grad_output_, grad_input_, output_, alpha_, scale_, input_scale_);
    grad_input_->maybe_zero_dim(output_->dim() == 0);
    return grad_input;
}
Tensor & CPUDoubleType::elu_forward_(Tensor & self, Scalar alpha, Scalar scale, Scalar input_scale) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto alpha_ = alpha.toDouble();
    auto scale_ = scale.toDouble();
    auto input_scale_ = input_scale.toDouble();
    THNN_DoubleELU_updateOutput(globalContext().getTHCState(), self_, self_, alpha_, scale_, input_scale_, true);
    return self;
}
Tensor & CPUDoubleType::glu_forward_out(Tensor & output, const Tensor & self, int64_t dim) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    auto output_ = checked_tensor_unwrap(output,"output",2, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleGatedLinear_updateOutput(globalContext().getTHCState(), self_, output_, dim);
    output_->maybe_zero_dim(false);
    return output;
}
Tensor CPUDoubleType::glu_forward(const Tensor & self, int64_t dim) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    THNN_DoubleGatedLinear_updateOutput(globalContext().getTHCState(), self_, output_, dim);
    output_->maybe_zero_dim(false);
    return output;
}
Tensor & CPUDoubleType::glu_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, int64_t dim) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",3, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleGatedLinear_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, dim);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::glu_backward(const Tensor & grad_output, const Tensor & self, int64_t dim) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    dim = maybe_wrap_dim(dim, self_);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleGatedLinear_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, dim);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor & CPUDoubleType::hardtanh_forward_out(Tensor & output, const Tensor & self, Scalar min_val, Scalar max_val) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto min_val_ = min_val.toDouble();
    auto max_val_ = max_val.toDouble();
    auto output_ = checked_tensor_unwrap(output,"output",3, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleHardTanh_updateOutput(globalContext().getTHCState(), self_, output_, min_val_, max_val_, false);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor CPUDoubleType::hardtanh_forward(const Tensor & self, Scalar min_val, Scalar max_val) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto min_val_ = min_val.toDouble();
    auto max_val_ = max_val.toDouble();
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    THNN_DoubleHardTanh_updateOutput(globalContext().getTHCState(), self_, output_, min_val_, max_val_, false);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor & CPUDoubleType::hardtanh_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, Scalar min_val, Scalar max_val) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto min_val_ = min_val.toDouble();
    auto max_val_ = max_val.toDouble();
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",4, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleHardTanh_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, min_val_, max_val_, false);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::hardtanh_backward(const Tensor & grad_output, const Tensor & self, Scalar min_val, Scalar max_val) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto min_val_ = min_val.toDouble();
    auto max_val_ = max_val.toDouble();
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleHardTanh_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, min_val_, max_val_, false);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor & CPUDoubleType::hardtanh_forward_(Tensor & self, Scalar min_val, Scalar max_val) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto min_val_ = min_val.toDouble();
    auto max_val_ = max_val.toDouble();
    THNN_DoubleHardTanh_updateOutput(globalContext().getTHCState(), self_, self_, min_val_, max_val_, true);
    return self;
}
Tensor & CPUDoubleType::leaky_relu_forward_out(Tensor & output, const Tensor & self, Scalar negative_slope) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto negative_slope_ = negative_slope.toDouble();
    auto output_ = checked_tensor_unwrap(output,"output",2, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleLeakyReLU_updateOutput(globalContext().getTHCState(), self_, output_, negative_slope_, false);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor CPUDoubleType::leaky_relu_forward(const Tensor & self, Scalar negative_slope) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto negative_slope_ = negative_slope.toDouble();
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    THNN_DoubleLeakyReLU_updateOutput(globalContext().getTHCState(), self_, output_, negative_slope_, false);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor & CPUDoubleType::leaky_relu_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, Scalar negative_slope) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto negative_slope_ = negative_slope.toDouble();
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",3, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleLeakyReLU_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, negative_slope_, false);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::leaky_relu_backward(const Tensor & grad_output, const Tensor & self, Scalar negative_slope) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto negative_slope_ = negative_slope.toDouble();
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleLeakyReLU_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, negative_slope_, false);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor & CPUDoubleType::leaky_relu_forward_(Tensor & self, Scalar negative_slope) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto negative_slope_ = negative_slope.toDouble();
    THNN_DoubleLeakyReLU_updateOutput(globalContext().getTHCState(), self_, self_, negative_slope_, true);
    return self;
}
std::tuple<Tensor &,Tensor &> CPUDoubleType::log_sigmoid_forward_out(Tensor & output, Tensor & buffer, const Tensor & self) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto output_ = checked_tensor_unwrap(output,"output",1, false, Backend::CPU, ScalarType::Double);
    auto buffer_ = checked_tensor_unwrap(buffer,"buffer",1, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleLogSigmoid_updateOutput(globalContext().getTHCState(), self_, output_, buffer_);
    output_->maybe_zero_dim(self_->dim() == 0);
    buffer_->maybe_zero_dim(self_->dim() == 0);
    return std::tuple<Tensor &, Tensor &>(output, buffer);
}
std::tuple<Tensor,Tensor> CPUDoubleType::log_sigmoid_forward(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    auto buffer_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto buffer = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(buffer_));
    THNN_DoubleLogSigmoid_updateOutput(globalContext().getTHCState(), self_, output_, buffer_);
    output_->maybe_zero_dim(self_->dim() == 0);
    buffer_->maybe_zero_dim(self_->dim() == 0);
    return std::tuple<Tensor, Tensor>(output, buffer);
}
Tensor & CPUDoubleType::log_sigmoid_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, const Tensor & buffer) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto buffer_ = checked_tensor_unwrap(buffer,"buffer",3, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",3, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleLogSigmoid_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, buffer_);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::log_sigmoid_backward(const Tensor & grad_output, const Tensor & self, const Tensor & buffer) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto buffer_ = checked_tensor_unwrap(buffer,"buffer",3, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleLogSigmoid_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, buffer_);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor & CPUDoubleType::rrelu_with_noise_forward_out(Tensor & output, const Tensor & self, const Tensor & noise, Scalar lower, Scalar upper, bool training, Generator * generator) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto noise_ = checked_tensor_unwrap(noise,"noise",2, false, Backend::CPU, ScalarType::Double);
    auto lower_ = lower.toDouble();
    auto upper_ = upper.toDouble();
    auto generator_ = check_generator<CPUGenerator>(generator, &globalContext().defaultGenerator(device_type()));
    auto output_ = checked_tensor_unwrap(output,"output",6, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleRReLU_updateOutput(globalContext().getTHCState(), self_, output_, noise_, lower_, upper_, training, false, generator_->generator);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor CPUDoubleType::rrelu_with_noise_forward(const Tensor & self, const Tensor & noise, Scalar lower, Scalar upper, bool training, Generator * generator) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto noise_ = checked_tensor_unwrap(noise,"noise",2, false, Backend::CPU, ScalarType::Double);
    auto lower_ = lower.toDouble();
    auto upper_ = upper.toDouble();
    auto generator_ = check_generator<CPUGenerator>(generator, &globalContext().defaultGenerator(device_type()));
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    THNN_DoubleRReLU_updateOutput(globalContext().getTHCState(), self_, output_, noise_, lower_, upper_, training, false, generator_->generator);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor & CPUDoubleType::rrelu_with_noise_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, const Tensor & noise, Scalar lower, Scalar upper, bool training) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto noise_ = checked_tensor_unwrap(noise,"noise",3, false, Backend::CPU, ScalarType::Double);
    auto lower_ = lower.toDouble();
    auto upper_ = upper.toDouble();
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",6, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleRReLU_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, noise_, lower_, upper_, training, false);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::rrelu_with_noise_backward(const Tensor & grad_output, const Tensor & self, const Tensor & noise, Scalar lower, Scalar upper, bool training) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto noise_ = checked_tensor_unwrap(noise,"noise",3, false, Backend::CPU, ScalarType::Double);
    auto lower_ = lower.toDouble();
    auto upper_ = upper.toDouble();
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleRReLU_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, noise_, lower_, upper_, training, false);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor & CPUDoubleType::rrelu_with_noise_forward_(Tensor & self, const Tensor & noise, Scalar lower, Scalar upper, bool training, Generator * generator) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto noise_ = checked_tensor_unwrap(noise,"noise",2, false, Backend::CPU, ScalarType::Double);
    auto lower_ = lower.toDouble();
    auto upper_ = upper.toDouble();
    auto generator_ = check_generator<CPUGenerator>(generator, &globalContext().defaultGenerator(device_type()));
    THNN_DoubleRReLU_updateOutput(globalContext().getTHCState(), self_, self_, noise_, lower_, upper_, training, true, generator_->generator);
    return self;
}
Tensor & CPUDoubleType::softplus_forward_out(Tensor & output, const Tensor & self, Scalar beta, Scalar threshold) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto beta_ = beta.toDouble();
    auto threshold_ = threshold.toDouble();
    auto output_ = checked_tensor_unwrap(output,"output",3, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleSoftPlus_updateOutput(globalContext().getTHCState(), self_, output_, beta_, threshold_);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor CPUDoubleType::softplus_forward(const Tensor & self, Scalar beta, Scalar threshold) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto beta_ = beta.toDouble();
    auto threshold_ = threshold.toDouble();
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    THNN_DoubleSoftPlus_updateOutput(globalContext().getTHCState(), self_, output_, beta_, threshold_);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor & CPUDoubleType::softplus_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, Scalar beta, Scalar threshold, const Tensor & output) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto beta_ = beta.toDouble();
    auto threshold_ = threshold.toDouble();
    auto output_ = checked_tensor_unwrap(output,"output",5, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",5, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleSoftPlus_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, output_, beta_, threshold_);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::softplus_backward(const Tensor & grad_output, const Tensor & self, Scalar beta, Scalar threshold, const Tensor & output) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto beta_ = beta.toDouble();
    auto threshold_ = threshold.toDouble();
    auto output_ = checked_tensor_unwrap(output,"output",5, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleSoftPlus_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, output_, beta_, threshold_);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor & CPUDoubleType::softshrink_forward_out(Tensor & output, const Tensor & self, Scalar lambd) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto lambd_ = lambd.toDouble();
    auto output_ = checked_tensor_unwrap(output,"output",2, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleSoftShrink_updateOutput(globalContext().getTHCState(), self_, output_, lambd_);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor CPUDoubleType::softshrink_forward(const Tensor & self, Scalar lambd) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto lambd_ = lambd.toDouble();
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    THNN_DoubleSoftShrink_updateOutput(globalContext().getTHCState(), self_, output_, lambd_);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor & CPUDoubleType::softshrink_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, Scalar lambd) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto lambd_ = lambd.toDouble();
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",3, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleSoftShrink_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, lambd_);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::softshrink_backward(const Tensor & grad_output, const Tensor & self, Scalar lambd) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto lambd_ = lambd.toDouble();
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleSoftShrink_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, lambd_);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor & CPUDoubleType::threshold_forward_out(Tensor & output, const Tensor & self, Scalar threshold, Scalar value) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto threshold_ = threshold.toDouble();
    auto value_ = value.toDouble();
    auto output_ = checked_tensor_unwrap(output,"output",3, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleThreshold_updateOutput(globalContext().getTHCState(), self_, output_, threshold_, value_, false);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor CPUDoubleType::threshold_forward(const Tensor & self, Scalar threshold, Scalar value) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto threshold_ = threshold.toDouble();
    auto value_ = value.toDouble();
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    THNN_DoubleThreshold_updateOutput(globalContext().getTHCState(), self_, output_, threshold_, value_, false);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor & CPUDoubleType::threshold_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, Scalar threshold, Scalar value) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto threshold_ = threshold.toDouble();
    auto value_ = value.toDouble();
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",4, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleThreshold_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, threshold_, value_, false);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::threshold_backward(const Tensor & grad_output, const Tensor & self, Scalar threshold, Scalar value) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto threshold_ = threshold.toDouble();
    auto value_ = value.toDouble();
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleThreshold_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, threshold_, value_, false);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor & CPUDoubleType::threshold_forward_(Tensor & self, Scalar threshold, Scalar value) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto threshold_ = threshold.toDouble();
    auto value_ = value.toDouble();
    THNN_DoubleThreshold_updateOutput(globalContext().getTHCState(), self_, self_, threshold_, value_, true);
    return self;
}
Tensor & CPUDoubleType::adaptive_avg_pool2d_forward_out(Tensor & output, const Tensor & self, IntList output_size) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto output_size_ = check_intlist<2>(output_size, "output_size", 2);
    auto output_ = checked_tensor_unwrap(output,"output",2, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleSpatialAdaptiveAveragePooling_updateOutput(globalContext().getTHCState(), self_, output_, output_size_[1], output_size_[0]);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor CPUDoubleType::adaptive_avg_pool2d_forward(const Tensor & self, IntList output_size) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto output_size_ = check_intlist<2>(output_size, "output_size", 2);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    THNN_DoubleSpatialAdaptiveAveragePooling_updateOutput(globalContext().getTHCState(), self_, output_, output_size_[1], output_size_[0]);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor & CPUDoubleType::adaptive_avg_pool2d_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",2, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleSpatialAdaptiveAveragePooling_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::adaptive_avg_pool2d_backward(const Tensor & grad_output, const Tensor & self) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleSpatialAdaptiveAveragePooling_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor & CPUDoubleType::adaptive_avg_pool3d_forward_out(Tensor & output, const Tensor & self, IntList output_size) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto output_size_ = check_intlist<3>(output_size, "output_size", 2);
    auto output_ = checked_tensor_unwrap(output,"output",2, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleVolumetricAdaptiveAveragePooling_updateOutput(globalContext().getTHCState(), self_, output_, output_size_[0], output_size_[2], output_size_[1]);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor CPUDoubleType::adaptive_avg_pool3d_forward(const Tensor & self, IntList output_size) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto output_size_ = check_intlist<3>(output_size, "output_size", 2);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    THNN_DoubleVolumetricAdaptiveAveragePooling_updateOutput(globalContext().getTHCState(), self_, output_, output_size_[0], output_size_[2], output_size_[1]);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor & CPUDoubleType::adaptive_avg_pool3d_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",2, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleVolumetricAdaptiveAveragePooling_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::adaptive_avg_pool3d_backward(const Tensor & grad_output, const Tensor & self) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleVolumetricAdaptiveAveragePooling_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
std::tuple<Tensor &,Tensor &> CPUDoubleType::adaptive_max_pool2d_forward_out(Tensor & output, Tensor & indices, const Tensor & self, IntList output_size) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto output_size_ = check_intlist<2>(output_size, "output_size", 2);
    auto output_ = checked_tensor_unwrap(output,"output",2, false, Backend::CPU, ScalarType::Double);
    auto indices_ = checked_tensor_unwrap(indices,"indices",2, false, Backend::CPU, ScalarType::Long);
    THNN_DoubleSpatialAdaptiveMaxPooling_updateOutput(globalContext().getTHCState(), self_, output_, indices_, output_size_[1], output_size_[0]);
    bool maybe_scalar = self_->dim() == 0;
    output_->maybe_zero_dim(maybe_scalar);
    indices_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor &, Tensor &>(output, indices);
}
std::tuple<Tensor,Tensor> CPUDoubleType::adaptive_max_pool2d_forward(const Tensor & self, IntList output_size) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto output_size_ = check_intlist<2>(output_size, "output_size", 2);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    auto indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), scalarTypeToTypeMeta(ScalarType::Long), allocator(), false).release();
    auto indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(indices_));
    THNN_DoubleSpatialAdaptiveMaxPooling_updateOutput(globalContext().getTHCState(), self_, output_, indices_, output_size_[1], output_size_[0]);
    bool maybe_scalar = self_->dim() == 0;
    output_->maybe_zero_dim(maybe_scalar);
    indices_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor, Tensor>(output, indices);
}
Tensor & CPUDoubleType::adaptive_max_pool2d_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, const Tensor & indices) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto indices_ = checked_tensor_unwrap(indices,"indices",3, false, Backend::CPU, ScalarType::Long);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",3, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleSpatialAdaptiveMaxPooling_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, indices_);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::adaptive_max_pool2d_backward(const Tensor & grad_output, const Tensor & self, const Tensor & indices) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto indices_ = checked_tensor_unwrap(indices,"indices",3, false, Backend::CPU, ScalarType::Long);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleSpatialAdaptiveMaxPooling_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, indices_);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
std::tuple<Tensor &,Tensor &> CPUDoubleType::adaptive_max_pool3d_forward_out(Tensor & output, Tensor & indices, const Tensor & self, IntList output_size) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto output_size_ = check_intlist<3>(output_size, "output_size", 2);
    auto output_ = checked_tensor_unwrap(output,"output",2, false, Backend::CPU, ScalarType::Double);
    auto indices_ = checked_tensor_unwrap(indices,"indices",2, false, Backend::CPU, ScalarType::Long);
    THNN_DoubleVolumetricAdaptiveMaxPooling_updateOutput(globalContext().getTHCState(), self_, output_, indices_, output_size_[0], output_size_[2], output_size_[1]);
    bool maybe_scalar = self_->dim() == 0;
    output_->maybe_zero_dim(maybe_scalar);
    indices_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor &, Tensor &>(output, indices);
}
std::tuple<Tensor,Tensor> CPUDoubleType::adaptive_max_pool3d_forward(const Tensor & self, IntList output_size) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto output_size_ = check_intlist<3>(output_size, "output_size", 2);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    auto indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), scalarTypeToTypeMeta(ScalarType::Long), allocator(), false).release();
    auto indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(indices_));
    THNN_DoubleVolumetricAdaptiveMaxPooling_updateOutput(globalContext().getTHCState(), self_, output_, indices_, output_size_[0], output_size_[2], output_size_[1]);
    bool maybe_scalar = self_->dim() == 0;
    output_->maybe_zero_dim(maybe_scalar);
    indices_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor, Tensor>(output, indices);
}
Tensor & CPUDoubleType::adaptive_max_pool3d_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, const Tensor & indices) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto indices_ = checked_tensor_unwrap(indices,"indices",3, false, Backend::CPU, ScalarType::Long);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",3, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleVolumetricAdaptiveMaxPooling_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, indices_);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::adaptive_max_pool3d_backward(const Tensor & grad_output, const Tensor & self, const Tensor & indices) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto indices_ = checked_tensor_unwrap(indices,"indices",3, false, Backend::CPU, ScalarType::Long);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleVolumetricAdaptiveMaxPooling_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, indices_);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor & CPUDoubleType::avg_pool2d_forward_out(Tensor & output, const Tensor & self, IntList kernel_size, IntList stride, IntList padding, bool ceil_mode, bool count_include_pad) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<2>(kernel_size, "kernel_size", 2);
    auto stride_ = check_intlist<2>(stride, "stride", 3, kernel_size);
    auto padding_ = check_intlist<2>(padding, "padding", 4);
    auto output_ = checked_tensor_unwrap(output,"output",6, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleSpatialAveragePooling_updateOutput(globalContext().getTHCState(), self_, output_, kernel_size_[1], kernel_size_[0], stride_[1], stride_[0], padding_[1], padding_[0], ceil_mode, count_include_pad);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor CPUDoubleType::avg_pool2d_forward(const Tensor & self, IntList kernel_size, IntList stride, IntList padding, bool ceil_mode, bool count_include_pad) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<2>(kernel_size, "kernel_size", 2);
    auto stride_ = check_intlist<2>(stride, "stride", 3, kernel_size);
    auto padding_ = check_intlist<2>(padding, "padding", 4);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    THNN_DoubleSpatialAveragePooling_updateOutput(globalContext().getTHCState(), self_, output_, kernel_size_[1], kernel_size_[0], stride_[1], stride_[0], padding_[1], padding_[0], ceil_mode, count_include_pad);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor & CPUDoubleType::avg_pool2d_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, IntList kernel_size, IntList stride, IntList padding, bool ceil_mode, bool count_include_pad) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<2>(kernel_size, "kernel_size", 3);
    auto stride_ = check_intlist<2>(stride, "stride", 4, kernel_size);
    auto padding_ = check_intlist<2>(padding, "padding", 5);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",7, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleSpatialAveragePooling_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, kernel_size_[1], kernel_size_[0], stride_[1], stride_[0], padding_[1], padding_[0], ceil_mode, count_include_pad);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::avg_pool2d_backward(const Tensor & grad_output, const Tensor & self, IntList kernel_size, IntList stride, IntList padding, bool ceil_mode, bool count_include_pad) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<2>(kernel_size, "kernel_size", 3);
    auto stride_ = check_intlist<2>(stride, "stride", 4, kernel_size);
    auto padding_ = check_intlist<2>(padding, "padding", 5);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleSpatialAveragePooling_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, kernel_size_[1], kernel_size_[0], stride_[1], stride_[0], padding_[1], padding_[0], ceil_mode, count_include_pad);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor & CPUDoubleType::avg_pool3d_forward_out(Tensor & output, const Tensor & self, IntList kernel_size, IntList stride, IntList padding, bool ceil_mode, bool count_include_pad) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<3>(kernel_size, "kernel_size", 2);
    auto stride_ = check_intlist<3>(stride, "stride", 3, kernel_size);
    auto padding_ = check_intlist<3>(padding, "padding", 4);
    auto output_ = checked_tensor_unwrap(output,"output",6, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleVolumetricAveragePooling_updateOutput(globalContext().getTHCState(), self_, output_, kernel_size_[0], kernel_size_[2], kernel_size_[1], stride_[0], stride_[2], stride_[1], padding_[0], padding_[2], padding_[1], ceil_mode, count_include_pad);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor CPUDoubleType::avg_pool3d_forward(const Tensor & self, IntList kernel_size, IntList stride, IntList padding, bool ceil_mode, bool count_include_pad) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<3>(kernel_size, "kernel_size", 2);
    auto stride_ = check_intlist<3>(stride, "stride", 3, kernel_size);
    auto padding_ = check_intlist<3>(padding, "padding", 4);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    THNN_DoubleVolumetricAveragePooling_updateOutput(globalContext().getTHCState(), self_, output_, kernel_size_[0], kernel_size_[2], kernel_size_[1], stride_[0], stride_[2], stride_[1], padding_[0], padding_[2], padding_[1], ceil_mode, count_include_pad);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor & CPUDoubleType::avg_pool3d_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, IntList kernel_size, IntList stride, IntList padding, bool ceil_mode, bool count_include_pad) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<3>(kernel_size, "kernel_size", 3);
    auto stride_ = check_intlist<3>(stride, "stride", 4, kernel_size);
    auto padding_ = check_intlist<3>(padding, "padding", 5);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",7, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleVolumetricAveragePooling_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, kernel_size_[0], kernel_size_[2], kernel_size_[1], stride_[0], stride_[2], stride_[1], padding_[0], padding_[2], padding_[1], ceil_mode, count_include_pad);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::avg_pool3d_backward(const Tensor & grad_output, const Tensor & self, IntList kernel_size, IntList stride, IntList padding, bool ceil_mode, bool count_include_pad) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<3>(kernel_size, "kernel_size", 3);
    auto stride_ = check_intlist<3>(stride, "stride", 4, kernel_size);
    auto padding_ = check_intlist<3>(padding, "padding", 5);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleVolumetricAveragePooling_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, kernel_size_[0], kernel_size_[2], kernel_size_[1], stride_[0], stride_[2], stride_[1], padding_[0], padding_[2], padding_[1], ceil_mode, count_include_pad);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
std::tuple<Tensor &,Tensor &> CPUDoubleType::fractional_max_pool2d_forward_out(Tensor & output, Tensor & indices, const Tensor & self, IntList kernel_size, IntList output_size, const Tensor & random_samples) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<2>(kernel_size, "kernel_size", 2);
    auto output_size_ = check_intlist<2>(output_size, "output_size", 3);
    auto random_samples_ = checked_tensor_unwrap(random_samples,"random_samples",4, false, Backend::CPU, ScalarType::Double);
    auto output_ = checked_tensor_unwrap(output,"output",4, false, Backend::CPU, ScalarType::Double);
    auto indices_ = checked_tensor_unwrap(indices,"indices",4, false, Backend::CPU, ScalarType::Long);
    THNN_DoubleSpatialFractionalMaxPooling_updateOutput(globalContext().getTHCState(), self_, output_, output_size_[1], output_size_[0], kernel_size_[1], kernel_size_[0], indices_, random_samples_);
    output_->maybe_zero_dim(false);
    return std::tuple<Tensor &, Tensor &>(output, indices);
}
std::tuple<Tensor,Tensor> CPUDoubleType::fractional_max_pool2d_forward(const Tensor & self, IntList kernel_size, IntList output_size, const Tensor & random_samples) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<2>(kernel_size, "kernel_size", 2);
    auto output_size_ = check_intlist<2>(output_size, "output_size", 3);
    auto random_samples_ = checked_tensor_unwrap(random_samples,"random_samples",4, false, Backend::CPU, ScalarType::Double);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    auto indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), scalarTypeToTypeMeta(ScalarType::Long), allocator(), false).release();
    auto indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(indices_));
    THNN_DoubleSpatialFractionalMaxPooling_updateOutput(globalContext().getTHCState(), self_, output_, output_size_[1], output_size_[0], kernel_size_[1], kernel_size_[0], indices_, random_samples_);
    output_->maybe_zero_dim(false);
    return std::tuple<Tensor, Tensor>(output, indices);
}
Tensor & CPUDoubleType::fractional_max_pool2d_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, IntList kernel_size, IntList output_size, const Tensor & indices) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<2>(kernel_size, "kernel_size", 3);
    auto output_size_ = check_intlist<2>(output_size, "output_size", 4);
    auto indices_ = checked_tensor_unwrap(indices,"indices",5, false, Backend::CPU, ScalarType::Long);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",5, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleSpatialFractionalMaxPooling_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, output_size_[1], output_size_[0], kernel_size_[1], kernel_size_[0], indices_);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::fractional_max_pool2d_backward(const Tensor & grad_output, const Tensor & self, IntList kernel_size, IntList output_size, const Tensor & indices) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<2>(kernel_size, "kernel_size", 3);
    auto output_size_ = check_intlist<2>(output_size, "output_size", 4);
    auto indices_ = checked_tensor_unwrap(indices,"indices",5, false, Backend::CPU, ScalarType::Long);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleSpatialFractionalMaxPooling_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, output_size_[1], output_size_[0], kernel_size_[1], kernel_size_[0], indices_);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
std::tuple<Tensor &,Tensor &> CPUDoubleType::max_pool2d_with_indices_forward_out(Tensor & output, Tensor & indices, const Tensor & self, IntList kernel_size, IntList stride, IntList padding, IntList dilation, bool ceil_mode) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<2>(kernel_size, "kernel_size", 2);
    auto stride_ = check_intlist<2>(stride, "stride", 3, kernel_size);
    auto padding_ = check_intlist<2>(padding, "padding", 4);
    auto dilation_ = check_intlist<2>(dilation, "dilation", 5);
    auto output_ = checked_tensor_unwrap(output,"output",6, false, Backend::CPU, ScalarType::Double);
    auto indices_ = checked_tensor_unwrap(indices,"indices",6, false, Backend::CPU, ScalarType::Long);
    THNN_DoubleSpatialDilatedMaxPooling_updateOutput(globalContext().getTHCState(), self_, output_, indices_, kernel_size_[1], kernel_size_[0], stride_[1], stride_[0], padding_[1], padding_[0], dilation_[1], dilation_[0], ceil_mode);
    bool maybe_scalar = self_->dim() == 0;
    output_->maybe_zero_dim(maybe_scalar);
    indices_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor &, Tensor &>(output, indices);
}
std::tuple<Tensor,Tensor> CPUDoubleType::max_pool2d_with_indices_forward(const Tensor & self, IntList kernel_size, IntList stride, IntList padding, IntList dilation, bool ceil_mode) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<2>(kernel_size, "kernel_size", 2);
    auto stride_ = check_intlist<2>(stride, "stride", 3, kernel_size);
    auto padding_ = check_intlist<2>(padding, "padding", 4);
    auto dilation_ = check_intlist<2>(dilation, "dilation", 5);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    auto indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), scalarTypeToTypeMeta(ScalarType::Long), allocator(), false).release();
    auto indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(indices_));
    THNN_DoubleSpatialDilatedMaxPooling_updateOutput(globalContext().getTHCState(), self_, output_, indices_, kernel_size_[1], kernel_size_[0], stride_[1], stride_[0], padding_[1], padding_[0], dilation_[1], dilation_[0], ceil_mode);
    bool maybe_scalar = self_->dim() == 0;
    output_->maybe_zero_dim(maybe_scalar);
    indices_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor, Tensor>(output, indices);
}
Tensor & CPUDoubleType::max_pool2d_with_indices_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, IntList kernel_size, IntList stride, IntList padding, IntList dilation, bool ceil_mode, const Tensor & indices) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<2>(kernel_size, "kernel_size", 3);
    auto stride_ = check_intlist<2>(stride, "stride", 4, kernel_size);
    auto padding_ = check_intlist<2>(padding, "padding", 5);
    auto dilation_ = check_intlist<2>(dilation, "dilation", 6);
    auto indices_ = checked_tensor_unwrap(indices,"indices",8, false, Backend::CPU, ScalarType::Long);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",8, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleSpatialDilatedMaxPooling_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, indices_, kernel_size_[1], kernel_size_[0], stride_[1], stride_[0], padding_[1], padding_[0], dilation_[1], dilation_[0], ceil_mode);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::max_pool2d_with_indices_backward(const Tensor & grad_output, const Tensor & self, IntList kernel_size, IntList stride, IntList padding, IntList dilation, bool ceil_mode, const Tensor & indices) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<2>(kernel_size, "kernel_size", 3);
    auto stride_ = check_intlist<2>(stride, "stride", 4, kernel_size);
    auto padding_ = check_intlist<2>(padding, "padding", 5);
    auto dilation_ = check_intlist<2>(dilation, "dilation", 6);
    auto indices_ = checked_tensor_unwrap(indices,"indices",8, false, Backend::CPU, ScalarType::Long);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleSpatialDilatedMaxPooling_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, indices_, kernel_size_[1], kernel_size_[0], stride_[1], stride_[0], padding_[1], padding_[0], dilation_[1], dilation_[0], ceil_mode);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
std::tuple<Tensor &,Tensor &> CPUDoubleType::max_pool3d_with_indices_forward_out(Tensor & output, Tensor & indices, const Tensor & self, IntList kernel_size, IntList stride, IntList padding, IntList dilation, bool ceil_mode) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<3>(kernel_size, "kernel_size", 2);
    auto stride_ = check_intlist<3>(stride, "stride", 3, kernel_size);
    auto padding_ = check_intlist<3>(padding, "padding", 4);
    auto dilation_ = check_intlist<3>(dilation, "dilation", 5);
    auto output_ = checked_tensor_unwrap(output,"output",6, false, Backend::CPU, ScalarType::Double);
    auto indices_ = checked_tensor_unwrap(indices,"indices",6, false, Backend::CPU, ScalarType::Long);
    THNN_DoubleVolumetricDilatedMaxPooling_updateOutput(globalContext().getTHCState(), self_, output_, indices_, kernel_size_[0], kernel_size_[2], kernel_size_[1], stride_[0], stride_[2], stride_[1], padding_[0], padding_[2], padding_[1], dilation_[0], dilation_[2], dilation_[1], ceil_mode);
    bool maybe_scalar = self_->dim() == 0;
    output_->maybe_zero_dim(maybe_scalar);
    indices_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor &, Tensor &>(output, indices);
}
std::tuple<Tensor,Tensor> CPUDoubleType::max_pool3d_with_indices_forward(const Tensor & self, IntList kernel_size, IntList stride, IntList padding, IntList dilation, bool ceil_mode) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<3>(kernel_size, "kernel_size", 2);
    auto stride_ = check_intlist<3>(stride, "stride", 3, kernel_size);
    auto padding_ = check_intlist<3>(padding, "padding", 4);
    auto dilation_ = check_intlist<3>(dilation, "dilation", 5);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    auto indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), scalarTypeToTypeMeta(ScalarType::Long), allocator(), false).release();
    auto indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(indices_));
    THNN_DoubleVolumetricDilatedMaxPooling_updateOutput(globalContext().getTHCState(), self_, output_, indices_, kernel_size_[0], kernel_size_[2], kernel_size_[1], stride_[0], stride_[2], stride_[1], padding_[0], padding_[2], padding_[1], dilation_[0], dilation_[2], dilation_[1], ceil_mode);
    bool maybe_scalar = self_->dim() == 0;
    output_->maybe_zero_dim(maybe_scalar);
    indices_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor, Tensor>(output, indices);
}
Tensor & CPUDoubleType::max_pool3d_with_indices_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, IntList kernel_size, IntList stride, IntList padding, IntList dilation, bool ceil_mode, const Tensor & indices) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<3>(kernel_size, "kernel_size", 3);
    auto stride_ = check_intlist<3>(stride, "stride", 4, kernel_size);
    auto padding_ = check_intlist<3>(padding, "padding", 5);
    auto dilation_ = check_intlist<3>(dilation, "dilation", 6);
    auto indices_ = checked_tensor_unwrap(indices,"indices",8, false, Backend::CPU, ScalarType::Long);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",8, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleVolumetricDilatedMaxPooling_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, indices_, kernel_size_[0], kernel_size_[2], kernel_size_[1], stride_[0], stride_[2], stride_[1], padding_[0], padding_[2], padding_[1], dilation_[0], dilation_[2], dilation_[1], ceil_mode);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::max_pool3d_with_indices_backward(const Tensor & grad_output, const Tensor & self, IntList kernel_size, IntList stride, IntList padding, IntList dilation, bool ceil_mode, const Tensor & indices) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<3>(kernel_size, "kernel_size", 3);
    auto stride_ = check_intlist<3>(stride, "stride", 4, kernel_size);
    auto padding_ = check_intlist<3>(padding, "padding", 5);
    auto dilation_ = check_intlist<3>(dilation, "dilation", 6);
    auto indices_ = checked_tensor_unwrap(indices,"indices",8, false, Backend::CPU, ScalarType::Long);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleVolumetricDilatedMaxPooling_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, indices_, kernel_size_[0], kernel_size_[2], kernel_size_[1], stride_[0], stride_[2], stride_[1], padding_[0], padding_[2], padding_[1], dilation_[0], dilation_[2], dilation_[1], ceil_mode);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor & CPUDoubleType::max_unpool2d_forward_out(Tensor & output, const Tensor & self, const Tensor & indices, IntList output_size) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto indices_ = checked_tensor_unwrap(indices,"indices",2, false, Backend::CPU, ScalarType::Long);
    auto output_size_ = check_intlist<2>(output_size, "output_size", 3);
    auto output_ = checked_tensor_unwrap(output,"output",3, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleSpatialMaxUnpooling_updateOutput(globalContext().getTHCState(), self_, output_, indices_, output_size_[1], output_size_[0]);
    output_->maybe_zero_dim(self_->dim() == 0 && indices_->dim() == 0);
    return output;
}
Tensor CPUDoubleType::max_unpool2d_forward(const Tensor & self, const Tensor & indices, IntList output_size) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto indices_ = checked_tensor_unwrap(indices,"indices",2, false, Backend::CPU, ScalarType::Long);
    auto output_size_ = check_intlist<2>(output_size, "output_size", 3);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    THNN_DoubleSpatialMaxUnpooling_updateOutput(globalContext().getTHCState(), self_, output_, indices_, output_size_[1], output_size_[0]);
    output_->maybe_zero_dim(self_->dim() == 0 && indices_->dim() == 0);
    return output;
}
Tensor & CPUDoubleType::max_unpool2d_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, const Tensor & indices, IntList output_size) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto indices_ = checked_tensor_unwrap(indices,"indices",3, false, Backend::CPU, ScalarType::Long);
    auto output_size_ = check_intlist<2>(output_size, "output_size", 4);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",4, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleSpatialMaxUnpooling_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, indices_, output_size_[1], output_size_[0]);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::max_unpool2d_backward(const Tensor & grad_output, const Tensor & self, const Tensor & indices, IntList output_size) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto indices_ = checked_tensor_unwrap(indices,"indices",3, false, Backend::CPU, ScalarType::Long);
    auto output_size_ = check_intlist<2>(output_size, "output_size", 4);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleSpatialMaxUnpooling_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, indices_, output_size_[1], output_size_[0]);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor & CPUDoubleType::max_unpool3d_forward_out(Tensor & output, const Tensor & self, const Tensor & indices, IntList output_size, IntList stride, IntList padding) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto indices_ = checked_tensor_unwrap(indices,"indices",2, false, Backend::CPU, ScalarType::Long);
    auto output_size_ = check_intlist<3>(output_size, "output_size", 3);
    auto stride_ = check_intlist<3>(stride, "stride", 4);
    auto padding_ = check_intlist<3>(padding, "padding", 5);
    auto output_ = checked_tensor_unwrap(output,"output",5, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleVolumetricMaxUnpooling_updateOutput(globalContext().getTHCState(), self_, output_, indices_, output_size_[0], output_size_[2], output_size_[1], stride_[0], stride_[2], stride_[1], padding_[0], padding_[2], padding_[1]);
    output_->maybe_zero_dim(self_->dim() == 0 && indices_->dim() == 0);
    return output;
}
Tensor CPUDoubleType::max_unpool3d_forward(const Tensor & self, const Tensor & indices, IntList output_size, IntList stride, IntList padding) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto indices_ = checked_tensor_unwrap(indices,"indices",2, false, Backend::CPU, ScalarType::Long);
    auto output_size_ = check_intlist<3>(output_size, "output_size", 3);
    auto stride_ = check_intlist<3>(stride, "stride", 4);
    auto padding_ = check_intlist<3>(padding, "padding", 5);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    THNN_DoubleVolumetricMaxUnpooling_updateOutput(globalContext().getTHCState(), self_, output_, indices_, output_size_[0], output_size_[2], output_size_[1], stride_[0], stride_[2], stride_[1], padding_[0], padding_[2], padding_[1]);
    output_->maybe_zero_dim(self_->dim() == 0 && indices_->dim() == 0);
    return output;
}
Tensor & CPUDoubleType::max_unpool3d_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, const Tensor & indices, IntList output_size, IntList stride, IntList padding) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto indices_ = checked_tensor_unwrap(indices,"indices",3, false, Backend::CPU, ScalarType::Long);
    auto output_size_ = check_intlist<3>(output_size, "output_size", 4);
    auto stride_ = check_intlist<3>(stride, "stride", 5);
    auto padding_ = check_intlist<3>(padding, "padding", 6);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",6, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleVolumetricMaxUnpooling_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, indices_, output_size_[0], output_size_[2], output_size_[1], stride_[0], stride_[2], stride_[1], padding_[0], padding_[2], padding_[1]);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::max_unpool3d_backward(const Tensor & grad_output, const Tensor & self, const Tensor & indices, IntList output_size, IntList stride, IntList padding) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto indices_ = checked_tensor_unwrap(indices,"indices",3, false, Backend::CPU, ScalarType::Long);
    auto output_size_ = check_intlist<3>(output_size, "output_size", 4);
    auto stride_ = check_intlist<3>(stride, "stride", 5);
    auto padding_ = check_intlist<3>(padding, "padding", 6);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleVolumetricMaxUnpooling_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, indices_, output_size_[0], output_size_[2], output_size_[1], stride_[0], stride_[2], stride_[1], padding_[0], padding_[2], padding_[1]);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor & CPUDoubleType::reflection_pad1d_forward_out(Tensor & output, const Tensor & self, IntList padding) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto padding_ = check_intlist<2>(padding, "padding", 2);
    auto output_ = checked_tensor_unwrap(output,"output",2, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleTemporalReflectionPadding_updateOutput(globalContext().getTHCState(), self_, output_, padding_[0], padding_[1]);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor CPUDoubleType::reflection_pad1d_forward(const Tensor & self, IntList padding) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto padding_ = check_intlist<2>(padding, "padding", 2);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    THNN_DoubleTemporalReflectionPadding_updateOutput(globalContext().getTHCState(), self_, output_, padding_[0], padding_[1]);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor & CPUDoubleType::reflection_pad1d_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, IntList padding) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto padding_ = check_intlist<2>(padding, "padding", 3);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",3, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleTemporalReflectionPadding_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, padding_[0], padding_[1]);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::reflection_pad1d_backward(const Tensor & grad_output, const Tensor & self, IntList padding) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto padding_ = check_intlist<2>(padding, "padding", 3);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleTemporalReflectionPadding_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, padding_[0], padding_[1]);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor & CPUDoubleType::reflection_pad2d_forward_out(Tensor & output, const Tensor & self, IntList padding) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto padding_ = check_intlist<4>(padding, "padding", 2);
    auto output_ = checked_tensor_unwrap(output,"output",2, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleSpatialReflectionPadding_updateOutput(globalContext().getTHCState(), self_, output_, padding_[0], padding_[1], padding_[2], padding_[3]);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor CPUDoubleType::reflection_pad2d_forward(const Tensor & self, IntList padding) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto padding_ = check_intlist<4>(padding, "padding", 2);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    THNN_DoubleSpatialReflectionPadding_updateOutput(globalContext().getTHCState(), self_, output_, padding_[0], padding_[1], padding_[2], padding_[3]);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor & CPUDoubleType::reflection_pad2d_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, IntList padding) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto padding_ = check_intlist<4>(padding, "padding", 3);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",3, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleSpatialReflectionPadding_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, padding_[0], padding_[1], padding_[2], padding_[3]);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::reflection_pad2d_backward(const Tensor & grad_output, const Tensor & self, IntList padding) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto padding_ = check_intlist<4>(padding, "padding", 3);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleSpatialReflectionPadding_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, padding_[0], padding_[1], padding_[2], padding_[3]);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor & CPUDoubleType::replication_pad1d_forward_out(Tensor & output, const Tensor & self, IntList padding) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto padding_ = check_intlist<2>(padding, "padding", 2);
    auto output_ = checked_tensor_unwrap(output,"output",2, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleTemporalReplicationPadding_updateOutput(globalContext().getTHCState(), self_, output_, padding_[0], padding_[1]);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor CPUDoubleType::replication_pad1d_forward(const Tensor & self, IntList padding) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto padding_ = check_intlist<2>(padding, "padding", 2);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    THNN_DoubleTemporalReplicationPadding_updateOutput(globalContext().getTHCState(), self_, output_, padding_[0], padding_[1]);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor & CPUDoubleType::replication_pad1d_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, IntList padding) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto padding_ = check_intlist<2>(padding, "padding", 3);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",3, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleTemporalReplicationPadding_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, padding_[0], padding_[1]);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::replication_pad1d_backward(const Tensor & grad_output, const Tensor & self, IntList padding) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto padding_ = check_intlist<2>(padding, "padding", 3);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleTemporalReplicationPadding_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, padding_[0], padding_[1]);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor & CPUDoubleType::replication_pad2d_forward_out(Tensor & output, const Tensor & self, IntList padding) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto padding_ = check_intlist<4>(padding, "padding", 2);
    auto output_ = checked_tensor_unwrap(output,"output",2, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleSpatialReplicationPadding_updateOutput(globalContext().getTHCState(), self_, output_, padding_[0], padding_[1], padding_[2], padding_[3]);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor CPUDoubleType::replication_pad2d_forward(const Tensor & self, IntList padding) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto padding_ = check_intlist<4>(padding, "padding", 2);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    THNN_DoubleSpatialReplicationPadding_updateOutput(globalContext().getTHCState(), self_, output_, padding_[0], padding_[1], padding_[2], padding_[3]);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor & CPUDoubleType::replication_pad2d_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, IntList padding) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto padding_ = check_intlist<4>(padding, "padding", 3);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",3, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleSpatialReplicationPadding_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, padding_[0], padding_[1], padding_[2], padding_[3]);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::replication_pad2d_backward(const Tensor & grad_output, const Tensor & self, IntList padding) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto padding_ = check_intlist<4>(padding, "padding", 3);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleSpatialReplicationPadding_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, padding_[0], padding_[1], padding_[2], padding_[3]);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor & CPUDoubleType::replication_pad3d_forward_out(Tensor & output, const Tensor & self, IntList padding) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto padding_ = check_intlist<6>(padding, "padding", 2);
    auto output_ = checked_tensor_unwrap(output,"output",2, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleVolumetricReplicationPadding_updateOutput(globalContext().getTHCState(), self_, output_, padding_[0], padding_[1], padding_[2], padding_[3], padding_[4], padding_[5]);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor CPUDoubleType::replication_pad3d_forward(const Tensor & self, IntList padding) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto padding_ = check_intlist<6>(padding, "padding", 2);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    THNN_DoubleVolumetricReplicationPadding_updateOutput(globalContext().getTHCState(), self_, output_, padding_[0], padding_[1], padding_[2], padding_[3], padding_[4], padding_[5]);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor & CPUDoubleType::replication_pad3d_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, IntList padding) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto padding_ = check_intlist<6>(padding, "padding", 3);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",3, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleVolumetricReplicationPadding_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, padding_[0], padding_[1], padding_[2], padding_[3], padding_[4], padding_[5]);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::replication_pad3d_backward(const Tensor & grad_output, const Tensor & self, IntList padding) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto padding_ = check_intlist<6>(padding, "padding", 3);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleVolumetricReplicationPadding_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_, padding_[0], padding_[1], padding_[2], padding_[3], padding_[4], padding_[5]);
    grad_input_->maybe_zero_dim(self_->dim() == 0);
    return grad_input;
}
Tensor & CPUDoubleType::upsample_linear1d_forward_out(Tensor & output, const Tensor & self, IntList output_size, bool align_corners) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto output_size_ = check_intlist<1>(output_size, "output_size", 2);
    auto output_ = checked_tensor_unwrap(output,"output",3, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleTemporalUpSamplingLinear_updateOutput(globalContext().getTHCState(), self_, output_, output_size_[0], align_corners);
    return output;
}
Tensor CPUDoubleType::upsample_linear1d_forward(const Tensor & self, IntList output_size, bool align_corners) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto output_size_ = check_intlist<1>(output_size, "output_size", 2);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    THNN_DoubleTemporalUpSamplingLinear_updateOutput(globalContext().getTHCState(), self_, output_, output_size_[0], align_corners);
    return output;
}
Tensor & CPUDoubleType::upsample_linear1d_backward_out(Tensor & grad_input, const Tensor & grad_output, IntList output_size, IntList input_size, bool align_corners) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto output_size_ = check_intlist<1>(output_size, "output_size", 2);
    auto input_size_ = check_intlist<3>(input_size, "input_size", 3);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",4, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleTemporalUpSamplingLinear_updateGradInput(globalContext().getTHCState(), grad_output_, grad_input_, input_size_[0], input_size_[1], input_size_[2], output_size_[0], align_corners);
    grad_input_->maybe_zero_dim(false);
    return grad_input;
}
Tensor CPUDoubleType::upsample_linear1d_backward(const Tensor & grad_output, IntList output_size, IntList input_size, bool align_corners) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto output_size_ = check_intlist<1>(output_size, "output_size", 2);
    auto input_size_ = check_intlist<3>(input_size, "input_size", 3);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleTemporalUpSamplingLinear_updateGradInput(globalContext().getTHCState(), grad_output_, grad_input_, input_size_[0], input_size_[1], input_size_[2], output_size_[0], align_corners);
    grad_input_->maybe_zero_dim(false);
    return grad_input;
}
Tensor & CPUDoubleType::upsample_bilinear2d_forward_out(Tensor & output, const Tensor & self, IntList output_size, bool align_corners) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto output_size_ = check_intlist<2>(output_size, "output_size", 2);
    auto output_ = checked_tensor_unwrap(output,"output",3, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleSpatialUpSamplingBilinear_updateOutput(globalContext().getTHCState(), self_, output_, output_size_[0], output_size_[1], align_corners);
    return output;
}
Tensor CPUDoubleType::upsample_bilinear2d_forward(const Tensor & self, IntList output_size, bool align_corners) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto output_size_ = check_intlist<2>(output_size, "output_size", 2);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    THNN_DoubleSpatialUpSamplingBilinear_updateOutput(globalContext().getTHCState(), self_, output_, output_size_[0], output_size_[1], align_corners);
    return output;
}
Tensor & CPUDoubleType::upsample_bilinear2d_backward_out(Tensor & grad_input, const Tensor & grad_output, IntList output_size, IntList input_size, bool align_corners) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto output_size_ = check_intlist<2>(output_size, "output_size", 2);
    auto input_size_ = check_intlist<4>(input_size, "input_size", 3);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",4, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleSpatialUpSamplingBilinear_updateGradInput(globalContext().getTHCState(), grad_output_, grad_input_, input_size_[0], input_size_[1], input_size_[2], input_size_[3], output_size_[0], output_size_[1], align_corners);
    grad_input_->maybe_zero_dim(false);
    return grad_input;
}
Tensor CPUDoubleType::upsample_bilinear2d_backward(const Tensor & grad_output, IntList output_size, IntList input_size, bool align_corners) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto output_size_ = check_intlist<2>(output_size, "output_size", 2);
    auto input_size_ = check_intlist<4>(input_size, "input_size", 3);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleSpatialUpSamplingBilinear_updateGradInput(globalContext().getTHCState(), grad_output_, grad_input_, input_size_[0], input_size_[1], input_size_[2], input_size_[3], output_size_[0], output_size_[1], align_corners);
    grad_input_->maybe_zero_dim(false);
    return grad_input;
}
Tensor & CPUDoubleType::upsample_trilinear3d_forward_out(Tensor & output, const Tensor & self, IntList output_size, bool align_corners) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto output_size_ = check_intlist<3>(output_size, "output_size", 2);
    auto output_ = checked_tensor_unwrap(output,"output",3, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleVolumetricUpSamplingTrilinear_updateOutput(globalContext().getTHCState(), self_, output_, output_size_[0], output_size_[1], output_size_[2], align_corners);
    return output;
}
Tensor CPUDoubleType::upsample_trilinear3d_forward(const Tensor & self, IntList output_size, bool align_corners) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto output_size_ = check_intlist<3>(output_size, "output_size", 2);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    THNN_DoubleVolumetricUpSamplingTrilinear_updateOutput(globalContext().getTHCState(), self_, output_, output_size_[0], output_size_[1], output_size_[2], align_corners);
    return output;
}
Tensor & CPUDoubleType::upsample_trilinear3d_backward_out(Tensor & grad_input, const Tensor & grad_output, IntList output_size, IntList input_size, bool align_corners) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto output_size_ = check_intlist<3>(output_size, "output_size", 2);
    auto input_size_ = check_intlist<5>(input_size, "input_size", 3);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",4, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleVolumetricUpSamplingTrilinear_updateGradInput(globalContext().getTHCState(), grad_output_, grad_input_, input_size_[0], input_size_[1], input_size_[2], input_size_[3], input_size_[4], output_size_[0], output_size_[1], output_size_[2], align_corners);
    grad_input_->maybe_zero_dim(false);
    return grad_input;
}
Tensor CPUDoubleType::upsample_trilinear3d_backward(const Tensor & grad_output, IntList output_size, IntList input_size, bool align_corners) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto output_size_ = check_intlist<3>(output_size, "output_size", 2);
    auto input_size_ = check_intlist<5>(input_size, "input_size", 3);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleVolumetricUpSamplingTrilinear_updateGradInput(globalContext().getTHCState(), grad_output_, grad_input_, input_size_[0], input_size_[1], input_size_[2], input_size_[3], input_size_[4], output_size_[0], output_size_[1], output_size_[2], align_corners);
    grad_input_->maybe_zero_dim(false);
    return grad_input;
}
Tensor & CPUDoubleType::upsample_nearest1d_forward_out(Tensor & output, const Tensor & self, IntList output_size) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto output_size_ = check_intlist<1>(output_size, "output_size", 2);
    auto output_ = checked_tensor_unwrap(output,"output",2, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleTemporalUpSamplingNearest_updateOutput(globalContext().getTHCState(), self_, output_, output_size_[0]);
    return output;
}
Tensor CPUDoubleType::upsample_nearest1d_forward(const Tensor & self, IntList output_size) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto output_size_ = check_intlist<1>(output_size, "output_size", 2);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    THNN_DoubleTemporalUpSamplingNearest_updateOutput(globalContext().getTHCState(), self_, output_, output_size_[0]);
    return output;
}
Tensor & CPUDoubleType::upsample_nearest1d_backward_out(Tensor & grad_input, const Tensor & grad_output, IntList output_size, IntList input_size) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto output_size_ = check_intlist<1>(output_size, "output_size", 2);
    auto input_size_ = check_intlist<3>(input_size, "input_size", 3);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",3, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleTemporalUpSamplingNearest_updateGradInput(globalContext().getTHCState(), grad_output_, grad_input_, input_size_[0], input_size_[1], input_size_[2], output_size_[0]);
    grad_input_->maybe_zero_dim(false);
    return grad_input;
}
Tensor CPUDoubleType::upsample_nearest1d_backward(const Tensor & grad_output, IntList output_size, IntList input_size) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto output_size_ = check_intlist<1>(output_size, "output_size", 2);
    auto input_size_ = check_intlist<3>(input_size, "input_size", 3);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleTemporalUpSamplingNearest_updateGradInput(globalContext().getTHCState(), grad_output_, grad_input_, input_size_[0], input_size_[1], input_size_[2], output_size_[0]);
    grad_input_->maybe_zero_dim(false);
    return grad_input;
}
Tensor & CPUDoubleType::upsample_nearest2d_forward_out(Tensor & output, const Tensor & self, IntList output_size) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto output_size_ = check_intlist<2>(output_size, "output_size", 2);
    auto output_ = checked_tensor_unwrap(output,"output",2, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleSpatialUpSamplingNearest_updateOutput(globalContext().getTHCState(), self_, output_, output_size_[0], output_size_[1]);
    return output;
}
Tensor CPUDoubleType::upsample_nearest2d_forward(const Tensor & self, IntList output_size) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto output_size_ = check_intlist<2>(output_size, "output_size", 2);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    THNN_DoubleSpatialUpSamplingNearest_updateOutput(globalContext().getTHCState(), self_, output_, output_size_[0], output_size_[1]);
    return output;
}
Tensor & CPUDoubleType::upsample_nearest2d_backward_out(Tensor & grad_input, const Tensor & grad_output, IntList output_size, IntList input_size) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto output_size_ = check_intlist<2>(output_size, "output_size", 2);
    auto input_size_ = check_intlist<4>(input_size, "input_size", 3);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",3, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleSpatialUpSamplingNearest_updateGradInput(globalContext().getTHCState(), grad_output_, grad_input_, input_size_[0], input_size_[1], input_size_[2], input_size_[3], output_size_[0], output_size_[1]);
    grad_input_->maybe_zero_dim(false);
    return grad_input;
}
Tensor CPUDoubleType::upsample_nearest2d_backward(const Tensor & grad_output, IntList output_size, IntList input_size) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto output_size_ = check_intlist<2>(output_size, "output_size", 2);
    auto input_size_ = check_intlist<4>(input_size, "input_size", 3);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleSpatialUpSamplingNearest_updateGradInput(globalContext().getTHCState(), grad_output_, grad_input_, input_size_[0], input_size_[1], input_size_[2], input_size_[3], output_size_[0], output_size_[1]);
    grad_input_->maybe_zero_dim(false);
    return grad_input;
}
Tensor & CPUDoubleType::upsample_nearest3d_forward_out(Tensor & output, const Tensor & self, IntList output_size) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto output_size_ = check_intlist<3>(output_size, "output_size", 2);
    auto output_ = checked_tensor_unwrap(output,"output",2, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleVolumetricUpSamplingNearest_updateOutput(globalContext().getTHCState(), self_, output_, output_size_[0], output_size_[1], output_size_[2]);
    return output;
}
Tensor CPUDoubleType::upsample_nearest3d_forward(const Tensor & self, IntList output_size) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto output_size_ = check_intlist<3>(output_size, "output_size", 2);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    THNN_DoubleVolumetricUpSamplingNearest_updateOutput(globalContext().getTHCState(), self_, output_, output_size_[0], output_size_[1], output_size_[2]);
    return output;
}
Tensor & CPUDoubleType::upsample_nearest3d_backward_out(Tensor & grad_input, const Tensor & grad_output, IntList output_size, IntList input_size) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto output_size_ = check_intlist<3>(output_size, "output_size", 2);
    auto input_size_ = check_intlist<5>(input_size, "input_size", 3);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",3, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleVolumetricUpSamplingNearest_updateGradInput(globalContext().getTHCState(), grad_output_, grad_input_, input_size_[0], input_size_[1], input_size_[2], input_size_[3], input_size_[4], output_size_[0], output_size_[1], output_size_[2]);
    grad_input_->maybe_zero_dim(false);
    return grad_input;
}
Tensor CPUDoubleType::upsample_nearest3d_backward(const Tensor & grad_output, IntList output_size, IntList input_size) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto output_size_ = check_intlist<3>(output_size, "output_size", 2);
    auto input_size_ = check_intlist<5>(input_size, "input_size", 3);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleVolumetricUpSamplingNearest_updateGradInput(globalContext().getTHCState(), grad_output_, grad_input_, input_size_[0], input_size_[1], input_size_[2], input_size_[3], input_size_[4], output_size_[0], output_size_[1], output_size_[2]);
    grad_input_->maybe_zero_dim(false);
    return grad_input;
}
Tensor & CPUDoubleType::_sigmoid_forward_out(Tensor & output, const Tensor & self) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto output_ = checked_tensor_unwrap(output,"output",1, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleSigmoid_updateOutput(globalContext().getTHCState(), self_, output_);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor CPUDoubleType::_sigmoid_forward(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    THNN_DoubleSigmoid_updateOutput(globalContext().getTHCState(), self_, output_);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor & CPUDoubleType::_sigmoid_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & output) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto output_ = checked_tensor_unwrap(output,"output",2, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",2, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleSigmoid_updateGradInput(globalContext().getTHCState(), grad_output_, grad_input_, output_);
    grad_input_->maybe_zero_dim(output_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::_sigmoid_backward(const Tensor & grad_output, const Tensor & output) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto output_ = checked_tensor_unwrap(output,"output",2, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleSigmoid_updateGradInput(globalContext().getTHCState(), grad_output_, grad_input_, output_);
    grad_input_->maybe_zero_dim(output_->dim() == 0);
    return grad_input;
}
Tensor & CPUDoubleType::_tanh_forward_out(Tensor & output, const Tensor & self) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto output_ = checked_tensor_unwrap(output,"output",1, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleTanh_updateOutput(globalContext().getTHCState(), self_, output_);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor CPUDoubleType::_tanh_forward(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    THNN_DoubleTanh_updateOutput(globalContext().getTHCState(), self_, output_);
    output_->maybe_zero_dim(self_->dim() == 0);
    return output;
}
Tensor & CPUDoubleType::_tanh_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & output) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto output_ = checked_tensor_unwrap(output,"output",2, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",2, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleTanh_updateGradInput(globalContext().getTHCState(), grad_output_, grad_input_, output_);
    grad_input_->maybe_zero_dim(output_->dim() == 0);
    return grad_input;
}
Tensor CPUDoubleType::_tanh_backward(const Tensor & grad_output, const Tensor & output) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto output_ = checked_tensor_unwrap(output,"output",2, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
    THNN_DoubleTanh_updateGradInput(globalContext().getTHCState(), grad_output_, grad_input_, output_);
    grad_input_->maybe_zero_dim(output_->dim() == 0);
    return grad_input;
}
std::tuple<Tensor &,Tensor &,Tensor &> CPUDoubleType::thnn_conv_transpose2d_forward_out(Tensor & output, Tensor & columns, Tensor & ones, const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding, IntList output_padding, IntList dilation) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto weight_ = checked_tensor_unwrap(weight,"weight",2, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<2>(kernel_size, "kernel_size", 3);
    auto bias_ = checked_tensor_unwrap(bias,"bias",4, true, Backend::CPU, ScalarType::Double);
    auto stride_ = check_intlist<2>(stride, "stride", 5);
    auto padding_ = check_intlist<2>(padding, "padding", 6);
    auto output_padding_ = check_intlist<2>(output_padding, "output_padding", 7);
    auto dilation_ = check_intlist<2>(dilation, "dilation", 8);
    auto output_ = checked_tensor_unwrap(output,"output",8, false, Backend::CPU, ScalarType::Double);
    auto columns_ = checked_tensor_unwrap(columns,"columns",8, false, Backend::CPU, ScalarType::Double);
    auto ones_ = checked_tensor_unwrap(ones,"ones",8, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleSpatialFullDilatedConvolution_updateOutput(globalContext().getTHCState(), self_, output_, weight_, bias_ ? bias_ : NULL, columns_, ones_, kernel_size_[1], kernel_size_[0], stride_[1], stride_[0], padding_[1], padding_[0], dilation_[1], dilation_[0], output_padding_[1], output_padding_[0]);
    bool maybe_scalar = self_->dim() == 0 && weight_->dim() == 0 && (!bias_ || bias_->dim() == 0);
    output_->maybe_zero_dim(maybe_scalar);
    columns_->maybe_zero_dim(maybe_scalar);
    ones_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor &, Tensor &, Tensor &>(output, columns, ones);
}
std::tuple<Tensor,Tensor,Tensor> CPUDoubleType::thnn_conv_transpose2d_forward(const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding, IntList output_padding, IntList dilation) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto weight_ = checked_tensor_unwrap(weight,"weight",2, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<2>(kernel_size, "kernel_size", 3);
    auto bias_ = checked_tensor_unwrap(bias,"bias",4, true, Backend::CPU, ScalarType::Double);
    auto stride_ = check_intlist<2>(stride, "stride", 5);
    auto padding_ = check_intlist<2>(padding, "padding", 6);
    auto output_padding_ = check_intlist<2>(output_padding, "output_padding", 7);
    auto dilation_ = check_intlist<2>(dilation, "dilation", 8);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    auto columns_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto columns = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(columns_));
    auto ones_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto ones = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(ones_));
    THNN_DoubleSpatialFullDilatedConvolution_updateOutput(globalContext().getTHCState(), self_, output_, weight_, bias_ ? bias_ : NULL, columns_, ones_, kernel_size_[1], kernel_size_[0], stride_[1], stride_[0], padding_[1], padding_[0], dilation_[1], dilation_[0], output_padding_[1], output_padding_[0]);
    bool maybe_scalar = self_->dim() == 0 && weight_->dim() == 0 && (!bias_ || bias_->dim() == 0);
    output_->maybe_zero_dim(maybe_scalar);
    columns_->maybe_zero_dim(maybe_scalar);
    ones_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor, Tensor, Tensor>(output, columns, ones);
}
std::tuple<Tensor &,Tensor &,Tensor &> CPUDoubleType::thnn_conv_transpose2d_backward_out(Tensor & grad_input, Tensor & grad_weight, Tensor & grad_bias, const Tensor & grad_output, const Tensor & self, const Tensor & weight, IntList kernel_size, IntList stride, IntList padding, IntList output_padding, IntList dilation, const Tensor & columns, const Tensor & ones) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto weight_ = checked_tensor_unwrap(weight,"weight",3, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<2>(kernel_size, "kernel_size", 4);
    auto stride_ = check_intlist<2>(stride, "stride", 5);
    auto padding_ = check_intlist<2>(padding, "padding", 6);
    auto output_padding_ = check_intlist<2>(output_padding, "output_padding", 7);
    auto dilation_ = check_intlist<2>(dilation, "dilation", 8);
    auto columns_ = checked_tensor_unwrap(columns,"columns",9, false, Backend::CPU, ScalarType::Double);
    auto ones_ = checked_tensor_unwrap(ones,"ones",10, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",10, true, Backend::CPU, ScalarType::Double);
    auto grad_weight_ = checked_tensor_unwrap(grad_weight,"grad_weight",10, true, Backend::CPU, ScalarType::Double);
    if (grad_weight.defined()) {
        grad_weight.resize_(weight.sizes());
        grad_weight.zero_();
    }
    auto grad_bias_ = checked_tensor_unwrap(grad_bias,"grad_bias",10, true, Backend::CPU, ScalarType::Double);
    if (grad_bias.defined()) {
        grad_bias.resize_({ weight.size(1) });
        grad_bias.zero_();
    }
    if (grad_input_) THNN_DoubleSpatialFullDilatedConvolution_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_ ? grad_input_ : NULL, weight_, columns_, kernel_size_[1], kernel_size_[0], stride_[1], stride_[0], padding_[1], padding_[0], dilation_[1], dilation_[0], output_padding_[1], output_padding_[0]);
    if (grad_weight_ || grad_bias_) THNN_DoubleSpatialFullDilatedConvolution_accGradParameters(globalContext().getTHCState(), self_, grad_output_, grad_weight_ ? grad_weight_ : NULL, grad_bias_ ? grad_bias_ : NULL, columns_, ones_, kernel_size_[1], kernel_size_[0], stride_[1], stride_[0], padding_[1], padding_[0], dilation_[1], dilation_[0], output_padding_[1], output_padding_[0], 1);
    if (grad_input_) grad_input_->maybe_zero_dim(self_->dim() == 0);
    return std::tuple<Tensor &, Tensor &, Tensor &>(grad_input, grad_weight, grad_bias);
}
std::tuple<Tensor,Tensor,Tensor> CPUDoubleType::thnn_conv_transpose2d_backward(const Tensor & grad_output, const Tensor & self, const Tensor & weight, IntList kernel_size, IntList stride, IntList padding, IntList output_padding, IntList dilation, const Tensor & columns, const Tensor & ones, std::array<bool,3> output_mask) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto weight_ = checked_tensor_unwrap(weight,"weight",3, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<2>(kernel_size, "kernel_size", 4);
    auto stride_ = check_intlist<2>(stride, "stride", 5);
    auto padding_ = check_intlist<2>(padding, "padding", 6);
    auto output_padding_ = check_intlist<2>(output_padding, "output_padding", 7);
    auto dilation_ = check_intlist<2>(dilation, "dilation", 8);
    auto columns_ = checked_tensor_unwrap(columns,"columns",9, false, Backend::CPU, ScalarType::Double);
    auto ones_ = checked_tensor_unwrap(ones,"ones",10, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = output_mask[0] ? c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release() : nullptr;
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_ == nullptr ? (TensorImpl*)UndefinedTensorImpl::singleton() : (TensorImpl*)grad_input_));
    auto grad_weight_ = output_mask[1] ? c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release() : nullptr;
    auto grad_weight = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_weight_ == nullptr ? (TensorImpl*)UndefinedTensorImpl::singleton() : (TensorImpl*)grad_weight_));
    if (grad_weight.defined()) {
        grad_weight.resize_(weight.sizes());
        grad_weight.zero_();
    }
    auto grad_bias_ = output_mask[2] ? c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release() : nullptr;
    auto grad_bias = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_bias_ == nullptr ? (TensorImpl*)UndefinedTensorImpl::singleton() : (TensorImpl*)grad_bias_));
    if (grad_bias.defined()) {
        grad_bias.resize_({ weight.size(1) });
        grad_bias.zero_();
    }
    if (grad_input_) THNN_DoubleSpatialFullDilatedConvolution_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_ ? grad_input_ : NULL, weight_, columns_, kernel_size_[1], kernel_size_[0], stride_[1], stride_[0], padding_[1], padding_[0], dilation_[1], dilation_[0], output_padding_[1], output_padding_[0]);
    if (grad_weight_ || grad_bias_) THNN_DoubleSpatialFullDilatedConvolution_accGradParameters(globalContext().getTHCState(), self_, grad_output_, grad_weight_ ? grad_weight_ : NULL, grad_bias_ ? grad_bias_ : NULL, columns_, ones_, kernel_size_[1], kernel_size_[0], stride_[1], stride_[0], padding_[1], padding_[0], dilation_[1], dilation_[0], output_padding_[1], output_padding_[0], 1);
    if (grad_input_) grad_input_->maybe_zero_dim(self_->dim() == 0);
    return std::tuple<Tensor, Tensor, Tensor>(grad_input, grad_weight, grad_bias);
}
std::tuple<Tensor &,Tensor &,Tensor &> CPUDoubleType::thnn_conv_transpose3d_forward_out(Tensor & output, Tensor & finput, Tensor & fgrad_input, const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding, IntList output_padding, IntList dilation) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto weight_ = checked_tensor_unwrap(weight,"weight",2, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<3>(kernel_size, "kernel_size", 3);
    auto bias_ = checked_tensor_unwrap(bias,"bias",4, true, Backend::CPU, ScalarType::Double);
    auto stride_ = check_intlist<3>(stride, "stride", 5);
    auto padding_ = check_intlist<3>(padding, "padding", 6);
    auto output_padding_ = check_intlist<3>(output_padding, "output_padding", 7);
    auto dilation_ = check_intlist<3>(dilation, "dilation", 8);
    auto output_ = checked_tensor_unwrap(output,"output",8, false, Backend::CPU, ScalarType::Double);
    auto finput_ = checked_tensor_unwrap(finput,"finput",8, false, Backend::CPU, ScalarType::Double);
    auto fgrad_input_ = checked_tensor_unwrap(fgrad_input,"fgrad_input",8, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleVolumetricFullDilatedConvolution_updateOutput(globalContext().getTHCState(), self_, output_, weight_, bias_ ? bias_ : NULL, finput_, fgrad_input_, kernel_size_[0], kernel_size_[2], kernel_size_[1], stride_[0], stride_[2], stride_[1], padding_[0], padding_[2], padding_[1], dilation_[0], dilation_[2], dilation_[1], output_padding_[0], output_padding_[2], output_padding_[1]);
    bool maybe_scalar = self_->dim() == 0 && weight_->dim() == 0 && (!bias_ || bias_->dim() == 0);
    output_->maybe_zero_dim(maybe_scalar);
    finput_->maybe_zero_dim(maybe_scalar);
    fgrad_input_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor &, Tensor &, Tensor &>(output, finput, fgrad_input);
}
std::tuple<Tensor,Tensor,Tensor> CPUDoubleType::thnn_conv_transpose3d_forward(const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding, IntList output_padding, IntList dilation) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto weight_ = checked_tensor_unwrap(weight,"weight",2, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<3>(kernel_size, "kernel_size", 3);
    auto bias_ = checked_tensor_unwrap(bias,"bias",4, true, Backend::CPU, ScalarType::Double);
    auto stride_ = check_intlist<3>(stride, "stride", 5);
    auto padding_ = check_intlist<3>(padding, "padding", 6);
    auto output_padding_ = check_intlist<3>(output_padding, "output_padding", 7);
    auto dilation_ = check_intlist<3>(dilation, "dilation", 8);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    auto finput_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto finput = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(finput_));
    auto fgrad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto fgrad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(fgrad_input_));
    THNN_DoubleVolumetricFullDilatedConvolution_updateOutput(globalContext().getTHCState(), self_, output_, weight_, bias_ ? bias_ : NULL, finput_, fgrad_input_, kernel_size_[0], kernel_size_[2], kernel_size_[1], stride_[0], stride_[2], stride_[1], padding_[0], padding_[2], padding_[1], dilation_[0], dilation_[2], dilation_[1], output_padding_[0], output_padding_[2], output_padding_[1]);
    bool maybe_scalar = self_->dim() == 0 && weight_->dim() == 0 && (!bias_ || bias_->dim() == 0);
    output_->maybe_zero_dim(maybe_scalar);
    finput_->maybe_zero_dim(maybe_scalar);
    fgrad_input_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor, Tensor, Tensor>(output, finput, fgrad_input);
}
std::tuple<Tensor &,Tensor &,Tensor &> CPUDoubleType::thnn_conv_transpose3d_backward_out(Tensor & grad_input, Tensor & grad_weight, Tensor & grad_bias, const Tensor & grad_output, const Tensor & self, const Tensor & weight, IntList kernel_size, IntList stride, IntList padding, IntList output_padding, IntList dilation, const Tensor & finput, const Tensor & fgrad_input) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto weight_ = checked_tensor_unwrap(weight,"weight",3, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<3>(kernel_size, "kernel_size", 4);
    auto stride_ = check_intlist<3>(stride, "stride", 5);
    auto padding_ = check_intlist<3>(padding, "padding", 6);
    auto output_padding_ = check_intlist<3>(output_padding, "output_padding", 7);
    auto dilation_ = check_intlist<3>(dilation, "dilation", 8);
    auto finput_ = checked_tensor_unwrap(finput,"finput",9, false, Backend::CPU, ScalarType::Double);
    auto fgrad_input_ = checked_tensor_unwrap(fgrad_input,"fgrad_input",10, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",10, true, Backend::CPU, ScalarType::Double);
    auto grad_weight_ = checked_tensor_unwrap(grad_weight,"grad_weight",10, true, Backend::CPU, ScalarType::Double);
    if (grad_weight.defined()) {
        grad_weight.resize_(weight.sizes());
        grad_weight.zero_();
    }
    auto grad_bias_ = checked_tensor_unwrap(grad_bias,"grad_bias",10, true, Backend::CPU, ScalarType::Double);
    if (grad_bias.defined()) {
        grad_bias.resize_({ weight.size(1) });
        grad_bias.zero_();
    }
    if (grad_input_) THNN_DoubleVolumetricFullDilatedConvolution_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_ ? grad_input_ : NULL, weight_, finput_, fgrad_input_, kernel_size_[0], kernel_size_[2], kernel_size_[1], stride_[0], stride_[2], stride_[1], padding_[0], padding_[2], padding_[1], dilation_[0], dilation_[2], dilation_[1], output_padding_[0], output_padding_[2], output_padding_[1]);
    if (grad_weight_ || grad_bias_) THNN_DoubleVolumetricFullDilatedConvolution_accGradParameters(globalContext().getTHCState(), self_, grad_output_, grad_weight_ ? grad_weight_ : NULL, grad_bias_ ? grad_bias_ : NULL, finput_, fgrad_input_, kernel_size_[0], kernel_size_[2], kernel_size_[1], stride_[0], stride_[2], stride_[1], padding_[0], padding_[2], padding_[1], dilation_[0], dilation_[2], dilation_[1], output_padding_[0], output_padding_[2], output_padding_[1], 1);
    if (grad_input_) grad_input_->maybe_zero_dim(self_->dim() == 0);
    return std::tuple<Tensor &, Tensor &, Tensor &>(grad_input, grad_weight, grad_bias);
}
std::tuple<Tensor,Tensor,Tensor> CPUDoubleType::thnn_conv_transpose3d_backward(const Tensor & grad_output, const Tensor & self, const Tensor & weight, IntList kernel_size, IntList stride, IntList padding, IntList output_padding, IntList dilation, const Tensor & finput, const Tensor & fgrad_input, std::array<bool,3> output_mask) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto weight_ = checked_tensor_unwrap(weight,"weight",3, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<3>(kernel_size, "kernel_size", 4);
    auto stride_ = check_intlist<3>(stride, "stride", 5);
    auto padding_ = check_intlist<3>(padding, "padding", 6);
    auto output_padding_ = check_intlist<3>(output_padding, "output_padding", 7);
    auto dilation_ = check_intlist<3>(dilation, "dilation", 8);
    auto finput_ = checked_tensor_unwrap(finput,"finput",9, false, Backend::CPU, ScalarType::Double);
    auto fgrad_input_ = checked_tensor_unwrap(fgrad_input,"fgrad_input",10, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = output_mask[0] ? c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release() : nullptr;
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_ == nullptr ? (TensorImpl*)UndefinedTensorImpl::singleton() : (TensorImpl*)grad_input_));
    auto grad_weight_ = output_mask[1] ? c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release() : nullptr;
    auto grad_weight = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_weight_ == nullptr ? (TensorImpl*)UndefinedTensorImpl::singleton() : (TensorImpl*)grad_weight_));
    if (grad_weight.defined()) {
        grad_weight.resize_(weight.sizes());
        grad_weight.zero_();
    }
    auto grad_bias_ = output_mask[2] ? c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release() : nullptr;
    auto grad_bias = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_bias_ == nullptr ? (TensorImpl*)UndefinedTensorImpl::singleton() : (TensorImpl*)grad_bias_));
    if (grad_bias.defined()) {
        grad_bias.resize_({ weight.size(1) });
        grad_bias.zero_();
    }
    if (grad_input_) THNN_DoubleVolumetricFullDilatedConvolution_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_ ? grad_input_ : NULL, weight_, finput_, fgrad_input_, kernel_size_[0], kernel_size_[2], kernel_size_[1], stride_[0], stride_[2], stride_[1], padding_[0], padding_[2], padding_[1], dilation_[0], dilation_[2], dilation_[1], output_padding_[0], output_padding_[2], output_padding_[1]);
    if (grad_weight_ || grad_bias_) THNN_DoubleVolumetricFullDilatedConvolution_accGradParameters(globalContext().getTHCState(), self_, grad_output_, grad_weight_ ? grad_weight_ : NULL, grad_bias_ ? grad_bias_ : NULL, finput_, fgrad_input_, kernel_size_[0], kernel_size_[2], kernel_size_[1], stride_[0], stride_[2], stride_[1], padding_[0], padding_[2], padding_[1], dilation_[0], dilation_[2], dilation_[1], output_padding_[0], output_padding_[2], output_padding_[1], 1);
    if (grad_input_) grad_input_->maybe_zero_dim(self_->dim() == 0);
    return std::tuple<Tensor, Tensor, Tensor>(grad_input, grad_weight, grad_bias);
}
std::tuple<Tensor &,Tensor &,Tensor &> CPUDoubleType::thnn_conv2d_forward_out(Tensor & output, Tensor & finput, Tensor & fgrad_input, const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto weight_ = checked_tensor_unwrap(weight,"weight",2, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<2>(kernel_size, "kernel_size", 3);
    auto bias_ = checked_tensor_unwrap(bias,"bias",4, true, Backend::CPU, ScalarType::Double);
    auto stride_ = check_intlist<2>(stride, "stride", 5);
    auto padding_ = check_intlist<2>(padding, "padding", 6);
    auto output_ = checked_tensor_unwrap(output,"output",6, false, Backend::CPU, ScalarType::Double);
    auto finput_ = checked_tensor_unwrap(finput,"finput",6, false, Backend::CPU, ScalarType::Double);
    auto fgrad_input_ = checked_tensor_unwrap(fgrad_input,"fgrad_input",6, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleSpatialConvolutionMM_updateOutput(globalContext().getTHCState(), self_, output_, weight_, bias_ ? bias_ : NULL, finput_, fgrad_input_, kernel_size_[1], kernel_size_[0], stride_[1], stride_[0], padding_[1], padding_[0]);
    bool maybe_scalar = self_->dim() == 0 && weight_->dim() == 0 && (!bias_ || bias_->dim() == 0);
    output_->maybe_zero_dim(maybe_scalar);
    finput_->maybe_zero_dim(maybe_scalar);
    fgrad_input_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor &, Tensor &, Tensor &>(output, finput, fgrad_input);
}
std::tuple<Tensor,Tensor,Tensor> CPUDoubleType::thnn_conv2d_forward(const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto weight_ = checked_tensor_unwrap(weight,"weight",2, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<2>(kernel_size, "kernel_size", 3);
    auto bias_ = checked_tensor_unwrap(bias,"bias",4, true, Backend::CPU, ScalarType::Double);
    auto stride_ = check_intlist<2>(stride, "stride", 5);
    auto padding_ = check_intlist<2>(padding, "padding", 6);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    auto finput_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto finput = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(finput_));
    auto fgrad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto fgrad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(fgrad_input_));
    THNN_DoubleSpatialConvolutionMM_updateOutput(globalContext().getTHCState(), self_, output_, weight_, bias_ ? bias_ : NULL, finput_, fgrad_input_, kernel_size_[1], kernel_size_[0], stride_[1], stride_[0], padding_[1], padding_[0]);
    bool maybe_scalar = self_->dim() == 0 && weight_->dim() == 0 && (!bias_ || bias_->dim() == 0);
    output_->maybe_zero_dim(maybe_scalar);
    finput_->maybe_zero_dim(maybe_scalar);
    fgrad_input_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor, Tensor, Tensor>(output, finput, fgrad_input);
}
std::tuple<Tensor &,Tensor &,Tensor &> CPUDoubleType::thnn_conv2d_backward_out(Tensor & grad_input, Tensor & grad_weight, Tensor & grad_bias, const Tensor & grad_output, const Tensor & self, const Tensor & weight, IntList kernel_size, IntList stride, IntList padding, const Tensor & finput, const Tensor & fgrad_input) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto weight_ = checked_tensor_unwrap(weight,"weight",3, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<2>(kernel_size, "kernel_size", 4);
    auto stride_ = check_intlist<2>(stride, "stride", 5);
    auto padding_ = check_intlist<2>(padding, "padding", 6);
    auto finput_ = checked_tensor_unwrap(finput,"finput",7, false, Backend::CPU, ScalarType::Double);
    auto fgrad_input_ = checked_tensor_unwrap(fgrad_input,"fgrad_input",8, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",8, true, Backend::CPU, ScalarType::Double);
    auto grad_weight_ = checked_tensor_unwrap(grad_weight,"grad_weight",8, true, Backend::CPU, ScalarType::Double);
    if (grad_weight.defined()) {
        grad_weight.resize_(weight.sizes());
        grad_weight.zero_();
    }
    auto grad_bias_ = checked_tensor_unwrap(grad_bias,"grad_bias",8, true, Backend::CPU, ScalarType::Double);
    if (grad_bias.defined()) {
        grad_bias.resize_({ weight.size(0) });
        grad_bias.zero_();
    }
    if (grad_input_) THNN_DoubleSpatialConvolutionMM_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_ ? grad_input_ : NULL, weight_, finput_, fgrad_input_, kernel_size_[1], kernel_size_[0], stride_[1], stride_[0], padding_[1], padding_[0]);
    if (grad_weight_ || grad_bias_) THNN_DoubleSpatialConvolutionMM_accGradParameters(globalContext().getTHCState(), self_, grad_output_, grad_weight_ ? grad_weight_ : NULL, grad_bias_ ? grad_bias_ : NULL, finput_, fgrad_input_, kernel_size_[1], kernel_size_[0], stride_[1], stride_[0], padding_[1], padding_[0], 1);
    if (grad_input_) grad_input_->maybe_zero_dim(self_->dim() == 0);
    return std::tuple<Tensor &, Tensor &, Tensor &>(grad_input, grad_weight, grad_bias);
}
std::tuple<Tensor,Tensor,Tensor> CPUDoubleType::thnn_conv2d_backward(const Tensor & grad_output, const Tensor & self, const Tensor & weight, IntList kernel_size, IntList stride, IntList padding, const Tensor & finput, const Tensor & fgrad_input, std::array<bool,3> output_mask) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto weight_ = checked_tensor_unwrap(weight,"weight",3, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<2>(kernel_size, "kernel_size", 4);
    auto stride_ = check_intlist<2>(stride, "stride", 5);
    auto padding_ = check_intlist<2>(padding, "padding", 6);
    auto finput_ = checked_tensor_unwrap(finput,"finput",7, false, Backend::CPU, ScalarType::Double);
    auto fgrad_input_ = checked_tensor_unwrap(fgrad_input,"fgrad_input",8, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = output_mask[0] ? c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release() : nullptr;
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_ == nullptr ? (TensorImpl*)UndefinedTensorImpl::singleton() : (TensorImpl*)grad_input_));
    auto grad_weight_ = output_mask[1] ? c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release() : nullptr;
    auto grad_weight = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_weight_ == nullptr ? (TensorImpl*)UndefinedTensorImpl::singleton() : (TensorImpl*)grad_weight_));
    if (grad_weight.defined()) {
        grad_weight.resize_(weight.sizes());
        grad_weight.zero_();
    }
    auto grad_bias_ = output_mask[2] ? c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release() : nullptr;
    auto grad_bias = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_bias_ == nullptr ? (TensorImpl*)UndefinedTensorImpl::singleton() : (TensorImpl*)grad_bias_));
    if (grad_bias.defined()) {
        grad_bias.resize_({ weight.size(0) });
        grad_bias.zero_();
    }
    if (grad_input_) THNN_DoubleSpatialConvolutionMM_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_ ? grad_input_ : NULL, weight_, finput_, fgrad_input_, kernel_size_[1], kernel_size_[0], stride_[1], stride_[0], padding_[1], padding_[0]);
    if (grad_weight_ || grad_bias_) THNN_DoubleSpatialConvolutionMM_accGradParameters(globalContext().getTHCState(), self_, grad_output_, grad_weight_ ? grad_weight_ : NULL, grad_bias_ ? grad_bias_ : NULL, finput_, fgrad_input_, kernel_size_[1], kernel_size_[0], stride_[1], stride_[0], padding_[1], padding_[0], 1);
    if (grad_input_) grad_input_->maybe_zero_dim(self_->dim() == 0);
    return std::tuple<Tensor, Tensor, Tensor>(grad_input, grad_weight, grad_bias);
}
std::tuple<Tensor &,Tensor &,Tensor &> CPUDoubleType::thnn_conv3d_forward_out(Tensor & output, Tensor & finput, Tensor & fgrad_input, const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto weight_ = checked_tensor_unwrap(weight,"weight",2, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<3>(kernel_size, "kernel_size", 3);
    auto bias_ = checked_tensor_unwrap(bias,"bias",4, true, Backend::CPU, ScalarType::Double);
    auto stride_ = check_intlist<3>(stride, "stride", 5);
    auto padding_ = check_intlist<3>(padding, "padding", 6);
    auto output_ = checked_tensor_unwrap(output,"output",6, false, Backend::CPU, ScalarType::Double);
    auto finput_ = checked_tensor_unwrap(finput,"finput",6, false, Backend::CPU, ScalarType::Double);
    auto fgrad_input_ = checked_tensor_unwrap(fgrad_input,"fgrad_input",6, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleVolumetricConvolutionMM_updateOutput(globalContext().getTHCState(), self_, output_, weight_, bias_ ? bias_ : NULL, finput_, fgrad_input_, kernel_size_[0], kernel_size_[2], kernel_size_[1], stride_[0], stride_[2], stride_[1], padding_[0], padding_[2], padding_[1]);
    bool maybe_scalar = self_->dim() == 0 && weight_->dim() == 0 && (!bias_ || bias_->dim() == 0);
    output_->maybe_zero_dim(maybe_scalar);
    finput_->maybe_zero_dim(maybe_scalar);
    fgrad_input_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor &, Tensor &, Tensor &>(output, finput, fgrad_input);
}
std::tuple<Tensor,Tensor,Tensor> CPUDoubleType::thnn_conv3d_forward(const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto weight_ = checked_tensor_unwrap(weight,"weight",2, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<3>(kernel_size, "kernel_size", 3);
    auto bias_ = checked_tensor_unwrap(bias,"bias",4, true, Backend::CPU, ScalarType::Double);
    auto stride_ = check_intlist<3>(stride, "stride", 5);
    auto padding_ = check_intlist<3>(padding, "padding", 6);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    auto finput_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto finput = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(finput_));
    auto fgrad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto fgrad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(fgrad_input_));
    THNN_DoubleVolumetricConvolutionMM_updateOutput(globalContext().getTHCState(), self_, output_, weight_, bias_ ? bias_ : NULL, finput_, fgrad_input_, kernel_size_[0], kernel_size_[2], kernel_size_[1], stride_[0], stride_[2], stride_[1], padding_[0], padding_[2], padding_[1]);
    bool maybe_scalar = self_->dim() == 0 && weight_->dim() == 0 && (!bias_ || bias_->dim() == 0);
    output_->maybe_zero_dim(maybe_scalar);
    finput_->maybe_zero_dim(maybe_scalar);
    fgrad_input_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor, Tensor, Tensor>(output, finput, fgrad_input);
}
std::tuple<Tensor &,Tensor &,Tensor &> CPUDoubleType::thnn_conv3d_backward_out(Tensor & grad_input, Tensor & grad_weight, Tensor & grad_bias, const Tensor & grad_output, const Tensor & self, const Tensor & weight, IntList kernel_size, IntList stride, IntList padding, const Tensor & finput, const Tensor & fgrad_input) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto weight_ = checked_tensor_unwrap(weight,"weight",3, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<3>(kernel_size, "kernel_size", 4);
    auto stride_ = check_intlist<3>(stride, "stride", 5);
    auto padding_ = check_intlist<3>(padding, "padding", 6);
    auto finput_ = checked_tensor_unwrap(finput,"finput",7, false, Backend::CPU, ScalarType::Double);
    auto fgrad_input_ = checked_tensor_unwrap(fgrad_input,"fgrad_input",8, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",8, true, Backend::CPU, ScalarType::Double);
    auto grad_weight_ = checked_tensor_unwrap(grad_weight,"grad_weight",8, true, Backend::CPU, ScalarType::Double);
    if (grad_weight.defined()) {
        grad_weight.resize_(weight.sizes());
        grad_weight.zero_();
    }
    auto grad_bias_ = checked_tensor_unwrap(grad_bias,"grad_bias",8, true, Backend::CPU, ScalarType::Double);
    if (grad_bias.defined()) {
        grad_bias.resize_({ weight.size(0) });
        grad_bias.zero_();
    }
    if (grad_input_) THNN_DoubleVolumetricConvolutionMM_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_ ? grad_input_ : NULL, weight_, finput_, fgrad_input_, kernel_size_[0], kernel_size_[2], kernel_size_[1], stride_[0], stride_[2], stride_[1], padding_[0], padding_[2], padding_[1]);
    if (grad_weight_ || grad_bias_) THNN_DoubleVolumetricConvolutionMM_accGradParameters(globalContext().getTHCState(), self_, grad_output_, grad_weight_ ? grad_weight_ : NULL, grad_bias_ ? grad_bias_ : NULL, finput_, fgrad_input_, kernel_size_[0], kernel_size_[2], kernel_size_[1], stride_[0], stride_[2], stride_[1], padding_[0], padding_[2], padding_[1], 1);
    if (grad_input_) grad_input_->maybe_zero_dim(self_->dim() == 0);
    return std::tuple<Tensor &, Tensor &, Tensor &>(grad_input, grad_weight, grad_bias);
}
std::tuple<Tensor,Tensor,Tensor> CPUDoubleType::thnn_conv3d_backward(const Tensor & grad_output, const Tensor & self, const Tensor & weight, IntList kernel_size, IntList stride, IntList padding, const Tensor & finput, const Tensor & fgrad_input, std::array<bool,3> output_mask) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto weight_ = checked_tensor_unwrap(weight,"weight",3, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<3>(kernel_size, "kernel_size", 4);
    auto stride_ = check_intlist<3>(stride, "stride", 5);
    auto padding_ = check_intlist<3>(padding, "padding", 6);
    auto finput_ = checked_tensor_unwrap(finput,"finput",7, false, Backend::CPU, ScalarType::Double);
    auto fgrad_input_ = checked_tensor_unwrap(fgrad_input,"fgrad_input",8, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = output_mask[0] ? c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release() : nullptr;
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_ == nullptr ? (TensorImpl*)UndefinedTensorImpl::singleton() : (TensorImpl*)grad_input_));
    auto grad_weight_ = output_mask[1] ? c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release() : nullptr;
    auto grad_weight = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_weight_ == nullptr ? (TensorImpl*)UndefinedTensorImpl::singleton() : (TensorImpl*)grad_weight_));
    if (grad_weight.defined()) {
        grad_weight.resize_(weight.sizes());
        grad_weight.zero_();
    }
    auto grad_bias_ = output_mask[2] ? c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release() : nullptr;
    auto grad_bias = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_bias_ == nullptr ? (TensorImpl*)UndefinedTensorImpl::singleton() : (TensorImpl*)grad_bias_));
    if (grad_bias.defined()) {
        grad_bias.resize_({ weight.size(0) });
        grad_bias.zero_();
    }
    if (grad_input_) THNN_DoubleVolumetricConvolutionMM_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_ ? grad_input_ : NULL, weight_, finput_, fgrad_input_, kernel_size_[0], kernel_size_[2], kernel_size_[1], stride_[0], stride_[2], stride_[1], padding_[0], padding_[2], padding_[1]);
    if (grad_weight_ || grad_bias_) THNN_DoubleVolumetricConvolutionMM_accGradParameters(globalContext().getTHCState(), self_, grad_output_, grad_weight_ ? grad_weight_ : NULL, grad_bias_ ? grad_bias_ : NULL, finput_, fgrad_input_, kernel_size_[0], kernel_size_[2], kernel_size_[1], stride_[0], stride_[2], stride_[1], padding_[0], padding_[2], padding_[1], 1);
    if (grad_input_) grad_input_->maybe_zero_dim(self_->dim() == 0);
    return std::tuple<Tensor, Tensor, Tensor>(grad_input, grad_weight, grad_bias);
}
std::tuple<Tensor &,Tensor &,Tensor &> CPUDoubleType::thnn_conv_dilated2d_forward_out(Tensor & output, Tensor & columns, Tensor & ones, const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding, IntList dilation) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto weight_ = checked_tensor_unwrap(weight,"weight",2, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<2>(kernel_size, "kernel_size", 3);
    auto bias_ = checked_tensor_unwrap(bias,"bias",4, true, Backend::CPU, ScalarType::Double);
    auto stride_ = check_intlist<2>(stride, "stride", 5);
    auto padding_ = check_intlist<2>(padding, "padding", 6);
    auto dilation_ = check_intlist<2>(dilation, "dilation", 7);
    auto output_ = checked_tensor_unwrap(output,"output",7, false, Backend::CPU, ScalarType::Double);
    auto columns_ = checked_tensor_unwrap(columns,"columns",7, false, Backend::CPU, ScalarType::Double);
    auto ones_ = checked_tensor_unwrap(ones,"ones",7, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleSpatialDilatedConvolution_updateOutput(globalContext().getTHCState(), self_, output_, weight_, bias_ ? bias_ : NULL, columns_, ones_, kernel_size_[1], kernel_size_[0], stride_[1], stride_[0], padding_[1], padding_[0], dilation_[1], dilation_[0]);
    bool maybe_scalar = self_->dim() == 0 && weight_->dim() == 0 && (!bias_ || bias_->dim() == 0);
    output_->maybe_zero_dim(maybe_scalar);
    columns_->maybe_zero_dim(maybe_scalar);
    ones_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor &, Tensor &, Tensor &>(output, columns, ones);
}
std::tuple<Tensor,Tensor,Tensor> CPUDoubleType::thnn_conv_dilated2d_forward(const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding, IntList dilation) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto weight_ = checked_tensor_unwrap(weight,"weight",2, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<2>(kernel_size, "kernel_size", 3);
    auto bias_ = checked_tensor_unwrap(bias,"bias",4, true, Backend::CPU, ScalarType::Double);
    auto stride_ = check_intlist<2>(stride, "stride", 5);
    auto padding_ = check_intlist<2>(padding, "padding", 6);
    auto dilation_ = check_intlist<2>(dilation, "dilation", 7);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    auto columns_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto columns = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(columns_));
    auto ones_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto ones = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(ones_));
    THNN_DoubleSpatialDilatedConvolution_updateOutput(globalContext().getTHCState(), self_, output_, weight_, bias_ ? bias_ : NULL, columns_, ones_, kernel_size_[1], kernel_size_[0], stride_[1], stride_[0], padding_[1], padding_[0], dilation_[1], dilation_[0]);
    bool maybe_scalar = self_->dim() == 0 && weight_->dim() == 0 && (!bias_ || bias_->dim() == 0);
    output_->maybe_zero_dim(maybe_scalar);
    columns_->maybe_zero_dim(maybe_scalar);
    ones_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor, Tensor, Tensor>(output, columns, ones);
}
std::tuple<Tensor &,Tensor &,Tensor &> CPUDoubleType::thnn_conv_dilated2d_backward_out(Tensor & grad_input, Tensor & grad_weight, Tensor & grad_bias, const Tensor & grad_output, const Tensor & self, const Tensor & weight, IntList kernel_size, IntList stride, IntList padding, IntList dilation, const Tensor & columns, const Tensor & ones) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto weight_ = checked_tensor_unwrap(weight,"weight",3, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<2>(kernel_size, "kernel_size", 4);
    auto stride_ = check_intlist<2>(stride, "stride", 5);
    auto padding_ = check_intlist<2>(padding, "padding", 6);
    auto dilation_ = check_intlist<2>(dilation, "dilation", 7);
    auto columns_ = checked_tensor_unwrap(columns,"columns",8, false, Backend::CPU, ScalarType::Double);
    auto ones_ = checked_tensor_unwrap(ones,"ones",9, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",9, true, Backend::CPU, ScalarType::Double);
    auto grad_weight_ = checked_tensor_unwrap(grad_weight,"grad_weight",9, true, Backend::CPU, ScalarType::Double);
    if (grad_weight.defined()) {
        grad_weight.resize_(weight.sizes());
        grad_weight.zero_();
    }
    auto grad_bias_ = checked_tensor_unwrap(grad_bias,"grad_bias",9, true, Backend::CPU, ScalarType::Double);
    if (grad_bias.defined()) {
        grad_bias.resize_({ weight.size(0) });
        grad_bias.zero_();
    }
    if (grad_input_) THNN_DoubleSpatialDilatedConvolution_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_ ? grad_input_ : NULL, weight_, columns_, kernel_size_[1], kernel_size_[0], stride_[1], stride_[0], padding_[1], padding_[0], dilation_[1], dilation_[0]);
    if (grad_weight_ || grad_bias_) THNN_DoubleSpatialDilatedConvolution_accGradParameters(globalContext().getTHCState(), self_, grad_output_, grad_weight_ ? grad_weight_ : NULL, grad_bias_ ? grad_bias_ : NULL, columns_, ones_, kernel_size_[1], kernel_size_[0], stride_[1], stride_[0], padding_[1], padding_[0], dilation_[1], dilation_[0], 1);
    if (grad_input_) grad_input_->maybe_zero_dim(self_->dim() == 0);
    return std::tuple<Tensor &, Tensor &, Tensor &>(grad_input, grad_weight, grad_bias);
}
std::tuple<Tensor,Tensor,Tensor> CPUDoubleType::thnn_conv_dilated2d_backward(const Tensor & grad_output, const Tensor & self, const Tensor & weight, IntList kernel_size, IntList stride, IntList padding, IntList dilation, const Tensor & columns, const Tensor & ones, std::array<bool,3> output_mask) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto weight_ = checked_tensor_unwrap(weight,"weight",3, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<2>(kernel_size, "kernel_size", 4);
    auto stride_ = check_intlist<2>(stride, "stride", 5);
    auto padding_ = check_intlist<2>(padding, "padding", 6);
    auto dilation_ = check_intlist<2>(dilation, "dilation", 7);
    auto columns_ = checked_tensor_unwrap(columns,"columns",8, false, Backend::CPU, ScalarType::Double);
    auto ones_ = checked_tensor_unwrap(ones,"ones",9, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = output_mask[0] ? c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release() : nullptr;
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_ == nullptr ? (TensorImpl*)UndefinedTensorImpl::singleton() : (TensorImpl*)grad_input_));
    auto grad_weight_ = output_mask[1] ? c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release() : nullptr;
    auto grad_weight = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_weight_ == nullptr ? (TensorImpl*)UndefinedTensorImpl::singleton() : (TensorImpl*)grad_weight_));
    if (grad_weight.defined()) {
        grad_weight.resize_(weight.sizes());
        grad_weight.zero_();
    }
    auto grad_bias_ = output_mask[2] ? c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release() : nullptr;
    auto grad_bias = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_bias_ == nullptr ? (TensorImpl*)UndefinedTensorImpl::singleton() : (TensorImpl*)grad_bias_));
    if (grad_bias.defined()) {
        grad_bias.resize_({ weight.size(0) });
        grad_bias.zero_();
    }
    if (grad_input_) THNN_DoubleSpatialDilatedConvolution_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_ ? grad_input_ : NULL, weight_, columns_, kernel_size_[1], kernel_size_[0], stride_[1], stride_[0], padding_[1], padding_[0], dilation_[1], dilation_[0]);
    if (grad_weight_ || grad_bias_) THNN_DoubleSpatialDilatedConvolution_accGradParameters(globalContext().getTHCState(), self_, grad_output_, grad_weight_ ? grad_weight_ : NULL, grad_bias_ ? grad_bias_ : NULL, columns_, ones_, kernel_size_[1], kernel_size_[0], stride_[1], stride_[0], padding_[1], padding_[0], dilation_[1], dilation_[0], 1);
    if (grad_input_) grad_input_->maybe_zero_dim(self_->dim() == 0);
    return std::tuple<Tensor, Tensor, Tensor>(grad_input, grad_weight, grad_bias);
}
std::tuple<Tensor &,Tensor &,Tensor &> CPUDoubleType::thnn_conv_dilated3d_forward_out(Tensor & output, Tensor & columns, Tensor & ones, const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding, IntList dilation) const {
    const DeviceGuard device_guard(output);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto weight_ = checked_tensor_unwrap(weight,"weight",2, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<3>(kernel_size, "kernel_size", 3);
    auto bias_ = checked_tensor_unwrap(bias,"bias",4, true, Backend::CPU, ScalarType::Double);
    auto stride_ = check_intlist<3>(stride, "stride", 5);
    auto padding_ = check_intlist<3>(padding, "padding", 6);
    auto dilation_ = check_intlist<3>(dilation, "dilation", 7);
    auto output_ = checked_tensor_unwrap(output,"output",7, false, Backend::CPU, ScalarType::Double);
    auto columns_ = checked_tensor_unwrap(columns,"columns",7, false, Backend::CPU, ScalarType::Double);
    auto ones_ = checked_tensor_unwrap(ones,"ones",7, false, Backend::CPU, ScalarType::Double);
    THNN_DoubleVolumetricDilatedConvolution_updateOutput(globalContext().getTHCState(), self_, output_, weight_, bias_ ? bias_ : NULL, columns_, ones_, kernel_size_[0], kernel_size_[2], kernel_size_[1], stride_[0], stride_[2], stride_[1], padding_[0], padding_[2], padding_[1], dilation_[0], dilation_[2], dilation_[1]);
    bool maybe_scalar = self_->dim() == 0 && weight_->dim() == 0 && (!bias_ || bias_->dim() == 0);
    output_->maybe_zero_dim(maybe_scalar);
    columns_->maybe_zero_dim(maybe_scalar);
    ones_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor &, Tensor &, Tensor &>(output, columns, ones);
}
std::tuple<Tensor,Tensor,Tensor> CPUDoubleType::thnn_conv_dilated3d_forward(const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding, IntList dilation) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Double);
    auto weight_ = checked_tensor_unwrap(weight,"weight",2, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<3>(kernel_size, "kernel_size", 3);
    auto bias_ = checked_tensor_unwrap(bias,"bias",4, true, Backend::CPU, ScalarType::Double);
    auto stride_ = check_intlist<3>(stride, "stride", 5);
    auto padding_ = check_intlist<3>(padding, "padding", 6);
    auto dilation_ = check_intlist<3>(dilation, "dilation", 7);
    auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
    auto columns_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto columns = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(columns_));
    auto ones_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release();
    auto ones = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(ones_));
    THNN_DoubleVolumetricDilatedConvolution_updateOutput(globalContext().getTHCState(), self_, output_, weight_, bias_ ? bias_ : NULL, columns_, ones_, kernel_size_[0], kernel_size_[2], kernel_size_[1], stride_[0], stride_[2], stride_[1], padding_[0], padding_[2], padding_[1], dilation_[0], dilation_[2], dilation_[1]);
    bool maybe_scalar = self_->dim() == 0 && weight_->dim() == 0 && (!bias_ || bias_->dim() == 0);
    output_->maybe_zero_dim(maybe_scalar);
    columns_->maybe_zero_dim(maybe_scalar);
    ones_->maybe_zero_dim(maybe_scalar);
    return std::tuple<Tensor, Tensor, Tensor>(output, columns, ones);
}
std::tuple<Tensor &,Tensor &,Tensor &> CPUDoubleType::thnn_conv_dilated3d_backward_out(Tensor & grad_input, Tensor & grad_weight, Tensor & grad_bias, const Tensor & grad_output, const Tensor & self, const Tensor & weight, IntList kernel_size, IntList stride, IntList padding, IntList dilation, const Tensor & columns, const Tensor & ones) const {
    const DeviceGuard device_guard(grad_input);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto weight_ = checked_tensor_unwrap(weight,"weight",3, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<3>(kernel_size, "kernel_size", 4);
    auto stride_ = check_intlist<3>(stride, "stride", 5);
    auto padding_ = check_intlist<3>(padding, "padding", 6);
    auto dilation_ = check_intlist<3>(dilation, "dilation", 7);
    auto columns_ = checked_tensor_unwrap(columns,"columns",8, false, Backend::CPU, ScalarType::Double);
    auto ones_ = checked_tensor_unwrap(ones,"ones",9, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = checked_tensor_unwrap(grad_input,"grad_input",9, true, Backend::CPU, ScalarType::Double);
    auto grad_weight_ = checked_tensor_unwrap(grad_weight,"grad_weight",9, true, Backend::CPU, ScalarType::Double);
    if (grad_weight.defined()) {
        grad_weight.resize_(weight.sizes());
        grad_weight.zero_();
    }
    auto grad_bias_ = checked_tensor_unwrap(grad_bias,"grad_bias",9, true, Backend::CPU, ScalarType::Double);
    if (grad_bias.defined()) {
        grad_bias.resize_({ weight.size(0) });
        grad_bias.zero_();
    }
    if (grad_input_) THNN_DoubleVolumetricDilatedConvolution_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_ ? grad_input_ : NULL, weight_, columns_, kernel_size_[0], kernel_size_[2], kernel_size_[1], stride_[0], stride_[2], stride_[1], padding_[0], padding_[2], padding_[1], dilation_[0], dilation_[2], dilation_[1]);
    if (grad_weight_ || grad_bias_) THNN_DoubleVolumetricDilatedConvolution_accGradParameters(globalContext().getTHCState(), self_, grad_output_, grad_weight_ ? grad_weight_ : NULL, grad_bias_ ? grad_bias_ : NULL, columns_, ones_, kernel_size_[0], kernel_size_[2], kernel_size_[1], stride_[0], stride_[2], stride_[1], padding_[0], padding_[2], padding_[1], dilation_[0], dilation_[2], dilation_[1], 1);
    if (grad_input_) grad_input_->maybe_zero_dim(self_->dim() == 0);
    return std::tuple<Tensor &, Tensor &, Tensor &>(grad_input, grad_weight, grad_bias);
}
std::tuple<Tensor,Tensor,Tensor> CPUDoubleType::thnn_conv_dilated3d_backward(const Tensor & grad_output, const Tensor & self, const Tensor & weight, IntList kernel_size, IntList stride, IntList padding, IntList dilation, const Tensor & columns, const Tensor & ones, std::array<bool,3> output_mask) const {
    const DeviceGuard device_guard(grad_output);
    auto grad_output_ = checked_tensor_unwrap(grad_output,"grad_output",1, false, Backend::CPU, ScalarType::Double);
    auto self_ = checked_tensor_unwrap(self,"self",2, false, Backend::CPU, ScalarType::Double);
    auto weight_ = checked_tensor_unwrap(weight,"weight",3, false, Backend::CPU, ScalarType::Double);
    auto kernel_size_ = check_intlist<3>(kernel_size, "kernel_size", 4);
    auto stride_ = check_intlist<3>(stride, "stride", 5);
    auto padding_ = check_intlist<3>(padding, "padding", 6);
    auto dilation_ = check_intlist<3>(dilation, "dilation", 7);
    auto columns_ = checked_tensor_unwrap(columns,"columns",8, false, Backend::CPU, ScalarType::Double);
    auto ones_ = checked_tensor_unwrap(ones,"ones",9, false, Backend::CPU, ScalarType::Double);
    auto grad_input_ = output_mask[0] ? c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release() : nullptr;
    auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_ == nullptr ? (TensorImpl*)UndefinedTensorImpl::singleton() : (TensorImpl*)grad_input_));
    auto grad_weight_ = output_mask[1] ? c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release() : nullptr;
    auto grad_weight = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_weight_ == nullptr ? (TensorImpl*)UndefinedTensorImpl::singleton() : (TensorImpl*)grad_weight_));
    if (grad_weight.defined()) {
        grad_weight.resize_(weight.sizes());
        grad_weight.zero_();
    }
    auto grad_bias_ = output_mask[2] ? c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<double>(), allocator(), false).release() : nullptr;
    auto grad_bias = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_bias_ == nullptr ? (TensorImpl*)UndefinedTensorImpl::singleton() : (TensorImpl*)grad_bias_));
    if (grad_bias.defined()) {
        grad_bias.resize_({ weight.size(0) });
        grad_bias.zero_();
    }
    if (grad_input_) THNN_DoubleVolumetricDilatedConvolution_updateGradInput(globalContext().getTHCState(), self_, grad_output_, grad_input_ ? grad_input_ : NULL, weight_, columns_, kernel_size_[0], kernel_size_[2], kernel_size_[1], stride_[0], stride_[2], stride_[1], padding_[0], padding_[2], padding_[1], dilation_[0], dilation_[2], dilation_[1]);
    if (grad_weight_ || grad_bias_) THNN_DoubleVolumetricDilatedConvolution_accGradParameters(globalContext().getTHCState(), self_, grad_output_, grad_weight_ ? grad_weight_ : NULL, grad_bias_ ? grad_bias_ : NULL, columns_, ones_, kernel_size_[0], kernel_size_[2], kernel_size_[1], stride_[0], stride_[2], stride_[1], padding_[0], padding_[2], padding_[1], dilation_[0], dilation_[2], dilation_[1], 1);
    if (grad_input_) grad_input_->maybe_zero_dim(self_->dim() == 0);
    return std::tuple<Tensor, Tensor, Tensor>(grad_input, grad_weight, grad_bias);
}
std::tuple<Tensor,Tensor> CPUDoubleType::_cudnn_ctc_loss(const Tensor & log_probs, const Tensor & targets, IntList input_lengths, IntList target_lengths, int64_t blank, bool deterministic) const {
    AT_ERROR("_cudnn_ctc_loss not supported on CPUDoubleType");
}
Tensor CPUDoubleType::_cudnn_rnn_flatten_weight(TensorList weight_arr, int64_t weight_stride0, int64_t input_size, int64_t mode, int64_t hidden_size, int64_t num_layers, bool batch_first, bool bidirectional) const {
    AT_ERROR("_cudnn_rnn_flatten_weight not supported on CPUDoubleType");
}
std::tuple<Tensor,Tensor,Tensor,Tensor,Tensor> CPUDoubleType::_cudnn_rnn(const Tensor & input, TensorList weight, int64_t weight_stride0, const Tensor & weight_buf, const Tensor & hx, const Tensor & cx, int64_t mode, int64_t hidden_size, int64_t num_layers, bool batch_first, double dropout, bool train, bool bidirectional, IntList batch_sizes, const Tensor & dropout_state) const {
    AT_ERROR("_cudnn_rnn not supported on CPUDoubleType");
}
std::tuple<Tensor,Tensor,Tensor,std::vector<Tensor>> CPUDoubleType::_cudnn_rnn_backward(const Tensor & input, TensorList weight, int64_t weight_stride0, const Tensor & weight_buf, const Tensor & hx, const Tensor & cx, const Tensor & output, const Tensor & grad_output, const Tensor & grad_hy, const Tensor & grad_cy, int64_t mode, int64_t hidden_size, int64_t num_layers, bool batch_first, double dropout, bool train, bool bidirectional, IntList batch_sizes, const Tensor & dropout_state, const Tensor & reserve, std::array<bool,4> output_mask) const {
    AT_ERROR("_cudnn_rnn_backward not supported on CPUDoubleType");
}
Tensor CPUDoubleType::_cudnn_init_dropout_state(double dropout, bool train, int64_t dropout_seed, const TensorOptions & options) const {
    AT_ERROR("_cudnn_init_dropout_state not supported on CPUDoubleType");
}
std::tuple<Tensor,Tensor> CPUDoubleType::_fused_dropout(const Tensor & self, double p, Generator * generator) const {
    AT_ERROR("_fused_dropout not supported on CPUDoubleType");
}
Tensor CPUDoubleType::_masked_scale(const Tensor & self, const Tensor & mask, double scale) const {
    AT_ERROR("_masked_scale not supported on CPUDoubleType");
}
Tensor & CPUDoubleType::abs_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::_abs__cpu(/* actuals */ self);
}
Tensor & CPUDoubleType::abs_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    return at::native::_abs_out_cpu(/* actuals */ result, self);
}
Tensor & CPUDoubleType::acos_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::_acos__cpu(/* actuals */ self);
}
Tensor & CPUDoubleType::acos_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    return at::native::_acos_out_cpu(/* actuals */ result, self);
}
Tensor & CPUDoubleType::asin_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::_asin__cpu(/* actuals */ self);
}
Tensor & CPUDoubleType::asin_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    return at::native::_asin_out_cpu(/* actuals */ result, self);
}
Tensor & CPUDoubleType::atan_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::_atan__cpu(/* actuals */ self);
}
Tensor & CPUDoubleType::atan_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    return at::native::_atan_out_cpu(/* actuals */ result, self);
}
Tensor CPUDoubleType::baddbmm(const Tensor & self, const Tensor & batch1, const Tensor & batch2, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(self);
    return at::native::baddbmm_cpu(/* actuals */ self, batch1, batch2, beta, alpha);
}
Tensor & CPUDoubleType::baddbmm_(Tensor & self, const Tensor & batch1, const Tensor & batch2, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(self);
    return at::native::baddbmm__cpu(/* actuals */ self, batch1, batch2, beta, alpha);
}
Tensor & CPUDoubleType::baddbmm_out(Tensor & result, const Tensor & self, const Tensor & batch1, const Tensor & batch2, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(result);
    return at::native::baddbmm_out_cpu(/* actuals */ result, self, batch1, batch2, beta, alpha);
}
Tensor & CPUDoubleType::bernoulli_(Tensor & self, const Tensor & p, Generator * generator) const {
    const DeviceGuard device_guard(self);
    return at::native::bernoulli_tensor_cpu_(/* actuals */ self, p, generator);
}
Tensor & CPUDoubleType::bernoulli_(Tensor & self, double p, Generator * generator) const {
    const DeviceGuard device_guard(self);
    return at::native::bernoulli_scalar_cpu_(/* actuals */ self, p, generator);
}
Tensor CPUDoubleType::bincount(const Tensor & self, const Tensor & weights, int64_t minlength) const {
    const DeviceGuard device_guard(self);
    return at::native::_bincount_cpu(/* actuals */ self, weights, minlength);
}
Tensor CPUDoubleType::bmm(const Tensor & self, const Tensor & mat2) const {
    const DeviceGuard device_guard(self);
    return at::native::bmm_cpu(/* actuals */ self, mat2);
}
Tensor & CPUDoubleType::bmm_out(Tensor & result, const Tensor & self, const Tensor & mat2) const {
    const DeviceGuard device_guard(result);
    return at::native::bmm_out_cpu(/* actuals */ result, self, mat2);
}
Tensor & CPUDoubleType::ceil_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::_ceil__cpu(/* actuals */ self);
}
Tensor & CPUDoubleType::ceil_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    return at::native::_ceil_out_cpu(/* actuals */ result, self);
}
Tensor & CPUDoubleType::clamp_(Tensor & self, c10::optional<Scalar> min, c10::optional<Scalar> max) const {
    const DeviceGuard device_guard(self);
    return at::native::_clamp__cpu(/* actuals */ self, min, max);
}
Tensor & CPUDoubleType::clamp_out(Tensor & result, const Tensor & self, c10::optional<Scalar> min, c10::optional<Scalar> max) const {
    const DeviceGuard device_guard(result);
    return at::native::_clamp_out_cpu(/* actuals */ result, self, min, max);
}
Tensor & CPUDoubleType::clamp_max_(Tensor & self, Scalar max) const {
    const DeviceGuard device_guard(self);
    return at::native::_clamp_max__cpu(/* actuals */ self, max);
}
Tensor & CPUDoubleType::clamp_max_out(Tensor & result, const Tensor & self, Scalar max) const {
    const DeviceGuard device_guard(result);
    return at::native::_clamp_max_out_cpu(/* actuals */ result, self, max);
}
Tensor & CPUDoubleType::clamp_min_(Tensor & self, Scalar min) const {
    const DeviceGuard device_guard(self);
    return at::native::_clamp_min__cpu(/* actuals */ self, min);
}
Tensor & CPUDoubleType::clamp_min_out(Tensor & result, const Tensor & self, Scalar min) const {
    const DeviceGuard device_guard(result);
    return at::native::_clamp_min_out_cpu(/* actuals */ result, self, min);
}
Tensor & CPUDoubleType::cos_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::_cos__cpu(/* actuals */ self);
}
Tensor & CPUDoubleType::cos_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    return at::native::_cos_out_cpu(/* actuals */ result, self);
}
Tensor & CPUDoubleType::cosh_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::_cosh__cpu(/* actuals */ self);
}
Tensor & CPUDoubleType::cosh_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    return at::native::_cosh_out_cpu(/* actuals */ result, self);
}
Tensor CPUDoubleType::cudnn_affine_grid_generator(const Tensor & theta, int64_t N, int64_t C, int64_t H, int64_t W) const {
    AT_ERROR("cudnn_affine_grid_generator not supported on CPUDoubleType");
}
Tensor CPUDoubleType::cudnn_affine_grid_generator_backward(const Tensor & grad, int64_t N, int64_t C, int64_t H, int64_t W) const {
    AT_ERROR("cudnn_affine_grid_generator_backward not supported on CPUDoubleType");
}
std::tuple<Tensor,Tensor,Tensor> CPUDoubleType::cudnn_batch_norm(const Tensor & input, const Tensor & weight, const Tensor & bias, const Tensor & running_mean, const Tensor & running_var, bool training, double exponential_average_factor, double epsilon) const {
    AT_ERROR("cudnn_batch_norm not supported on CPUDoubleType");
}
std::tuple<Tensor,Tensor,Tensor> CPUDoubleType::cudnn_batch_norm_backward(const Tensor & input, const Tensor & grad_output, const Tensor & weight, const Tensor & running_mean, const Tensor & running_var, const Tensor & save_mean, const Tensor & save_var, double epsilon) const {
    AT_ERROR("cudnn_batch_norm_backward not supported on CPUDoubleType");
}
Tensor CPUDoubleType::cudnn_convolution(const Tensor & self, const Tensor & weight, const Tensor & bias, IntList padding, IntList stride, IntList dilation, int64_t groups, bool benchmark, bool deterministic) const {
    AT_ERROR("cudnn_convolution not supported on CPUDoubleType");
}
Tensor CPUDoubleType::cudnn_convolution_backward_input(IntList self_size, const Tensor & grad_output, const Tensor & weight, IntList padding, IntList stride, IntList dilation, int64_t groups, bool benchmark, bool deterministic) const {
    AT_ERROR("cudnn_convolution_backward_input not supported on CPUDoubleType");
}
std::tuple<Tensor,Tensor,Tensor> CPUDoubleType::cudnn_convolution_backward(const Tensor & self, const Tensor & grad_output, const Tensor & weight, IntList padding, IntList stride, IntList dilation, int64_t groups, bool benchmark, bool deterministic, std::array<bool,3> output_mask) const {
    AT_ERROR("cudnn_convolution_backward not supported on CPUDoubleType");
}
Tensor CPUDoubleType::cudnn_convolution_backward_bias(const Tensor & grad_output) const {
    AT_ERROR("cudnn_convolution_backward_bias not supported on CPUDoubleType");
}
Tensor CPUDoubleType::cudnn_convolution_backward_weight(IntList weight_size, const Tensor & grad_output, const Tensor & self, IntList padding, IntList stride, IntList dilation, int64_t groups, bool benchmark, bool deterministic) const {
    AT_ERROR("cudnn_convolution_backward_weight not supported on CPUDoubleType");
}
Tensor CPUDoubleType::cudnn_convolution_transpose(const Tensor & self, const Tensor & weight, const Tensor & bias, IntList padding, IntList output_padding, IntList stride, IntList dilation, int64_t groups, bool benchmark, bool deterministic) const {
    AT_ERROR("cudnn_convolution_transpose not supported on CPUDoubleType");
}
std::tuple<Tensor,Tensor,Tensor> CPUDoubleType::cudnn_convolution_transpose_backward(const Tensor & self, const Tensor & grad_output, const Tensor & weight, IntList padding, IntList output_padding, IntList stride, IntList dilation, int64_t groups, bool benchmark, bool deterministic, std::array<bool,3> output_mask) const {
    AT_ERROR("cudnn_convolution_transpose_backward not supported on CPUDoubleType");
}
Tensor CPUDoubleType::cudnn_convolution_transpose_backward_bias(const Tensor & grad_output) const {
    AT_ERROR("cudnn_convolution_transpose_backward_bias not supported on CPUDoubleType");
}
Tensor CPUDoubleType::cudnn_convolution_transpose_backward_input(const Tensor & grad_output, const Tensor & weight, IntList padding, IntList stride, IntList dilation, int64_t groups, bool benchmark, bool deterministic) const {
    AT_ERROR("cudnn_convolution_transpose_backward_input not supported on CPUDoubleType");
}
Tensor CPUDoubleType::cudnn_convolution_transpose_backward_weight(IntList weight_size, const Tensor & grad_output, const Tensor & self, IntList padding, IntList stride, IntList dilation, int64_t groups, bool benchmark, bool deterministic) const {
    AT_ERROR("cudnn_convolution_transpose_backward_weight not supported on CPUDoubleType");
}
Tensor CPUDoubleType::cudnn_grid_sampler(const Tensor & self, const Tensor & grid) const {
    AT_ERROR("cudnn_grid_sampler not supported on CPUDoubleType");
}
std::tuple<Tensor,Tensor> CPUDoubleType::cudnn_grid_sampler_backward(const Tensor & self, const Tensor & grid, const Tensor & grad_output) const {
    AT_ERROR("cudnn_grid_sampler_backward not supported on CPUDoubleType");
}
std::tuple<Tensor,Tensor> CPUDoubleType::_ctc_loss(const Tensor & log_probs, const Tensor & targets, IntList input_lengths, IntList target_lengths, int64_t blank) const {
    const DeviceGuard device_guard(log_probs);
    return at::native::ctc_loss_cpu(/* actuals */ log_probs, targets, input_lengths, target_lengths, blank);
}
Tensor CPUDoubleType::_ctc_loss_backward(const Tensor & grad, const Tensor & log_probs, const Tensor & targets, IntList input_lengths, IntList target_lengths, const Tensor & neg_log_likelihood, const Tensor & log_alpha, int64_t blank) const {
    const DeviceGuard device_guard(grad);
    return at::native::ctc_loss_backward_cpu(/* actuals */ grad, log_probs, targets, input_lengths, target_lengths, neg_log_likelihood, log_alpha, blank);
}
Tensor CPUDoubleType::embedding_dense_backward(const Tensor & grad, const Tensor & indices, int64_t num_weights, int64_t padding_idx, bool scale_grad_by_freq) const {
    const DeviceGuard device_guard(grad);
    return at::native::embedding_dense_backward_cpu(/* actuals */ grad, indices, num_weights, padding_idx, scale_grad_by_freq);
}
Tensor & CPUDoubleType::embedding_renorm_(Tensor & self, const Tensor & indices, double max_norm, double norm_type) const {
    const DeviceGuard device_guard(self);
    return at::native::embedding_renorm_cpu_(/* actuals */ self, indices, max_norm, norm_type);
}
std::tuple<Tensor,Tensor,Tensor,Tensor> CPUDoubleType::_embedding_bag(const Tensor & weight, const Tensor & indices, const Tensor & offsets, bool scale_grad_by_freq, int64_t mode, bool sparse) const {
    const DeviceGuard device_guard(weight);
    return at::native::_embedding_bag_cpu(/* actuals */ weight, indices, offsets, scale_grad_by_freq, mode, sparse);
}
Tensor CPUDoubleType::_embedding_bag_dense_backward(const Tensor & grad, const Tensor & indices, const Tensor & offsets, const Tensor & offset2bag, const Tensor & bag_size, const Tensor & maximum_indices, int64_t num_weights, bool scale_grad_by_freq, int64_t mode) const {
    const DeviceGuard device_guard(grad);
    return at::native::_embedding_bag_dense_backward_cpu(/* actuals */ grad, indices, offsets, offset2bag, bag_size, maximum_indices, num_weights, scale_grad_by_freq, mode);
}
Tensor CPUDoubleType::empty(IntList size, const TensorOptions & options) const {
    const DeviceGuard device_guard(options.device());
    return at::native::empty_cpu(/* actuals */ size, options);
}
Tensor & CPUDoubleType::resize_(Tensor & self, IntList size) const {
    // DeviceGuard omitted
    return at::native::resize_cpu_(/* actuals */ self, size);
}
Tensor & CPUDoubleType::erf_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::_erf__cpu(/* actuals */ self);
}
Tensor & CPUDoubleType::erf_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    return at::native::_erf_out_cpu(/* actuals */ result, self);
}
Tensor & CPUDoubleType::erfc_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::_erfc__cpu(/* actuals */ self);
}
Tensor & CPUDoubleType::erfc_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    return at::native::_erfc_out_cpu(/* actuals */ result, self);
}
Tensor & CPUDoubleType::exp_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::_exp__cpu(/* actuals */ self);
}
Tensor & CPUDoubleType::exp_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    return at::native::_exp_out_cpu(/* actuals */ result, self);
}
Tensor & CPUDoubleType::expm1_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::_expm1__cpu(/* actuals */ self);
}
Tensor & CPUDoubleType::expm1_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    return at::native::_expm1_out_cpu(/* actuals */ result, self);
}
Tensor & CPUDoubleType::eye_out(Tensor & result, int64_t n) const {
    const DeviceGuard device_guard(result);
    return at::native::eye_out_cpu(/* actuals */ result, n);
}
Tensor & CPUDoubleType::eye_out(Tensor & result, int64_t n, int64_t m) const {
    const DeviceGuard device_guard(result);
    return at::native::eye_out_cpu(/* actuals */ result, n, m);
}
Tensor & CPUDoubleType::floor_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::_floor__cpu(/* actuals */ self);
}
Tensor & CPUDoubleType::floor_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    return at::native::_floor_out_cpu(/* actuals */ result, self);
}
Tensor CPUDoubleType::grid_sampler_2d(const Tensor & input, const Tensor & grid, int64_t interpolation_mode, int64_t padding_mode) const {
    const DeviceGuard device_guard(input);
    return at::native::grid_sampler_2d_cpu(/* actuals */ input, grid, interpolation_mode, padding_mode);
}
std::tuple<Tensor,Tensor> CPUDoubleType::grid_sampler_2d_backward(const Tensor & grad_output, const Tensor & input, const Tensor & grid, int64_t interpolation_mode, int64_t padding_mode) const {
    const DeviceGuard device_guard(grad_output);
    return at::native::grid_sampler_2d_backward_cpu(/* actuals */ grad_output, input, grid, interpolation_mode, padding_mode);
}
Tensor CPUDoubleType::grid_sampler_3d(const Tensor & input, const Tensor & grid, int64_t interpolation_mode, int64_t padding_mode) const {
    const DeviceGuard device_guard(input);
    return at::native::grid_sampler_3d_cpu(/* actuals */ input, grid, interpolation_mode, padding_mode);
}
std::tuple<Tensor,Tensor> CPUDoubleType::grid_sampler_3d_backward(const Tensor & grad_output, const Tensor & input, const Tensor & grid, int64_t interpolation_mode, int64_t padding_mode) const {
    const DeviceGuard device_guard(grad_output);
    return at::native::grid_sampler_3d_backward_cpu(/* actuals */ grad_output, input, grid, interpolation_mode, padding_mode);
}
std::tuple<Tensor,Tensor> CPUDoubleType::_gesv_helper(const Tensor & self, const Tensor & A) const {
    const DeviceGuard device_guard(self);
    return at::native::_gesv_helper_cpu(/* actuals */ self, A);
}
Tensor CPUDoubleType::_fft_with_size(const Tensor & self, int64_t signal_ndim, bool complex_input, bool complex_output, bool inverse, IntList checked_signal_sizes, bool normalized, bool onesided, IntList output_sizes) const {
    const DeviceGuard device_guard(self);
    return at::native::_fft_mkl(/* actuals */ self, signal_ndim, complex_input, complex_output, inverse, checked_signal_sizes, normalized, onesided, output_sizes);
}
Tensor CPUDoubleType::kl_div_backward(const Tensor & grad_output, const Tensor & self, const Tensor & target, int64_t reduction) const {
    const DeviceGuard device_guard(grad_output);
    return at::native::kl_div_backward_cpu(/* actuals */ grad_output, self, target, reduction);
}
Tensor & CPUDoubleType::log_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::_log__cpu(/* actuals */ self);
}
Tensor & CPUDoubleType::log_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    return at::native::_log_out_cpu(/* actuals */ result, self);
}
Tensor & CPUDoubleType::log10_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::_log10__cpu(/* actuals */ self);
}
Tensor & CPUDoubleType::log10_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    return at::native::_log10_out_cpu(/* actuals */ result, self);
}
Tensor & CPUDoubleType::log1p_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::_log1p__cpu(/* actuals */ self);
}
Tensor & CPUDoubleType::log1p_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    return at::native::_log1p_out_cpu(/* actuals */ result, self);
}
Tensor & CPUDoubleType::log2_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::_log2__cpu(/* actuals */ self);
}
Tensor & CPUDoubleType::log2_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    return at::native::_log2_out_cpu(/* actuals */ result, self);
}
Tensor CPUDoubleType::_log_softmax(const Tensor & self, int64_t dim, bool half_to_float) const {
    const DeviceGuard device_guard(self);
    return at::native::log_softmax_cpu(/* actuals */ self, dim, half_to_float);
}
Tensor CPUDoubleType::_log_softmax_backward_data(const Tensor & grad_output, const Tensor & output, int64_t dim, const Tensor & self) const {
    const DeviceGuard device_guard(grad_output);
    return at::native::log_softmax_backward_cpu(/* actuals */ grad_output, output, dim, self);
}
std::tuple<Tensor,Tensor,Tensor> CPUDoubleType::miopen_batch_norm(const Tensor & input, const Tensor & weight, const Tensor & bias, const Tensor & running_mean, const Tensor & running_var, bool training, double exponential_average_factor, double epsilon) const {
    AT_ERROR("miopen_batch_norm not supported on CPUDoubleType");
}
std::tuple<Tensor,Tensor,Tensor> CPUDoubleType::miopen_batch_norm_backward(const Tensor & input, const Tensor & grad_output, const Tensor & weight, const Tensor & running_mean, const Tensor & running_var, const Tensor & save_mean, const Tensor & save_var, double epsilon) const {
    AT_ERROR("miopen_batch_norm_backward not supported on CPUDoubleType");
}
Tensor CPUDoubleType::miopen_convolution(const Tensor & self, const Tensor & weight, const Tensor & bias, IntList padding, IntList stride, IntList dilation, int64_t groups, bool benchmark, bool deterministic) const {
    AT_ERROR("miopen_convolution not supported on CPUDoubleType");
}
Tensor CPUDoubleType::miopen_convolution_backward_input(IntList self_size, const Tensor & grad_output, const Tensor & weight, IntList padding, IntList stride, IntList dilation, int64_t groups, bool benchmark, bool deterministic) const {
    AT_ERROR("miopen_convolution_backward_input not supported on CPUDoubleType");
}
std::tuple<Tensor,Tensor,Tensor> CPUDoubleType::miopen_convolution_backward(const Tensor & self, const Tensor & grad_output, const Tensor & weight, IntList padding, IntList stride, IntList dilation, int64_t groups, bool benchmark, bool deterministic, std::array<bool,3> output_mask) const {
    AT_ERROR("miopen_convolution_backward not supported on CPUDoubleType");
}
Tensor CPUDoubleType::miopen_convolution_backward_bias(const Tensor & grad_output) const {
    AT_ERROR("miopen_convolution_backward_bias not supported on CPUDoubleType");
}
Tensor CPUDoubleType::miopen_convolution_backward_weight(IntList weight_size, const Tensor & grad_output, const Tensor & self, IntList padding, IntList stride, IntList dilation, int64_t groups, bool benchmark, bool deterministic) const {
    AT_ERROR("miopen_convolution_backward_weight not supported on CPUDoubleType");
}
Tensor CPUDoubleType::miopen_convolution_transpose(const Tensor & self, const Tensor & weight, const Tensor & bias, IntList padding, IntList output_padding, IntList stride, IntList dilation, int64_t groups, bool benchmark, bool deterministic) const {
    AT_ERROR("miopen_convolution_transpose not supported on CPUDoubleType");
}
std::tuple<Tensor,Tensor,Tensor> CPUDoubleType::miopen_convolution_transpose_backward(const Tensor & self, const Tensor & grad_output, const Tensor & weight, IntList padding, IntList output_padding, IntList stride, IntList dilation, int64_t groups, bool benchmark, bool deterministic, std::array<bool,3> output_mask) const {
    AT_ERROR("miopen_convolution_transpose_backward not supported on CPUDoubleType");
}
Tensor CPUDoubleType::miopen_convolution_transpose_backward_input(const Tensor & grad_output, const Tensor & weight, IntList padding, IntList stride, IntList dilation, int64_t groups, bool benchmark, bool deterministic) const {
    AT_ERROR("miopen_convolution_transpose_backward_input not supported on CPUDoubleType");
}
Tensor CPUDoubleType::miopen_convolution_transpose_backward_weight(IntList weight_size, const Tensor & grad_output, const Tensor & self, IntList padding, IntList stride, IntList dilation, int64_t groups, bool benchmark, bool deterministic) const {
    AT_ERROR("miopen_convolution_transpose_backward_weight not supported on CPUDoubleType");
}
Tensor CPUDoubleType::narrow_copy(const Tensor & self, int64_t dim, int64_t start, int64_t length) const {
    const DeviceGuard device_guard(self);
    return at::native::narrow_copy_dense(/* actuals */ self, dim, start, length);
}
std::tuple<Tensor,Tensor,Tensor> CPUDoubleType::native_batch_norm(const Tensor & input, const Tensor & weight, const Tensor & bias, const Tensor & running_mean, const Tensor & running_var, bool training, double momentum, double eps) const {
    const DeviceGuard device_guard(input);
    return at::native::batch_norm_cpu(/* actuals */ input, weight, bias, running_mean, running_var, training, momentum, eps);
}
std::tuple<Tensor,Tensor,Tensor> CPUDoubleType::native_batch_norm_backward(const Tensor & grad_out, const Tensor & input, const Tensor & weight, const Tensor & running_mean, const Tensor & running_var, const Tensor & save_mean, const Tensor & save_invstd, bool train, double eps, std::array<bool,3> output_mask) const {
    const DeviceGuard device_guard(grad_out);
    return at::native::batch_norm_backward_cpu(/* actuals */ grad_out, input, weight, running_mean, running_var, save_mean, save_invstd, train, eps, output_mask);
}
Tensor & CPUDoubleType::randperm_out(Tensor & result, int64_t n, Generator * generator) const {
    const DeviceGuard device_guard(result);
    return at::native::randperm_out_cpu(/* actuals */ result, n, generator);
}
std::tuple<Tensor,Tensor> CPUDoubleType::RoiPooling2d_forward(const Tensor & input, const Tensor & rois, int64_t pooledHeight, int64_t pooledWidth, double spatialScale) const {
    const DeviceGuard device_guard(input);
    return at::native::RoiPooling2d_forward_cpu(/* actuals */ input, rois, pooledHeight, pooledWidth, spatialScale);
}
Tensor CPUDoubleType::RoiPooling2d_backward(const Tensor & input, const Tensor & rois, int64_t pooledHeight, int64_t pooledWidth, double spatialScale, const Tensor & gradOutput, const Tensor & argmaxes) const {
    const DeviceGuard device_guard(input);
    return at::native::RoiPooling2d_backward_cpu(/* actuals */ input, rois, pooledHeight, pooledWidth, spatialScale, gradOutput, argmaxes);
}
Tensor & CPUDoubleType::round_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::_round__cpu(/* actuals */ self);
}
Tensor & CPUDoubleType::round_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    return at::native::_round_out_cpu(/* actuals */ result, self);
}
Tensor CPUDoubleType::prelu(const Tensor & self, const Tensor & weight) const {
    const DeviceGuard device_guard(self);
    return at::native::prelu_cpu(/* actuals */ self, weight);
}
std::tuple<Tensor,Tensor> CPUDoubleType::prelu_backward(const Tensor & grad_output, const Tensor & self, const Tensor & weight) const {
    const DeviceGuard device_guard(grad_output);
    return at::native::prelu_backward_cpu(/* actuals */ grad_output, self, weight);
}
Tensor CPUDoubleType::hardshrink(const Tensor & self, Scalar lambd) const {
    const DeviceGuard device_guard(self);
    return at::native::hardshrink_cpu(/* actuals */ self, lambd);
}
Tensor CPUDoubleType::hardshrink_backward(const Tensor & grad_out, const Tensor & self, Scalar lambd) const {
    const DeviceGuard device_guard(grad_out);
    return at::native::hardshrink_backward_cpu(/* actuals */ grad_out, self, lambd);
}
Tensor & CPUDoubleType::rsqrt_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::_rsqrt__cpu(/* actuals */ self);
}
Tensor & CPUDoubleType::rsqrt_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    return at::native::_rsqrt_out_cpu(/* actuals */ result, self);
}
Tensor & CPUDoubleType::sigmoid_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::_sigmoid__cpu(/* actuals */ self);
}
Tensor & CPUDoubleType::sigmoid_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    return at::native::_sigmoid_out_cpu(/* actuals */ result, self);
}
Tensor & CPUDoubleType::sin_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::_sin__cpu(/* actuals */ self);
}
Tensor & CPUDoubleType::sin_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    return at::native::_sin_out_cpu(/* actuals */ result, self);
}
Tensor & CPUDoubleType::sinh_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::_sinh__cpu(/* actuals */ self);
}
Tensor & CPUDoubleType::sinh_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    return at::native::_sinh_out_cpu(/* actuals */ result, self);
}
Tensor CPUDoubleType::_softmax(const Tensor & self, int64_t dim, bool half_to_float) const {
    const DeviceGuard device_guard(self);
    return at::native::softmax_cpu(/* actuals */ self, dim, half_to_float);
}
Tensor CPUDoubleType::_softmax_backward_data(const Tensor & grad_output, const Tensor & output, int64_t dim, const Tensor & self) const {
    const DeviceGuard device_guard(grad_output);
    return at::native::softmax_backward_cpu(/* actuals */ grad_output, output, dim, self);
}
Tensor & CPUDoubleType::_sparse_add_out(Tensor & result, const Tensor & self, const Tensor & other, Scalar alpha) const {
    AT_ERROR("_sparse_add_out not supported on CPUDoubleType");
}
Tensor & CPUDoubleType::_sparse_dense_add_out(Tensor & result, const Tensor & self, SparseTensorRef other, Scalar alpha) const {
    const DeviceGuard device_guard(result);
    return at::native::add_out_dense_sparse_cpu(/* actuals */ result, self, other, alpha);
}
Tensor & CPUDoubleType::_sparse_div_zerodim_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    AT_ERROR("_sparse_div_zerodim_out not supported on CPUDoubleType");
}
Tensor & CPUDoubleType::_sparse_div_scalar_out(Tensor & result, const Tensor & self, Scalar other) const {
    AT_ERROR("_sparse_div_scalar_out not supported on CPUDoubleType");
}
Tensor & CPUDoubleType::_sparse_mul_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    AT_ERROR("_sparse_mul_out not supported on CPUDoubleType");
}
Tensor & CPUDoubleType::_sparse_mul_zerodim_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    AT_ERROR("_sparse_mul_zerodim_out not supported on CPUDoubleType");
}
Tensor & CPUDoubleType::_sparse_mul_scalar_out(Tensor & result, const Tensor & self, Scalar other) const {
    AT_ERROR("_sparse_mul_scalar_out not supported on CPUDoubleType");
}
Tensor & CPUDoubleType::sspaddmm_out(Tensor & result, const Tensor & self, const Tensor & mat1, const Tensor & mat2, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(result);
    return at::native::_sspaddmm_out_only_sparse(/* actuals */ result, self, mat1, mat2, beta, alpha);
}
Tensor & CPUDoubleType::sqrt_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::_sqrt__cpu(/* actuals */ self);
}
Tensor & CPUDoubleType::sqrt_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    return at::native::_sqrt_out_cpu(/* actuals */ result, self);
}
Tensor & CPUDoubleType::tan_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::_tan__cpu(/* actuals */ self);
}
Tensor & CPUDoubleType::tan_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    return at::native::_tan_out_cpu(/* actuals */ result, self);
}
Tensor & CPUDoubleType::tanh_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::_tanh__cpu(/* actuals */ self);
}
Tensor & CPUDoubleType::tanh_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    return at::native::_tanh_out_cpu(/* actuals */ result, self);
}
Tensor CPUDoubleType::flip(const Tensor & self, IntList dims) const {
    const DeviceGuard device_guard(self);
    return at::native::flip_cpu(/* actuals */ self, dims);
}
Tensor & CPUDoubleType::trunc_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::_trunc__cpu(/* actuals */ self);
}
Tensor & CPUDoubleType::trunc_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    return at::native::_trunc_out_cpu(/* actuals */ result, self);
}
std::tuple<Tensor,Tensor> CPUDoubleType::_unique(const Tensor & self, bool sorted, bool return_inverse) const {
    const DeviceGuard device_guard(self);
    return at::native::_unique_cpu(/* actuals */ self, sorted, return_inverse);
}
std::tuple<Tensor,Tensor> CPUDoubleType::_unique_dim(const Tensor & self, int64_t dim, bool sorted, bool return_inverse) const {
    const DeviceGuard device_guard(self);
    return at::native::_unique_dim_cpu(/* actuals */ self, dim, sorted, return_inverse);
}
Tensor CPUDoubleType::_s_where(const Tensor & condition, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    return at::native::_s_where_cpu(/* actuals */ condition, self, other);
}
std::tuple<Tensor,Tensor> CPUDoubleType::_weight_norm_cuda_interface(const Tensor & v, const Tensor & g, int64_t dim) const {
    AT_ERROR("_weight_norm_cuda_interface not supported on CPUDoubleType");
}
std::tuple<Tensor,Tensor> CPUDoubleType::_weight_norm_cuda_interface_backward(const Tensor & grad_w, const Tensor & saved_v, const Tensor & saved_g, const Tensor & saved_norms, int64_t dim) const {
    AT_ERROR("_weight_norm_cuda_interface_backward not supported on CPUDoubleType");
}
Tensor CPUDoubleType::_standard_gamma_grad(const Tensor & self, const Tensor & output) const {
    const DeviceGuard device_guard(self);
    return at::native::_standard_gamma_grad_cpu(/* actuals */ self, output);
}
Tensor CPUDoubleType::_standard_gamma(const Tensor & self, Generator * generator) const {
    const DeviceGuard device_guard(self);
    return at::native::_s_gamma_cpu(/* actuals */ self, generator);
}
Tensor CPUDoubleType::poisson(const Tensor & self, Generator * generator) const {
    const DeviceGuard device_guard(self);
    return at::native::_s_poisson_cpu(/* actuals */ self, generator);
}
Tensor CPUDoubleType::native_norm(const Tensor & self, Scalar p) const {
    AT_ERROR("native_norm not supported on CPUDoubleType");
}
Tensor CPUDoubleType::native_clone(const Tensor & self) const {
    AT_ERROR("native_clone not supported on CPUDoubleType");
}
Tensor & CPUDoubleType::native_resize_as_(Tensor & self, const Tensor & the_template) const {
    AT_ERROR("native_resize_as_ not supported on CPUDoubleType");
}
Tensor & CPUDoubleType::native_pow_out(Tensor & result, const Tensor & self, Scalar exponent) const {
    AT_ERROR("native_pow_out not supported on CPUDoubleType");
}
Tensor CPUDoubleType::native_pow(const Tensor & self, Scalar exponent) const {
    AT_ERROR("native_pow not supported on CPUDoubleType");
}
Tensor & CPUDoubleType::native_zero_(Tensor & self) const {
    AT_ERROR("native_zero_ not supported on CPUDoubleType");
}
Tensor & CPUDoubleType::s_native_addmm_out(Tensor & result, const Tensor & self, const Tensor & mat1, const Tensor & mat2, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(result);
    return at::native::s_addmm_out_sparse_dense_cpu(/* actuals */ result, self, mat1, mat2, beta, alpha);
}
Tensor CPUDoubleType::s_native_addmm(const Tensor & self, const Tensor & mat1, const Tensor & mat2, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(self);
    return at::native::s_addmm_sparse_dense_cpu(/* actuals */ self, mat1, mat2, beta, alpha);
}
Tensor & CPUDoubleType::s_native_addmm_(Tensor & self, const Tensor & mat1, const Tensor & mat2, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(self);
    return at::native::s_addmm_sparse_dense_cpu_(/* actuals */ self, mat1, mat2, beta, alpha);
}
Tensor CPUDoubleType::_sparse_coo_tensor_with_dims(int64_t sparse_dim, int64_t dense_dim, IntList size, const TensorOptions & options) const {
    AT_ERROR("_sparse_coo_tensor_with_dims not supported on CPUDoubleType");
}
Tensor CPUDoubleType::_sparse_coo_tensor_with_dims_and_tensors(int64_t sparse_dim, int64_t dense_dim, IntList size, const Tensor & indices, const Tensor & values, const TensorOptions & options) const {
    AT_ERROR("_sparse_coo_tensor_with_dims_and_tensors not supported on CPUDoubleType");
}
Tensor & CPUDoubleType::sparse_resize_(Tensor & self, IntList size, int64_t sparse_dim, int64_t dense_dim) const {
    AT_ERROR("sparse_resize_ not supported on CPUDoubleType");
}
Tensor & CPUDoubleType::sparse_resize_and_clear_(Tensor & self, IntList size, int64_t sparse_dim, int64_t dense_dim) const {
    AT_ERROR("sparse_resize_and_clear_ not supported on CPUDoubleType");
}
Tensor CPUDoubleType::sparse_mask(const Tensor & self, SparseTensorRef mask) const {
    const DeviceGuard device_guard(self);
    return at::native::sparse_mask_cpu(/* actuals */ self, mask);
}
Tensor CPUDoubleType::to_dense(const Tensor & self) const {
    AT_ERROR("to_dense not supported on CPUDoubleType");
}
int64_t CPUDoubleType::sparse_dim(const Tensor & self) const {
    AT_ERROR("sparse_dim not supported on CPUDoubleType");
}
int64_t CPUDoubleType::dense_dim(const Tensor & self) const {
    AT_ERROR("dense_dim not supported on CPUDoubleType");
}
int64_t CPUDoubleType::_nnz(const Tensor & self) const {
    AT_ERROR("_nnz not supported on CPUDoubleType");
}
Tensor CPUDoubleType::coalesce(const Tensor & self) const {
    AT_ERROR("coalesce not supported on CPUDoubleType");
}
bool CPUDoubleType::is_coalesced(const Tensor & self) const {
    AT_ERROR("is_coalesced not supported on CPUDoubleType");
}
Tensor CPUDoubleType::_indices(const Tensor & self) const {
    AT_ERROR("_indices not supported on CPUDoubleType");
}
Tensor CPUDoubleType::_values(const Tensor & self) const {
    AT_ERROR("_values not supported on CPUDoubleType");
}
Tensor & CPUDoubleType::_coalesced_(Tensor & self, bool coalesced) const {
    AT_ERROR("_coalesced_ not supported on CPUDoubleType");
}
Tensor CPUDoubleType::indices(const Tensor & self) const {
    AT_ERROR("indices not supported on CPUDoubleType");
}
Tensor CPUDoubleType::values(const Tensor & self) const {
    AT_ERROR("values not supported on CPUDoubleType");
}
Tensor & CPUDoubleType::hspmm_out(Tensor & result, const Tensor & mat1, const Tensor & mat2) const {
    AT_ERROR("hspmm_out not supported on CPUDoubleType");
}
Tensor CPUDoubleType::hspmm(const Tensor & mat1, const Tensor & mat2) const {
    AT_ERROR("hspmm not supported on CPUDoubleType");
}
Tensor & CPUDoubleType::copy_sparse_to_sparse_(Tensor & self, const Tensor & src, bool non_blocking) const {
    AT_ERROR("copy_sparse_to_sparse_ not supported on CPUDoubleType");
}
Scalar CPUDoubleType::_local_scalar_dense(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::_local_scalar_dense_cpu(/* actuals */ self);
}
std::tuple<Tensor,Tensor,Tensor> CPUDoubleType::_thnn_fused_lstm_cell(const Tensor & input_gates, const Tensor & hidden_gates, const Tensor & cx, const Tensor & input_bias, const Tensor & hidden_bias) const {
    AT_ERROR("_thnn_fused_lstm_cell not supported on CPUDoubleType");
}
std::tuple<Tensor,Tensor,Tensor,Tensor,Tensor> CPUDoubleType::_thnn_fused_lstm_cell_backward(const Tensor & grad_hy, const Tensor & grad_cy, const Tensor & cx, const Tensor & cy, const Tensor & workspace, bool has_bias) const {
    AT_ERROR("_thnn_fused_lstm_cell_backward not supported on CPUDoubleType");
}
std::tuple<Tensor,Tensor> CPUDoubleType::_thnn_fused_gru_cell(const Tensor & input_gates, const Tensor & hidden_gates, const Tensor & hx, const Tensor & input_bias, const Tensor & hidden_bias) const {
    AT_ERROR("_thnn_fused_gru_cell not supported on CPUDoubleType");
}
std::tuple<Tensor,Tensor,Tensor,Tensor,Tensor> CPUDoubleType::_thnn_fused_gru_cell_backward(const Tensor & grad_hy, const Tensor & workspace, bool has_bias) const {
    AT_ERROR("_thnn_fused_gru_cell_backward not supported on CPUDoubleType");
}

}
