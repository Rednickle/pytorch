#include "ATen/TypeDefault.h"

// @generated by aten/src/ATen/gen.py

#include "ATen/core/SparseTensorRef.h"
#include "ATen/DeviceGuard.h"
#include "ATen/ExpandUtils.h"
#include "ATen/Functions.h"
#include "ATen/NativeFunctions.h"
#include "ATen/core/Scalar.h"
#include "ATen/core/SparseTensorRef.h"
#include "ATen/core/Storage.h"
#include "ATen/Tensor.h"
#include "ATen/core/TensorOptions.h"
#include "ATen/DeviceGuard.h"
#include "ATen/SparseTensorUtils.h"

namespace at {

Tensor & TypeDefault::copy_(Tensor & self, const Tensor & src, bool non_blocking) const {
  Tensor b_src;
  if (is_sparse()) {
    b_src = src;
  } else {
    std::tie(b_src) = expand_inplace(self, src, "copy");
  }
  return s_copy_(self, b_src, non_blocking);
}

Tensor TypeDefault::copy(const Tensor & src, bool non_blocking, optional<Device> to_device) const {
  DeviceGuard device_guard;
  if (to_device.has_value()) {
    device_guard.set_index(to_device.value().index());
  }
  AT_CHECK(src.defined(), "attempt to copy an undefined tensor");
  Tensor r;
  if (is_sparse()) {
    r = at::empty({0}, this->options());
  } else {
    r = at::empty(src.sizes(), this->options());
  }
  r.copy_(src, non_blocking);
  return r;
}

void TypeDefault::backward(
    Tensor& self,
    c10::optional<Tensor> gradient,
    bool keep_graph,
    bool create_graph) const {
  AT_ERROR("backward is not implemented for Tensor");
}

void TypeDefault::set_data(Tensor & self, Tensor new_data) const {
  AT_ERROR("set_data is not implemented for Tensor");
}

Type & TypeDefault::toBackend(Backend b) const {
  return at::globalContext().getNonVariableType(b,scalarType());
}
Type & TypeDefault::toScalarType(ScalarType s) const {
  return at::globalContext().getNonVariableType(backend(),s);
}
static std::vector<int64_t> defaultStrides(IntList sizes) {
  std::vector<int64_t> strides(sizes.size());
  int64_t stride = 1;
  for(size_t i = sizes.size(); i > 0; --i) {
    strides[i-1] = stride;
    stride *= sizes[i-1];
  }
  return strides;
}
static int64_t computeStorageSize(IntList sizes, IntList strides) {
  // size of the underlying storage is 1 bigger than the offset
  // of the last element according to stride
  int64_t size = 1;
  for(size_t i = 0; i < sizes.size(); i++) {
    if(sizes[i] == 0) {
      return 0;
    }
    size += strides[i]*(sizes[i]-1);
  }
  return size;
}
Tensor TypeDefault::tensorFromBlob(void * data, IntList sizes, const std::function<void(void*)> & deleter) const {
  return tensorFromBlob(data, sizes, defaultStrides(sizes), deleter);
}
Tensor TypeDefault::tensorFromBlob(void * data, IntList sizes, IntList strides, const std::function<void(void*)> & deleter) const {
  auto storage = storageFromBlob(data, computeStorageSize(sizes, strides), deleter);
  return tensor(storage, 0, sizes, strides);
}
Tensor TypeDefault::tensorWithAllocator(IntList sizes, Allocator* allocator) const {
  return tensorWithAllocator(sizes, defaultStrides(sizes), std::move(allocator));
}
Tensor TypeDefault::tensorWithAllocator(IntList sizes, IntList strides, Allocator* allocator) const {
  auto storage = storageWithAllocator(computeStorageSize(sizes, strides), std::move(allocator));
  return tensor(storage, 0, sizes, strides);
}

Storage TypeDefault::storage(bool resizable) const {
  return Storage(typeMeta(), 0, allocator(), resizable);
}
Storage TypeDefault::storage(size_t size, bool resizable) const {
  return Storage(typeMeta(), size, allocator(), resizable);
}
Storage TypeDefault::storageFromBlob(void * data, int64_t size, const std::function<void(void*)> & deleter) const {
    return Storage(
      typeMeta(),
      InefficientStdFunctionContext::makeDataPtr(data, deleter, getDeviceFromPtr(data)),
      size,
      deleter);
}
Storage TypeDefault::storageWithAllocator(int64_t size, Allocator* allocator) const {
    return Storage(typeMeta(), size, allocator);
}
Tensor TypeDefault::unsafeTensorFromTH(void * th_pointer, bool retain) const {
  auto tensor_impl = c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(static_cast<TensorImpl*>(th_pointer));
  if (retain && tensor_impl.get() != UndefinedTensorImpl::singleton()) {
    c10::raw::intrusive_ptr::incref(tensor_impl.get());
  }
  return Tensor(std::move(tensor_impl));
}
Storage TypeDefault::unsafeStorageFromTH(void * th_pointer, bool retain) const {
  if (retain && th_pointer) {
    c10::raw::intrusive_ptr::incref(static_cast<StorageImpl*>(th_pointer));
  }
  return Storage(c10::intrusive_ptr<StorageImpl>::reclaim(static_cast<StorageImpl*>(th_pointer)));
}


Tensor TypeDefault::scalarTensor(Scalar s) const {
  return at::empty({}, this->options()).fill_(s);
}

int64_t TypeDefault::_th_storage_offset(const Tensor & self) const {
    AT_ERROR("_th_storage_offset is not implemented for type ", toString());
}
int64_t TypeDefault::_th_ndimension(const Tensor & self) const {
    AT_ERROR("_th_ndimension is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_set_(Tensor & self, Storage source) const {
    AT_ERROR("_th_set_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_set_(Tensor & self, Storage source, int64_t storage_offset, IntList size, IntList stride) const {
    AT_ERROR("_th_set_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_set_(Tensor & self, const Tensor & source) const {
    AT_ERROR("_th_set_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_set_(Tensor & self) const {
    AT_ERROR("_th_set_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_fill_(Tensor & self, Scalar value) const {
    AT_ERROR("_fill_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_fill_(Tensor & self, const Tensor & value) const {
    AT_ERROR("_fill_ is not implemented for type ", toString());
}
bool TypeDefault::_th_is_contiguous(const Tensor & self) const {
    AT_ERROR("_th_is_contiguous is not implemented for type ", toString());
}
bool TypeDefault::_th_is_set_to(const Tensor & self, const Tensor & tensor) const {
    AT_ERROR("_th_is_set_to is not implemented for type ", toString());
}
Tensor & TypeDefault::s__th_masked_fill_(Tensor & self, const Tensor & mask, Scalar value) const {
    AT_ERROR("s__th_masked_fill_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_masked_fill_(Tensor & self, const Tensor & mask, Scalar value) const {
    const DeviceGuard device_guard(self);
    Tensor b_mask;
    std::tie(b_mask) = expand_inplace(self, mask, "_th_masked_fill_");
    return s__th_masked_fill_(self, b_mask, value);
}
Tensor & TypeDefault::s__th_masked_fill_(Tensor & self, const Tensor & mask, const Tensor & value) const {
    AT_ERROR("s__th_masked_fill_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_masked_fill_(Tensor & self, const Tensor & mask, const Tensor & value) const {
    const DeviceGuard device_guard(self);
    Tensor b_mask;
    std::tie(b_mask) = expand_inplace(self, mask, "_th_masked_fill_");
    return s__th_masked_fill_(self, b_mask, value);
}
Tensor & TypeDefault::s__th_masked_scatter_(Tensor & self, const Tensor & mask, const Tensor & source) const {
    AT_ERROR("s__th_masked_scatter_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_masked_scatter_(Tensor & self, const Tensor & mask, const Tensor & source) const {
    const DeviceGuard device_guard(self);
    Tensor b_mask;
    std::tie(b_mask) = expand_inplace(self, mask, "_th_masked_scatter_");
    return s__th_masked_scatter_(self, b_mask, source);
}
Tensor & TypeDefault::s__th_masked_select_out(Tensor & result, const Tensor & self, const Tensor & mask) const {
    AT_ERROR("s__th_masked_select_out is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_masked_select_out(Tensor & result, const Tensor & self, const Tensor & mask) const {
    const DeviceGuard device_guard(result);
    Tensor b_self, b_mask;
    std::tie(b_self, b_mask) = expand_outplace(self, mask, "_th_masked_select_out");
    return s__th_masked_select_out(result, b_self, b_mask);
}
Tensor TypeDefault::s__th_masked_select(const Tensor & self, const Tensor & mask) const {
    AT_ERROR("s__th_masked_select is not implemented for type ", toString());
}
Tensor TypeDefault::_th_masked_select(const Tensor & self, const Tensor & mask) const {
    const DeviceGuard device_guard(self);
    Tensor b_self, b_mask;
    std::tie(b_self, b_mask) = expand_outplace(self, mask, "_th_masked_select");
    return s__th_masked_select(b_self, b_mask);
}
Tensor & TypeDefault::_th_nonzero_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("_th_nonzero_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_nonzero(const Tensor & self) const {
    AT_ERROR("_th_nonzero is not implemented for type ", toString());
}
Tensor TypeDefault::_th_clone(const Tensor & self) const {
    AT_ERROR("_th_clone is not implemented for type ", toString());
}
Tensor TypeDefault::_th_view(const Tensor & self, IntList size) const {
    AT_ERROR("_th_view is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_resize_as_(Tensor & self, const Tensor & the_template) const {
    AT_ERROR("_th_resize_as_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_index_select_out(Tensor & result, const Tensor & self, int64_t dim, const Tensor & index) const {
    AT_ERROR("_th_index_select_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_index_select(const Tensor & self, int64_t dim, const Tensor & index) const {
    AT_ERROR("_th_index_select is not implemented for type ", toString());
}
Tensor & TypeDefault::_indexCopy_(Tensor & self, int64_t dim, const Tensor & index, const Tensor & source) const {
    AT_ERROR("_indexCopy_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_take_out(Tensor & result, const Tensor & self, const Tensor & index) const {
    AT_ERROR("_th_take_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_take(const Tensor & self, const Tensor & index) const {
    AT_ERROR("_th_take is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_put_(Tensor & self, const Tensor & index, const Tensor & source, bool accumulate) const {
    AT_ERROR("_th_put_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_index_add_(Tensor & self, int64_t dim, const Tensor & index, const Tensor & source) const {
    AT_ERROR("_th_index_add_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_index_fill_(Tensor & self, int64_t dim, const Tensor & index, Scalar value) const {
    AT_ERROR("_th_index_fill_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_index_fill_(Tensor & self, int64_t dim, const Tensor & index, const Tensor & value) const {
    AT_ERROR("_th_index_fill_ is not implemented for type ", toString());
}
Tensor TypeDefault::_th_unfold(const Tensor & self, int64_t dimension, int64_t size, int64_t step) const {
    AT_ERROR("_th_unfold is not implemented for type ", toString());
}
Tensor & TypeDefault::_range_out(Tensor & result, Scalar start, Scalar end, Scalar step) const {
    AT_ERROR("_range_out is not implemented for type ", toString());
}
Tensor TypeDefault::_range(Scalar start, Scalar end, Scalar step) const {
    AT_ERROR("_range is not implemented for type ", toString());
}
Tensor & TypeDefault::_arange_out(Tensor & result, Scalar start, Scalar end, Scalar step) const {
    AT_ERROR("_arange_out is not implemented for type ", toString());
}
Tensor TypeDefault::_arange(Scalar start, Scalar end, Scalar step) const {
    AT_ERROR("_arange is not implemented for type ", toString());
}
Tensor & TypeDefault::_arange_out(Tensor & result, Scalar end) const {
    AT_ERROR("_arange_out is not implemented for type ", toString());
}
Tensor TypeDefault::_arange(Scalar end) const {
    AT_ERROR("_arange is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_scatter_(Tensor & self, int64_t dim, const Tensor & index, const Tensor & src) const {
    AT_ERROR("_th_scatter_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_scatter_(Tensor & self, int64_t dim, const Tensor & index, Scalar value) const {
    AT_ERROR("_th_scatter_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_scatter_add_(Tensor & self, int64_t dim, const Tensor & index, const Tensor & src) const {
    AT_ERROR("_th_scatter_add_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_gather_out(Tensor & result, const Tensor & self, int64_t dim, const Tensor & index) const {
    AT_ERROR("_th_gather_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_gather(const Tensor & self, int64_t dim, const Tensor & index) const {
    AT_ERROR("_th_gather is not implemented for type ", toString());
}
void* TypeDefault::data_ptr(const Tensor & self) const {
    AT_ERROR("data_ptr is not implemented for type ", toString());
}
bool TypeDefault::_th_equal(const Tensor & self, const Tensor & other) const {
    AT_ERROR("_th_equal is not implemented for type ", toString());
}
Tensor & TypeDefault::__and___out(Tensor & result, const Tensor & self, Scalar other) const {
    AT_ERROR("__and___out is not implemented for type ", toString());
}
Tensor TypeDefault::__and__(const Tensor & self, Scalar other) const {
    AT_ERROR("__and__ is not implemented for type ", toString());
}
Tensor & TypeDefault::s___and___out(Tensor & result, const Tensor & self, const Tensor & other) const {
    AT_ERROR("s___and___out is not implemented for type ", toString());
}
Tensor & TypeDefault::__and___out(Tensor & result, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(result);
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "__and___out");
    return s___and___out(result, b_self, b_other);
}
Tensor TypeDefault::s___and__(const Tensor & self, const Tensor & other) const {
    AT_ERROR("s___and__ is not implemented for type ", toString());
}
Tensor TypeDefault::__and__(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "__and__");
    return s___and__(b_self, b_other);
}
Tensor & TypeDefault::__iand__(Tensor & self, Scalar other) const {
    AT_ERROR("__iand__ is not implemented for type ", toString());
}
Tensor & TypeDefault::s___iand__(Tensor & self, const Tensor & other) const {
    AT_ERROR("s___iand__ is not implemented for type ", toString());
}
Tensor & TypeDefault::__iand__(Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_other;
    std::tie(b_other) = expand_inplace(self, other, "__iand__");
    return s___iand__(self, b_other);
}
Tensor & TypeDefault::__or___out(Tensor & result, const Tensor & self, Scalar other) const {
    AT_ERROR("__or___out is not implemented for type ", toString());
}
Tensor TypeDefault::__or__(const Tensor & self, Scalar other) const {
    AT_ERROR("__or__ is not implemented for type ", toString());
}
Tensor & TypeDefault::s___or___out(Tensor & result, const Tensor & self, const Tensor & other) const {
    AT_ERROR("s___or___out is not implemented for type ", toString());
}
Tensor & TypeDefault::__or___out(Tensor & result, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(result);
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "__or___out");
    return s___or___out(result, b_self, b_other);
}
Tensor TypeDefault::s___or__(const Tensor & self, const Tensor & other) const {
    AT_ERROR("s___or__ is not implemented for type ", toString());
}
Tensor TypeDefault::__or__(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "__or__");
    return s___or__(b_self, b_other);
}
Tensor & TypeDefault::__ior__(Tensor & self, Scalar other) const {
    AT_ERROR("__ior__ is not implemented for type ", toString());
}
Tensor & TypeDefault::s___ior__(Tensor & self, const Tensor & other) const {
    AT_ERROR("s___ior__ is not implemented for type ", toString());
}
Tensor & TypeDefault::__ior__(Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_other;
    std::tie(b_other) = expand_inplace(self, other, "__ior__");
    return s___ior__(self, b_other);
}
Tensor & TypeDefault::__xor___out(Tensor & result, const Tensor & self, Scalar other) const {
    AT_ERROR("__xor___out is not implemented for type ", toString());
}
Tensor TypeDefault::__xor__(const Tensor & self, Scalar other) const {
    AT_ERROR("__xor__ is not implemented for type ", toString());
}
Tensor & TypeDefault::s___xor___out(Tensor & result, const Tensor & self, const Tensor & other) const {
    AT_ERROR("s___xor___out is not implemented for type ", toString());
}
Tensor & TypeDefault::__xor___out(Tensor & result, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(result);
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "__xor___out");
    return s___xor___out(result, b_self, b_other);
}
Tensor TypeDefault::s___xor__(const Tensor & self, const Tensor & other) const {
    AT_ERROR("s___xor__ is not implemented for type ", toString());
}
Tensor TypeDefault::__xor__(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "__xor__");
    return s___xor__(b_self, b_other);
}
Tensor & TypeDefault::__ixor__(Tensor & self, Scalar other) const {
    AT_ERROR("__ixor__ is not implemented for type ", toString());
}
Tensor & TypeDefault::s___ixor__(Tensor & self, const Tensor & other) const {
    AT_ERROR("s___ixor__ is not implemented for type ", toString());
}
Tensor & TypeDefault::__ixor__(Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_other;
    std::tie(b_other) = expand_inplace(self, other, "__ixor__");
    return s___ixor__(self, b_other);
}
Tensor & TypeDefault::__lshift___out(Tensor & result, const Tensor & self, Scalar other) const {
    AT_ERROR("__lshift___out is not implemented for type ", toString());
}
Tensor TypeDefault::__lshift__(const Tensor & self, Scalar other) const {
    AT_ERROR("__lshift__ is not implemented for type ", toString());
}
Tensor & TypeDefault::s___lshift___out(Tensor & result, const Tensor & self, const Tensor & other) const {
    AT_ERROR("s___lshift___out is not implemented for type ", toString());
}
Tensor & TypeDefault::__lshift___out(Tensor & result, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(result);
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "__lshift___out");
    return s___lshift___out(result, b_self, b_other);
}
Tensor TypeDefault::s___lshift__(const Tensor & self, const Tensor & other) const {
    AT_ERROR("s___lshift__ is not implemented for type ", toString());
}
Tensor TypeDefault::__lshift__(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "__lshift__");
    return s___lshift__(b_self, b_other);
}
Tensor & TypeDefault::__ilshift__(Tensor & self, Scalar other) const {
    AT_ERROR("__ilshift__ is not implemented for type ", toString());
}
Tensor & TypeDefault::s___ilshift__(Tensor & self, const Tensor & other) const {
    AT_ERROR("s___ilshift__ is not implemented for type ", toString());
}
Tensor & TypeDefault::__ilshift__(Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_other;
    std::tie(b_other) = expand_inplace(self, other, "__ilshift__");
    return s___ilshift__(self, b_other);
}
Tensor & TypeDefault::__rshift___out(Tensor & result, const Tensor & self, Scalar other) const {
    AT_ERROR("__rshift___out is not implemented for type ", toString());
}
Tensor TypeDefault::__rshift__(const Tensor & self, Scalar other) const {
    AT_ERROR("__rshift__ is not implemented for type ", toString());
}
Tensor & TypeDefault::s___rshift___out(Tensor & result, const Tensor & self, const Tensor & other) const {
    AT_ERROR("s___rshift___out is not implemented for type ", toString());
}
Tensor & TypeDefault::__rshift___out(Tensor & result, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(result);
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "__rshift___out");
    return s___rshift___out(result, b_self, b_other);
}
Tensor TypeDefault::s___rshift__(const Tensor & self, const Tensor & other) const {
    AT_ERROR("s___rshift__ is not implemented for type ", toString());
}
Tensor TypeDefault::__rshift__(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "__rshift__");
    return s___rshift__(b_self, b_other);
}
Tensor & TypeDefault::__irshift__(Tensor & self, Scalar other) const {
    AT_ERROR("__irshift__ is not implemented for type ", toString());
}
Tensor & TypeDefault::s___irshift__(Tensor & self, const Tensor & other) const {
    AT_ERROR("s___irshift__ is not implemented for type ", toString());
}
Tensor & TypeDefault::__irshift__(Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_other;
    std::tie(b_other) = expand_inplace(self, other, "__irshift__");
    return s___irshift__(self, b_other);
}
Tensor & TypeDefault::_th_lt_out(Tensor & result, const Tensor & self, Scalar other) const {
    AT_ERROR("_th_lt_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_lt(const Tensor & self, Scalar other) const {
    AT_ERROR("_th_lt is not implemented for type ", toString());
}
Tensor & TypeDefault::s__th_lt_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    AT_ERROR("s__th_lt_out is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_lt_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_lt_out");
    return s__th_lt_out(result, b_self, b_other);
}
Tensor TypeDefault::s__th_lt(const Tensor & self, const Tensor & other) const {
    AT_ERROR("s__th_lt is not implemented for type ", toString());
}
Tensor TypeDefault::_th_lt(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_lt");
    return s__th_lt(b_self, b_other);
}
Tensor & TypeDefault::_th_lt_(Tensor & self, Scalar other) const {
    AT_ERROR("_th_lt_ is not implemented for type ", toString());
}
Tensor & TypeDefault::s__th_lt_(Tensor & self, const Tensor & other) const {
    AT_ERROR("s__th_lt_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_lt_(Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_other;
    std::tie(b_other) = expand_inplace(self, other, "_th_lt_");
    return s__th_lt_(self, b_other);
}
Tensor & TypeDefault::_th_gt_out(Tensor & result, const Tensor & self, Scalar other) const {
    AT_ERROR("_th_gt_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_gt(const Tensor & self, Scalar other) const {
    AT_ERROR("_th_gt is not implemented for type ", toString());
}
Tensor & TypeDefault::s__th_gt_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    AT_ERROR("s__th_gt_out is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_gt_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_gt_out");
    return s__th_gt_out(result, b_self, b_other);
}
Tensor TypeDefault::s__th_gt(const Tensor & self, const Tensor & other) const {
    AT_ERROR("s__th_gt is not implemented for type ", toString());
}
Tensor TypeDefault::_th_gt(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_gt");
    return s__th_gt(b_self, b_other);
}
Tensor & TypeDefault::_th_gt_(Tensor & self, Scalar other) const {
    AT_ERROR("_th_gt_ is not implemented for type ", toString());
}
Tensor & TypeDefault::s__th_gt_(Tensor & self, const Tensor & other) const {
    AT_ERROR("s__th_gt_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_gt_(Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_other;
    std::tie(b_other) = expand_inplace(self, other, "_th_gt_");
    return s__th_gt_(self, b_other);
}
Tensor & TypeDefault::_th_le_out(Tensor & result, const Tensor & self, Scalar other) const {
    AT_ERROR("_th_le_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_le(const Tensor & self, Scalar other) const {
    AT_ERROR("_th_le is not implemented for type ", toString());
}
Tensor & TypeDefault::s__th_le_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    AT_ERROR("s__th_le_out is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_le_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_le_out");
    return s__th_le_out(result, b_self, b_other);
}
Tensor TypeDefault::s__th_le(const Tensor & self, const Tensor & other) const {
    AT_ERROR("s__th_le is not implemented for type ", toString());
}
Tensor TypeDefault::_th_le(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_le");
    return s__th_le(b_self, b_other);
}
Tensor & TypeDefault::_th_le_(Tensor & self, Scalar other) const {
    AT_ERROR("_th_le_ is not implemented for type ", toString());
}
Tensor & TypeDefault::s__th_le_(Tensor & self, const Tensor & other) const {
    AT_ERROR("s__th_le_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_le_(Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_other;
    std::tie(b_other) = expand_inplace(self, other, "_th_le_");
    return s__th_le_(self, b_other);
}
Tensor & TypeDefault::_th_ge_out(Tensor & result, const Tensor & self, Scalar other) const {
    AT_ERROR("_th_ge_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_ge(const Tensor & self, Scalar other) const {
    AT_ERROR("_th_ge is not implemented for type ", toString());
}
Tensor & TypeDefault::s__th_ge_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    AT_ERROR("s__th_ge_out is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_ge_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_ge_out");
    return s__th_ge_out(result, b_self, b_other);
}
Tensor TypeDefault::s__th_ge(const Tensor & self, const Tensor & other) const {
    AT_ERROR("s__th_ge is not implemented for type ", toString());
}
Tensor TypeDefault::_th_ge(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_ge");
    return s__th_ge(b_self, b_other);
}
Tensor & TypeDefault::_th_ge_(Tensor & self, Scalar other) const {
    AT_ERROR("_th_ge_ is not implemented for type ", toString());
}
Tensor & TypeDefault::s__th_ge_(Tensor & self, const Tensor & other) const {
    AT_ERROR("s__th_ge_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_ge_(Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_other;
    std::tie(b_other) = expand_inplace(self, other, "_th_ge_");
    return s__th_ge_(self, b_other);
}
Tensor & TypeDefault::_th_eq_out(Tensor & result, const Tensor & self, Scalar other) const {
    AT_ERROR("_th_eq_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_eq(const Tensor & self, Scalar other) const {
    AT_ERROR("_th_eq is not implemented for type ", toString());
}
Tensor & TypeDefault::s__th_eq_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    AT_ERROR("s__th_eq_out is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_eq_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_eq_out");
    return s__th_eq_out(result, b_self, b_other);
}
Tensor TypeDefault::s__th_eq(const Tensor & self, const Tensor & other) const {
    AT_ERROR("s__th_eq is not implemented for type ", toString());
}
Tensor TypeDefault::_th_eq(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_eq");
    return s__th_eq(b_self, b_other);
}
Tensor & TypeDefault::_th_eq_(Tensor & self, Scalar other) const {
    AT_ERROR("_th_eq_ is not implemented for type ", toString());
}
Tensor & TypeDefault::s__th_eq_(Tensor & self, const Tensor & other) const {
    AT_ERROR("s__th_eq_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_eq_(Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_other;
    std::tie(b_other) = expand_inplace(self, other, "_th_eq_");
    return s__th_eq_(self, b_other);
}
Tensor & TypeDefault::_th_ne_out(Tensor & result, const Tensor & self, Scalar other) const {
    AT_ERROR("_th_ne_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_ne(const Tensor & self, Scalar other) const {
    AT_ERROR("_th_ne is not implemented for type ", toString());
}
Tensor & TypeDefault::s__th_ne_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    AT_ERROR("s__th_ne_out is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_ne_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_ne_out");
    return s__th_ne_out(result, b_self, b_other);
}
Tensor TypeDefault::s__th_ne(const Tensor & self, const Tensor & other) const {
    AT_ERROR("s__th_ne is not implemented for type ", toString());
}
Tensor TypeDefault::_th_ne(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_ne");
    return s__th_ne(b_self, b_other);
}
Tensor & TypeDefault::_th_ne_(Tensor & self, Scalar other) const {
    AT_ERROR("_th_ne_ is not implemented for type ", toString());
}
Tensor & TypeDefault::s__th_ne_(Tensor & self, const Tensor & other) const {
    AT_ERROR("s__th_ne_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_ne_(Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_other;
    std::tie(b_other) = expand_inplace(self, other, "_th_ne_");
    return s__th_ne_(self, b_other);
}
Tensor & TypeDefault::s__th_min_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    AT_ERROR("s__th_min_out is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_min_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(result);
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_min_out");
    return s__th_min_out(result, b_self, b_other);
}
Tensor TypeDefault::s__th_min(const Tensor & self, const Tensor & other) const {
    AT_ERROR("s__th_min is not implemented for type ", toString());
}
Tensor TypeDefault::_th_min(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_min");
    return s__th_min(b_self, b_other);
}
Tensor TypeDefault::_th_min(const Tensor & self) const {
    AT_ERROR("_th_min is not implemented for type ", toString());
}
std::tuple<Tensor &,Tensor &> TypeDefault::_th_min_out(Tensor & min, Tensor & min_indices, const Tensor & self, int64_t dim, bool keepdim) const {
    AT_ERROR("_th_min_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::_th_min(const Tensor & self, int64_t dim, bool keepdim) const {
    AT_ERROR("_th_min is not implemented for type ", toString());
}
Tensor & TypeDefault::s__th_max_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    AT_ERROR("s__th_max_out is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_max_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(result);
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_max_out");
    return s__th_max_out(result, b_self, b_other);
}
Tensor TypeDefault::s__th_max(const Tensor & self, const Tensor & other) const {
    AT_ERROR("s__th_max is not implemented for type ", toString());
}
Tensor TypeDefault::_th_max(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_max");
    return s__th_max(b_self, b_other);
}
Tensor TypeDefault::_th_max(const Tensor & self) const {
    AT_ERROR("_th_max is not implemented for type ", toString());
}
std::tuple<Tensor &,Tensor &> TypeDefault::_th_max_out(Tensor & max, Tensor & max_indices, const Tensor & self, int64_t dim, bool keepdim) const {
    AT_ERROR("_th_max_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::_th_max(const Tensor & self, int64_t dim, bool keepdim) const {
    AT_ERROR("_th_max is not implemented for type ", toString());
}
std::tuple<Tensor &,Tensor &> TypeDefault::_th_kthvalue_out(Tensor & values, Tensor & indices, const Tensor & self, int64_t k, int64_t dim, bool keepdim) const {
    AT_ERROR("_th_kthvalue_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::_th_kthvalue(const Tensor & self, int64_t k, int64_t dim, bool keepdim) const {
    AT_ERROR("_th_kthvalue is not implemented for type ", toString());
}
std::tuple<Tensor &,Tensor &> TypeDefault::_th_mode_out(Tensor & values, Tensor & indices, const Tensor & self, int64_t dim, bool keepdim) const {
    AT_ERROR("_th_mode_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::_th_mode(const Tensor & self, int64_t dim, bool keepdim) const {
    AT_ERROR("_th_mode is not implemented for type ", toString());
}
Tensor TypeDefault::_th_median(const Tensor & self) const {
    AT_ERROR("_th_median is not implemented for type ", toString());
}
std::tuple<Tensor &,Tensor &> TypeDefault::_th_median_out(Tensor & values, Tensor & indices, const Tensor & self, int64_t dim, bool keepdim) const {
    AT_ERROR("_th_median_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::_th_median(const Tensor & self, int64_t dim, bool keepdim) const {
    AT_ERROR("_th_median is not implemented for type ", toString());
}
std::tuple<Tensor &,Tensor &> TypeDefault::_th_sort_out(Tensor & values, Tensor & indices, const Tensor & self, int64_t dim, bool descending) const {
    AT_ERROR("_th_sort_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::_th_sort(const Tensor & self, int64_t dim, bool descending) const {
    AT_ERROR("_th_sort is not implemented for type ", toString());
}
std::tuple<Tensor &,Tensor &> TypeDefault::_th_topk_out(Tensor & values, Tensor & indices, const Tensor & self, int64_t k, int64_t dim, bool largest, bool sorted) const {
    AT_ERROR("_th_topk_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::_th_topk(const Tensor & self, int64_t k, int64_t dim, bool largest, bool sorted) const {
    AT_ERROR("_th_topk is not implemented for type ", toString());
}
Tensor TypeDefault::_th_all(const Tensor & self) const {
    AT_ERROR("_th_all is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_all_out(Tensor & result, const Tensor & self, int64_t dim, bool keepdim) const {
    AT_ERROR("_th_all_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_all(const Tensor & self, int64_t dim, bool keepdim) const {
    AT_ERROR("_th_all is not implemented for type ", toString());
}
Tensor TypeDefault::_th_any(const Tensor & self) const {
    AT_ERROR("_th_any is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_any_out(Tensor & result, const Tensor & self, int64_t dim, bool keepdim) const {
    AT_ERROR("_th_any_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_any(const Tensor & self, int64_t dim, bool keepdim) const {
    AT_ERROR("_th_any is not implemented for type ", toString());
}
Tensor & TypeDefault::_abs_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("_abs_out is not implemented for type ", toString());
}
Tensor TypeDefault::_abs(const Tensor & self) const {
    AT_ERROR("_abs is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_sigmoid_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("_th_sigmoid_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_sigmoid(const Tensor & self) const {
    AT_ERROR("_th_sigmoid is not implemented for type ", toString());
}
Tensor & TypeDefault::_log_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("_log_out is not implemented for type ", toString());
}
Tensor TypeDefault::_log(const Tensor & self) const {
    AT_ERROR("_log is not implemented for type ", toString());
}
Tensor & TypeDefault::_log10_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("_log10_out is not implemented for type ", toString());
}
Tensor TypeDefault::_log10(const Tensor & self) const {
    AT_ERROR("_log10 is not implemented for type ", toString());
}
Tensor & TypeDefault::_log1p_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("_log1p_out is not implemented for type ", toString());
}
Tensor TypeDefault::_log1p(const Tensor & self) const {
    AT_ERROR("_log1p is not implemented for type ", toString());
}
Tensor & TypeDefault::_log2_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("_log2_out is not implemented for type ", toString());
}
Tensor TypeDefault::_log2(const Tensor & self) const {
    AT_ERROR("_log2 is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_lgamma_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("_th_lgamma_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_lgamma(const Tensor & self) const {
    AT_ERROR("_th_lgamma is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_lgamma_(Tensor & self) const {
    AT_ERROR("_th_lgamma_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_digamma_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("_th_digamma_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_digamma(const Tensor & self) const {
    AT_ERROR("_th_digamma is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_digamma_(Tensor & self) const {
    AT_ERROR("_th_digamma_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_polygamma_out(Tensor & result, int64_t n, const Tensor & self) const {
    AT_ERROR("_th_polygamma_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_polygamma(int64_t n, const Tensor & self) const {
    AT_ERROR("_th_polygamma is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_polygamma_(Tensor & self, int64_t n) const {
    AT_ERROR("_th_polygamma_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_exp_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("_exp_out is not implemented for type ", toString());
}
Tensor TypeDefault::_exp(const Tensor & self) const {
    AT_ERROR("_exp is not implemented for type ", toString());
}
Tensor & TypeDefault::_expm1_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("_expm1_out is not implemented for type ", toString());
}
Tensor TypeDefault::_expm1(const Tensor & self) const {
    AT_ERROR("_expm1 is not implemented for type ", toString());
}
Tensor & TypeDefault::_cos_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("_cos_out is not implemented for type ", toString());
}
Tensor TypeDefault::_cos(const Tensor & self) const {
    AT_ERROR("_cos is not implemented for type ", toString());
}
Tensor & TypeDefault::_acos_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("_acos_out is not implemented for type ", toString());
}
Tensor TypeDefault::_acos(const Tensor & self) const {
    AT_ERROR("_acos is not implemented for type ", toString());
}
Tensor & TypeDefault::_cosh_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("_cosh_out is not implemented for type ", toString());
}
Tensor TypeDefault::_cosh(const Tensor & self) const {
    AT_ERROR("_cosh is not implemented for type ", toString());
}
Tensor & TypeDefault::_sin_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("_sin_out is not implemented for type ", toString());
}
Tensor TypeDefault::_sin(const Tensor & self) const {
    AT_ERROR("_sin is not implemented for type ", toString());
}
Tensor & TypeDefault::_asin_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("_asin_out is not implemented for type ", toString());
}
Tensor TypeDefault::_asin(const Tensor & self) const {
    AT_ERROR("_asin is not implemented for type ", toString());
}
Tensor & TypeDefault::_sinh_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("_sinh_out is not implemented for type ", toString());
}
Tensor TypeDefault::_sinh(const Tensor & self) const {
    AT_ERROR("_sinh is not implemented for type ", toString());
}
Tensor & TypeDefault::_tan_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("_tan_out is not implemented for type ", toString());
}
Tensor TypeDefault::_tan(const Tensor & self) const {
    AT_ERROR("_tan is not implemented for type ", toString());
}
Tensor & TypeDefault::_atan_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("_atan_out is not implemented for type ", toString());
}
Tensor TypeDefault::_atan(const Tensor & self) const {
    AT_ERROR("_atan is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_tanh_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("_th_tanh_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_tanh(const Tensor & self) const {
    AT_ERROR("_th_tanh is not implemented for type ", toString());
}
Tensor & TypeDefault::_erf_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("_erf_out is not implemented for type ", toString());
}
Tensor TypeDefault::_erf(const Tensor & self) const {
    AT_ERROR("_erf is not implemented for type ", toString());
}
Tensor & TypeDefault::_erfc_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("_erfc_out is not implemented for type ", toString());
}
Tensor TypeDefault::_erfc(const Tensor & self) const {
    AT_ERROR("_erfc is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_erfinv_(Tensor & self) const {
    AT_ERROR("_th_erfinv_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_erfinv_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("_th_erfinv_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_erfinv(const Tensor & self) const {
    AT_ERROR("_th_erfinv is not implemented for type ", toString());
}
Tensor & TypeDefault::_sqrt_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("_sqrt_out is not implemented for type ", toString());
}
Tensor TypeDefault::_sqrt(const Tensor & self) const {
    AT_ERROR("_sqrt is not implemented for type ", toString());
}
Tensor & TypeDefault::_rsqrt_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("_rsqrt_out is not implemented for type ", toString());
}
Tensor TypeDefault::_rsqrt(const Tensor & self) const {
    AT_ERROR("_rsqrt is not implemented for type ", toString());
}
Tensor & TypeDefault::_ceil_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("_ceil_out is not implemented for type ", toString());
}
Tensor TypeDefault::_ceil(const Tensor & self) const {
    AT_ERROR("_ceil is not implemented for type ", toString());
}
Tensor & TypeDefault::_floor_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("_floor_out is not implemented for type ", toString());
}
Tensor TypeDefault::_floor(const Tensor & self) const {
    AT_ERROR("_floor is not implemented for type ", toString());
}
Tensor & TypeDefault::_round_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("_round_out is not implemented for type ", toString());
}
Tensor TypeDefault::_round(const Tensor & self) const {
    AT_ERROR("_round is not implemented for type ", toString());
}
Tensor & TypeDefault::_trunc_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("_trunc_out is not implemented for type ", toString());
}
Tensor TypeDefault::_trunc(const Tensor & self) const {
    AT_ERROR("_trunc is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_frac_(Tensor & self) const {
    AT_ERROR("_th_frac_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_frac_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("_th_frac_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_frac(const Tensor & self) const {
    AT_ERROR("_th_frac is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_var_out(Tensor & result, const Tensor & self, int64_t dim, bool unbiased, bool keepdim) const {
    AT_ERROR("_th_var_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_var(const Tensor & self, int64_t dim, bool unbiased, bool keepdim) const {
    AT_ERROR("_th_var is not implemented for type ", toString());
}
Tensor TypeDefault::_th_var(const Tensor & self, bool unbiased) const {
    AT_ERROR("_th_var is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_std_out(Tensor & result, const Tensor & self, int64_t dim, bool unbiased, bool keepdim) const {
    AT_ERROR("_th_std_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_std(const Tensor & self, int64_t dim, bool unbiased, bool keepdim) const {
    AT_ERROR("_th_std is not implemented for type ", toString());
}
Tensor TypeDefault::_th_std(const Tensor & self, bool unbiased) const {
    AT_ERROR("_th_std is not implemented for type ", toString());
}
Tensor TypeDefault::_th_norm(const Tensor & self, Scalar p) const {
    AT_ERROR("_th_norm is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_norm_out(Tensor & result, const Tensor & self, Scalar p, int64_t dim, bool keepdim) const {
    AT_ERROR("_th_norm_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_norm(const Tensor & self, Scalar p, int64_t dim, bool keepdim) const {
    AT_ERROR("_th_norm is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_renorm_out(Tensor & result, const Tensor & self, Scalar p, int64_t dim, Scalar maxnorm) const {
    AT_ERROR("_th_renorm_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_renorm(const Tensor & self, Scalar p, int64_t dim, Scalar maxnorm) const {
    AT_ERROR("_th_renorm is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_renorm_(Tensor & self, Scalar p, int64_t dim, Scalar maxnorm) const {
    AT_ERROR("_th_renorm_ is not implemented for type ", toString());
}
Tensor TypeDefault::s__th_dist(const Tensor & self, const Tensor & other, Scalar p) const {
    AT_ERROR("s__th_dist is not implemented for type ", toString());
}
Tensor TypeDefault::_th_dist(const Tensor & self, const Tensor & other, Scalar p) const {
    const DeviceGuard device_guard(self);
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_dist");
    return s__th_dist(b_self, b_other, p);
}
Tensor & TypeDefault::_th_reciprocal_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("_th_reciprocal_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_reciprocal(const Tensor & self) const {
    AT_ERROR("_th_reciprocal is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_reciprocal_(Tensor & self) const {
    AT_ERROR("_th_reciprocal_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_neg_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("_th_neg_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_neg(const Tensor & self) const {
    AT_ERROR("_th_neg is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_neg_(Tensor & self) const {
    AT_ERROR("_th_neg_ is not implemented for type ", toString());
}
Tensor & TypeDefault::s__th_atan2_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    AT_ERROR("s__th_atan2_out is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_atan2_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(result);
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_atan2_out");
    return s__th_atan2_out(result, b_self, b_other);
}
Tensor TypeDefault::s__th_atan2(const Tensor & self, const Tensor & other) const {
    AT_ERROR("s__th_atan2 is not implemented for type ", toString());
}
Tensor TypeDefault::_th_atan2(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_atan2");
    return s__th_atan2(b_self, b_other);
}
Tensor & TypeDefault::s__th_atan2_(Tensor & self, const Tensor & other) const {
    AT_ERROR("s__th_atan2_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_atan2_(Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_other;
    std::tie(b_other) = expand_inplace(self, other, "_th_atan2_");
    return s__th_atan2_(self, b_other);
}
Tensor & TypeDefault::_th_pow_out(Tensor & result, const Tensor & self, Scalar exponent) const {
    AT_ERROR("_th_pow_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_pow(const Tensor & self, Scalar exponent) const {
    AT_ERROR("_th_pow is not implemented for type ", toString());
}
Tensor & TypeDefault::s__th_pow_out(Tensor & result, const Tensor & self, const Tensor & exponent) const {
    AT_ERROR("s__th_pow_out is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_pow_out(Tensor & result, const Tensor & self, const Tensor & exponent) const {
    const DeviceGuard device_guard(result);
    Tensor b_self, b_exponent;
    std::tie(b_self, b_exponent) = expand_outplace(self, exponent, "_th_pow_out");
    return s__th_pow_out(result, b_self, b_exponent);
}
Tensor TypeDefault::s__th_pow(const Tensor & self, const Tensor & exponent) const {
    AT_ERROR("s__th_pow is not implemented for type ", toString());
}
Tensor TypeDefault::_th_pow(const Tensor & self, const Tensor & exponent) const {
    const DeviceGuard device_guard(self);
    Tensor b_self, b_exponent;
    std::tie(b_self, b_exponent) = expand_outplace(self, exponent, "_th_pow");
    return s__th_pow(b_self, b_exponent);
}
Tensor & TypeDefault::_th_pow_out(Tensor & result, Scalar self, const Tensor & exponent) const {
    AT_ERROR("_th_pow_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_pow(Scalar self, const Tensor & exponent) const {
    AT_ERROR("_th_pow is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_pow_(Tensor & self, Scalar exponent) const {
    AT_ERROR("_th_pow_ is not implemented for type ", toString());
}
Tensor & TypeDefault::s__th_pow_(Tensor & self, const Tensor & exponent) const {
    AT_ERROR("s__th_pow_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_pow_(Tensor & self, const Tensor & exponent) const {
    const DeviceGuard device_guard(self);
    Tensor b_exponent;
    std::tie(b_exponent) = expand_inplace(self, exponent, "_th_pow_");
    return s__th_pow_(self, b_exponent);
}
Tensor & TypeDefault::s__th_lerp_out(Tensor & result, const Tensor & self, const Tensor & end, Scalar weight) const {
    AT_ERROR("s__th_lerp_out is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_lerp_out(Tensor & result, const Tensor & self, const Tensor & end, Scalar weight) const {
    const DeviceGuard device_guard(result);
    Tensor b_self, b_end;
    std::tie(b_self, b_end) = expand_outplace(self, end, "_th_lerp_out");
    return s__th_lerp_out(result, b_self, b_end, weight);
}
Tensor TypeDefault::s__th_lerp(const Tensor & self, const Tensor & end, Scalar weight) const {
    AT_ERROR("s__th_lerp is not implemented for type ", toString());
}
Tensor TypeDefault::_th_lerp(const Tensor & self, const Tensor & end, Scalar weight) const {
    const DeviceGuard device_guard(self);
    Tensor b_self, b_end;
    std::tie(b_self, b_end) = expand_outplace(self, end, "_th_lerp");
    return s__th_lerp(b_self, b_end, weight);
}
Tensor & TypeDefault::s__th_lerp_(Tensor & self, const Tensor & end, Scalar weight) const {
    AT_ERROR("s__th_lerp_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_lerp_(Tensor & self, const Tensor & end, Scalar weight) const {
    const DeviceGuard device_guard(self);
    Tensor b_end;
    std::tie(b_end) = expand_inplace(self, end, "_th_lerp_");
    return s__th_lerp_(self, b_end, weight);
}
Tensor & TypeDefault::_linspace_out(Tensor & result, Scalar start, Scalar end, int64_t steps) const {
    AT_ERROR("_linspace_out is not implemented for type ", toString());
}
Tensor TypeDefault::_linspace(Scalar start, Scalar end, int64_t steps) const {
    AT_ERROR("_linspace is not implemented for type ", toString());
}
Tensor & TypeDefault::_logspace_out(Tensor & result, Scalar start, Scalar end, int64_t steps) const {
    AT_ERROR("_logspace_out is not implemented for type ", toString());
}
Tensor TypeDefault::_logspace(Scalar start, Scalar end, int64_t steps) const {
    AT_ERROR("_logspace is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_histc_out(Tensor & result, const Tensor & self, int64_t bins, Scalar min, Scalar max) const {
    AT_ERROR("_th_histc_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_histc(const Tensor & self, int64_t bins, Scalar min, Scalar max) const {
    AT_ERROR("_th_histc is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_zero_(Tensor & self) const {
    AT_ERROR("_th_zero_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_cumsum_out(Tensor & result, const Tensor & self, int64_t dim) const {
    AT_ERROR("_cumsum_out is not implemented for type ", toString());
}
Tensor TypeDefault::_cumsum(const Tensor & self, int64_t dim) const {
    AT_ERROR("_cumsum is not implemented for type ", toString());
}
Tensor & TypeDefault::_cumprod_out(Tensor & result, const Tensor & self, int64_t dim) const {
    AT_ERROR("_cumprod_out is not implemented for type ", toString());
}
Tensor TypeDefault::_cumprod(const Tensor & self, int64_t dim) const {
    AT_ERROR("_cumprod is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_sign_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("_th_sign_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_sign(const Tensor & self) const {
    AT_ERROR("_th_sign is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_sign_(Tensor & self) const {
    AT_ERROR("_th_sign_ is not implemented for type ", toString());
}
Tensor TypeDefault::_th_trace(const Tensor & self) const {
    AT_ERROR("_th_trace is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_fmod_out(Tensor & result, const Tensor & self, Scalar other) const {
    AT_ERROR("_th_fmod_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_fmod(const Tensor & self, Scalar other) const {
    AT_ERROR("_th_fmod is not implemented for type ", toString());
}
Tensor & TypeDefault::s__th_fmod_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    AT_ERROR("s__th_fmod_out is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_fmod_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(result);
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_fmod_out");
    return s__th_fmod_out(result, b_self, b_other);
}
Tensor TypeDefault::s__th_fmod(const Tensor & self, const Tensor & other) const {
    AT_ERROR("s__th_fmod is not implemented for type ", toString());
}
Tensor TypeDefault::_th_fmod(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_fmod");
    return s__th_fmod(b_self, b_other);
}
Tensor & TypeDefault::_th_fmod_(Tensor & self, Scalar other) const {
    AT_ERROR("_th_fmod_ is not implemented for type ", toString());
}
Tensor & TypeDefault::s__th_fmod_(Tensor & self, const Tensor & other) const {
    AT_ERROR("s__th_fmod_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_fmod_(Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_other;
    std::tie(b_other) = expand_inplace(self, other, "_th_fmod_");
    return s__th_fmod_(self, b_other);
}
Tensor & TypeDefault::_th_remainder_out(Tensor & result, const Tensor & self, Scalar other) const {
    AT_ERROR("_th_remainder_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_remainder(const Tensor & self, Scalar other) const {
    AT_ERROR("_th_remainder is not implemented for type ", toString());
}
Tensor & TypeDefault::s__th_remainder_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    AT_ERROR("s__th_remainder_out is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_remainder_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(result);
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_remainder_out");
    return s__th_remainder_out(result, b_self, b_other);
}
Tensor TypeDefault::s__th_remainder(const Tensor & self, const Tensor & other) const {
    AT_ERROR("s__th_remainder is not implemented for type ", toString());
}
Tensor TypeDefault::_th_remainder(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_remainder");
    return s__th_remainder(b_self, b_other);
}
Tensor & TypeDefault::_th_remainder_(Tensor & self, Scalar other) const {
    AT_ERROR("_th_remainder_ is not implemented for type ", toString());
}
Tensor & TypeDefault::s__th_remainder_(Tensor & self, const Tensor & other) const {
    AT_ERROR("s__th_remainder_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_remainder_(Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    Tensor b_other;
    std::tie(b_other) = expand_inplace(self, other, "_th_remainder_");
    return s__th_remainder_(self, b_other);
}
Tensor & TypeDefault::_th_clamp_out(Tensor & result, const Tensor & self, Scalar min, Scalar max) const {
    AT_ERROR("_th_clamp_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_clamp(const Tensor & self, Scalar min, Scalar max) const {
    AT_ERROR("_th_clamp is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_clamp_min_out(Tensor & result, const Tensor & self, Scalar min) const {
    AT_ERROR("_th_clamp_min_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_clamp_min(const Tensor & self, Scalar min) const {
    AT_ERROR("_th_clamp_min is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_clamp_max_out(Tensor & result, const Tensor & self, Scalar max) const {
    AT_ERROR("_th_clamp_max_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_clamp_max(const Tensor & self, Scalar max) const {
    AT_ERROR("_th_clamp_max is not implemented for type ", toString());
}
Tensor TypeDefault::_dot(const Tensor & self, const Tensor & tensor) const {
    AT_ERROR("_dot is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_tril_out(Tensor & result, const Tensor & self, int64_t diagonal) const {
    AT_ERROR("_th_tril_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_tril(const Tensor & self, int64_t diagonal) const {
    AT_ERROR("_th_tril is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_tril_(Tensor & self, int64_t diagonal) const {
    AT_ERROR("_th_tril_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_triu_out(Tensor & result, const Tensor & self, int64_t diagonal) const {
    AT_ERROR("_th_triu_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_triu(const Tensor & self, int64_t diagonal) const {
    AT_ERROR("_th_triu is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_triu_(Tensor & self, int64_t diagonal) const {
    AT_ERROR("_th_triu_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_cross_out(Tensor & result, const Tensor & self, const Tensor & other, int64_t dim) const {
    AT_ERROR("_th_cross_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_cross(const Tensor & self, const Tensor & other, int64_t dim) const {
    AT_ERROR("_th_cross is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_diag_out(Tensor & result, const Tensor & self, int64_t diagonal) const {
    AT_ERROR("_th_diag_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_diag(const Tensor & self, int64_t diagonal) const {
    AT_ERROR("_th_diag is not implemented for type ", toString());
}
Tensor & TypeDefault::s_th_addmm_out(Tensor & result, const Tensor & self, const Tensor & mat1, const Tensor & mat2, Scalar beta, Scalar alpha) const {
    AT_ERROR("s_th_addmm_out is not implemented for type ", toString());
}
Tensor & TypeDefault::th_addmm_out(Tensor & result, const Tensor & self, const Tensor & mat1, const Tensor & mat2, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(result);
    Tensor b_self;
    std::tie(b_self) = expand_size(self, {mat1.size(0),mat2.size(1)}, "th_addmm_out");
    return s_th_addmm_out(result, b_self, mat1, mat2, beta, alpha);
}
Tensor TypeDefault::s_th_addmm(const Tensor & self, const Tensor & mat1, const Tensor & mat2, Scalar beta, Scalar alpha) const {
    AT_ERROR("s_th_addmm is not implemented for type ", toString());
}
Tensor TypeDefault::th_addmm(const Tensor & self, const Tensor & mat1, const Tensor & mat2, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(self);
    Tensor b_self;
    std::tie(b_self) = expand_size(self, {mat1.size(0),mat2.size(1)}, "th_addmm");
    return s_th_addmm(b_self, mat1, mat2, beta, alpha);
}
Tensor & TypeDefault::th_addmm_(Tensor & self, const Tensor & mat1, const Tensor & mat2, Scalar beta, Scalar alpha) const {
    AT_ERROR("th_addmm_ is not implemented for type ", toString());
}
Tensor & TypeDefault::s__addmv_out(Tensor & result, const Tensor & self, const Tensor & mat, const Tensor & vec, Scalar beta, Scalar alpha) const {
    AT_ERROR("s__addmv_out is not implemented for type ", toString());
}
Tensor & TypeDefault::_addmv_out(Tensor & result, const Tensor & self, const Tensor & mat, const Tensor & vec, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(result);
    Tensor b_self;
    std::tie(b_self) = expand_size(self, {mat.size(0)}, "_addmv_out");
    return s__addmv_out(result, b_self, mat, vec, beta, alpha);
}
Tensor TypeDefault::s__addmv(const Tensor & self, const Tensor & mat, const Tensor & vec, Scalar beta, Scalar alpha) const {
    AT_ERROR("s__addmv is not implemented for type ", toString());
}
Tensor TypeDefault::_addmv(const Tensor & self, const Tensor & mat, const Tensor & vec, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(self);
    Tensor b_self;
    std::tie(b_self) = expand_size(self, {mat.size(0)}, "_addmv");
    return s__addmv(b_self, mat, vec, beta, alpha);
}
Tensor & TypeDefault::_addmv_(Tensor & self, const Tensor & mat, const Tensor & vec, Scalar beta, Scalar alpha) const {
    AT_ERROR("_addmv_ is not implemented for type ", toString());
}
Tensor & TypeDefault::s__addr_out(Tensor & result, const Tensor & self, const Tensor & vec1, const Tensor & vec2, Scalar beta, Scalar alpha) const {
    AT_ERROR("s__addr_out is not implemented for type ", toString());
}
Tensor & TypeDefault::_addr_out(Tensor & result, const Tensor & self, const Tensor & vec1, const Tensor & vec2, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(result);
    Tensor b_self;
    std::tie(b_self) = expand_size(self, {vec1.size(0),vec2.size(0)}, "_addr_out");
    return s__addr_out(result, b_self, vec1, vec2, beta, alpha);
}
Tensor TypeDefault::s__addr(const Tensor & self, const Tensor & vec1, const Tensor & vec2, Scalar beta, Scalar alpha) const {
    AT_ERROR("s__addr is not implemented for type ", toString());
}
Tensor TypeDefault::_addr(const Tensor & self, const Tensor & vec1, const Tensor & vec2, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(self);
    Tensor b_self;
    std::tie(b_self) = expand_size(self, {vec1.size(0),vec2.size(0)}, "_addr");
    return s__addr(b_self, vec1, vec2, beta, alpha);
}
Tensor & TypeDefault::_addr_(Tensor & self, const Tensor & vec1, const Tensor & vec2, Scalar beta, Scalar alpha) const {
    AT_ERROR("_addr_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_ger_out(Tensor & result, const Tensor & self, const Tensor & vec2) const {
    AT_ERROR("_ger_out is not implemented for type ", toString());
}
Tensor TypeDefault::_ger(const Tensor & self, const Tensor & vec2) const {
    AT_ERROR("_ger is not implemented for type ", toString());
}
Tensor & TypeDefault::_mv_out(Tensor & result, const Tensor & self, const Tensor & vec) const {
    AT_ERROR("_mv_out is not implemented for type ", toString());
}
Tensor TypeDefault::_mv(const Tensor & self, const Tensor & vec) const {
    AT_ERROR("_mv is not implemented for type ", toString());
}
Tensor & TypeDefault::_mm_out(Tensor & result, const Tensor & self, const Tensor & mat2) const {
    AT_ERROR("_mm_out is not implemented for type ", toString());
}
Tensor TypeDefault::_mm(const Tensor & self, const Tensor & mat2) const {
    AT_ERROR("_mm is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_bmm_out(Tensor & result, const Tensor & self, const Tensor & mat2) const {
    AT_ERROR("_th_bmm_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_bmm(const Tensor & self, const Tensor & mat2) const {
    AT_ERROR("_th_bmm is not implemented for type ", toString());
}
Tensor & TypeDefault::s_addbmm_out(Tensor & result, const Tensor & self, const Tensor & batch1, const Tensor & batch2, Scalar beta, Scalar alpha) const {
    AT_ERROR("s_addbmm_out is not implemented for type ", toString());
}
Tensor & TypeDefault::addbmm_out(Tensor & result, const Tensor & self, const Tensor & batch1, const Tensor & batch2, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(result);
    Tensor b_self;
    std::tie(b_self) = expand_size(self, {batch1.size(1),batch2.size(2)}, "addbmm_out");
    return s_addbmm_out(result, b_self, batch1, batch2, beta, alpha);
}
Tensor TypeDefault::s_addbmm(const Tensor & self, const Tensor & batch1, const Tensor & batch2, Scalar beta, Scalar alpha) const {
    AT_ERROR("s_addbmm is not implemented for type ", toString());
}
Tensor TypeDefault::addbmm(const Tensor & self, const Tensor & batch1, const Tensor & batch2, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(self);
    Tensor b_self;
    std::tie(b_self) = expand_size(self, {batch1.size(1),batch2.size(2)}, "addbmm");
    return s_addbmm(b_self, batch1, batch2, beta, alpha);
}
Tensor & TypeDefault::_th_addbmm_(Tensor & self, const Tensor & batch1, const Tensor & batch2, Scalar beta, Scalar alpha) const {
    AT_ERROR("_th_addbmm_ is not implemented for type ", toString());
}
Tensor & TypeDefault::s__th_baddbmm_out(Tensor & result, const Tensor & self, const Tensor & batch1, const Tensor & batch2, Scalar beta, Scalar alpha) const {
    AT_ERROR("s__th_baddbmm_out is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_baddbmm_out(Tensor & result, const Tensor & self, const Tensor & batch1, const Tensor & batch2, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(result);
    Tensor b_self;
    std::tie(b_self) = expand_size(self, {batch1.size(0),batch1.size(1),batch2.size(2)}, "_th_baddbmm_out");
    return s__th_baddbmm_out(result, b_self, batch1, batch2, beta, alpha);
}
Tensor TypeDefault::s__th_baddbmm(const Tensor & self, const Tensor & batch1, const Tensor & batch2, Scalar beta, Scalar alpha) const {
    AT_ERROR("s__th_baddbmm is not implemented for type ", toString());
}
Tensor TypeDefault::_th_baddbmm(const Tensor & self, const Tensor & batch1, const Tensor & batch2, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(self);
    Tensor b_self;
    std::tie(b_self) = expand_size(self, {batch1.size(0),batch1.size(1),batch2.size(2)}, "_th_baddbmm");
    return s__th_baddbmm(b_self, batch1, batch2, beta, alpha);
}
Tensor & TypeDefault::s__th_addcmul_out(Tensor & result, const Tensor & self, const Tensor & tensor1, const Tensor & tensor2, Scalar value) const {
    AT_ERROR("s__th_addcmul_out is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_addcmul_out(Tensor & result, const Tensor & self, const Tensor & tensor1, const Tensor & tensor2, Scalar value) const {
    const DeviceGuard device_guard(result);
    Tensor b_self, b_tensor1, b_tensor2;
    std::tie(b_self, b_tensor1, b_tensor2) = expand_outplace(self, tensor1, tensor2, "_th_addcmul_out");
    return s__th_addcmul_out(result, b_self, b_tensor1, b_tensor2, value);
}
Tensor TypeDefault::s__th_addcmul(const Tensor & self, const Tensor & tensor1, const Tensor & tensor2, Scalar value) const {
    AT_ERROR("s__th_addcmul is not implemented for type ", toString());
}
Tensor TypeDefault::_th_addcmul(const Tensor & self, const Tensor & tensor1, const Tensor & tensor2, Scalar value) const {
    const DeviceGuard device_guard(self);
    Tensor b_self, b_tensor1, b_tensor2;
    std::tie(b_self, b_tensor1, b_tensor2) = expand_outplace(self, tensor1, tensor2, "_th_addcmul");
    return s__th_addcmul(b_self, b_tensor1, b_tensor2, value);
}
Tensor & TypeDefault::s__th_addcmul_(Tensor & self, const Tensor & tensor1, const Tensor & tensor2, Scalar value) const {
    AT_ERROR("s__th_addcmul_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_addcmul_(Tensor & self, const Tensor & tensor1, const Tensor & tensor2, Scalar value) const {
    const DeviceGuard device_guard(self);
    Tensor b_tensor1, b_tensor2;
    std::tie(b_tensor1, b_tensor2) = expand_inplace(self, tensor1, tensor2, "_th_addcmul_");
    return s__th_addcmul_(self, b_tensor1, b_tensor2, value);
}
Tensor & TypeDefault::s__th_addcdiv_out(Tensor & result, const Tensor & self, const Tensor & tensor1, const Tensor & tensor2, Scalar value) const {
    AT_ERROR("s__th_addcdiv_out is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_addcdiv_out(Tensor & result, const Tensor & self, const Tensor & tensor1, const Tensor & tensor2, Scalar value) const {
    const DeviceGuard device_guard(result);
    Tensor b_self, b_tensor1, b_tensor2;
    std::tie(b_self, b_tensor1, b_tensor2) = expand_outplace(self, tensor1, tensor2, "_th_addcdiv_out");
    return s__th_addcdiv_out(result, b_self, b_tensor1, b_tensor2, value);
}
Tensor TypeDefault::s__th_addcdiv(const Tensor & self, const Tensor & tensor1, const Tensor & tensor2, Scalar value) const {
    AT_ERROR("s__th_addcdiv is not implemented for type ", toString());
}
Tensor TypeDefault::_th_addcdiv(const Tensor & self, const Tensor & tensor1, const Tensor & tensor2, Scalar value) const {
    const DeviceGuard device_guard(self);
    Tensor b_self, b_tensor1, b_tensor2;
    std::tie(b_self, b_tensor1, b_tensor2) = expand_outplace(self, tensor1, tensor2, "_th_addcdiv");
    return s__th_addcdiv(b_self, b_tensor1, b_tensor2, value);
}
Tensor & TypeDefault::s__th_addcdiv_(Tensor & self, const Tensor & tensor1, const Tensor & tensor2, Scalar value) const {
    AT_ERROR("s__th_addcdiv_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_addcdiv_(Tensor & self, const Tensor & tensor1, const Tensor & tensor2, Scalar value) const {
    const DeviceGuard device_guard(self);
    Tensor b_tensor1, b_tensor2;
    std::tie(b_tensor1, b_tensor2) = expand_inplace(self, tensor1, tensor2, "_th_addcdiv_");
    return s__th_addcdiv_(self, b_tensor1, b_tensor2, value);
}
std::tuple<Tensor &,Tensor &> TypeDefault::_gesv_single_out(Tensor & solution, Tensor & lu, const Tensor & self, const Tensor & A) const {
    AT_ERROR("_gesv_single_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::_gesv_single(const Tensor & self, const Tensor & A) const {
    AT_ERROR("_gesv_single is not implemented for type ", toString());
}
std::tuple<Tensor &,Tensor &> TypeDefault::_th_gels_out(Tensor & res1, Tensor & res2, const Tensor & self, const Tensor & A) const {
    AT_ERROR("_th_gels_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::_th_gels(const Tensor & self, const Tensor & A) const {
    AT_ERROR("_th_gels is not implemented for type ", toString());
}
std::tuple<Tensor &,Tensor &> TypeDefault::_th_trtrs_out(Tensor & res1, Tensor & res2, const Tensor & self, const Tensor & A, bool upper, bool transpose, bool unitriangular) const {
    AT_ERROR("_th_trtrs_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::_th_trtrs(const Tensor & self, const Tensor & A, bool upper, bool transpose, bool unitriangular) const {
    AT_ERROR("_th_trtrs is not implemented for type ", toString());
}
std::tuple<Tensor &,Tensor &> TypeDefault::_th_symeig_out(Tensor & res1, Tensor & res2, const Tensor & self, bool eigenvectors, bool upper) const {
    AT_ERROR("_th_symeig_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::_th_symeig(const Tensor & self, bool eigenvectors, bool upper) const {
    AT_ERROR("_th_symeig is not implemented for type ", toString());
}
std::tuple<Tensor &,Tensor &> TypeDefault::_th_eig_out(Tensor & res1, Tensor & res2, const Tensor & self, bool eigenvectors) const {
    AT_ERROR("_th_eig_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::_th_eig(const Tensor & self, bool eigenvectors) const {
    AT_ERROR("_th_eig is not implemented for type ", toString());
}
std::tuple<Tensor &,Tensor &,Tensor &> TypeDefault::_th_svd_out(Tensor & res1, Tensor & res2, Tensor & res3, const Tensor & self, bool some, bool compute_uv) const {
    AT_ERROR("_th_svd_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor,Tensor> TypeDefault::_th_svd(const Tensor & self, bool some, bool compute_uv) const {
    AT_ERROR("_th_svd is not implemented for type ", toString());
}
Tensor & TypeDefault::_getri_out(Tensor & output, const Tensor & self) const {
    AT_ERROR("_getri_out is not implemented for type ", toString());
}
Tensor TypeDefault::_getri(const Tensor & self) const {
    AT_ERROR("_getri is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_potrf_out(Tensor & output, const Tensor & self, bool upper) const {
    AT_ERROR("_th_potrf_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_potrf(const Tensor & self, bool upper) const {
    AT_ERROR("_th_potrf is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_potrs_out(Tensor & result, const Tensor & self, const Tensor & input2, bool upper) const {
    AT_ERROR("_th_potrs_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_potrs(const Tensor & self, const Tensor & input2, bool upper) const {
    AT_ERROR("_th_potrs is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_potri_out(Tensor & output, const Tensor & self, bool upper) const {
    AT_ERROR("_th_potri_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_potri(const Tensor & self, bool upper) const {
    AT_ERROR("_th_potri is not implemented for type ", toString());
}
std::tuple<Tensor &,Tensor &> TypeDefault::_th_pstrf_out(Tensor & res1, Tensor & res2, const Tensor & self, bool upper, Scalar tol) const {
    AT_ERROR("_th_pstrf_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::_th_pstrf(const Tensor & self, bool upper, Scalar tol) const {
    AT_ERROR("_th_pstrf is not implemented for type ", toString());
}
std::tuple<Tensor &,Tensor &> TypeDefault::_th_qr_out(Tensor & res1, Tensor & res2, const Tensor & self) const {
    AT_ERROR("_th_qr_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::_th_qr(const Tensor & self) const {
    AT_ERROR("_th_qr is not implemented for type ", toString());
}
std::tuple<Tensor &,Tensor &> TypeDefault::_th_geqrf_out(Tensor & res1, Tensor & res2, const Tensor & self) const {
    AT_ERROR("_th_geqrf_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::_th_geqrf(const Tensor & self) const {
    AT_ERROR("_th_geqrf is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_orgqr_out(Tensor & result, const Tensor & self, const Tensor & input2) const {
    AT_ERROR("_th_orgqr_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_orgqr(const Tensor & self, const Tensor & input2) const {
    AT_ERROR("_th_orgqr is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_ormqr_out(Tensor & result, const Tensor & self, const Tensor & input2, const Tensor & input3, bool left, bool transpose) const {
    AT_ERROR("_th_ormqr_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_ormqr(const Tensor & self, const Tensor & input2, const Tensor & input3, bool left, bool transpose) const {
    AT_ERROR("_th_ormqr is not implemented for type ", toString());
}
std::tuple<Tensor &,Tensor &> TypeDefault::_th_btrifact_out(Tensor & result, Tensor & pivots, const Tensor & self, bool pivot) const {
    AT_ERROR("_th_btrifact_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::_th_btrifact(const Tensor & self, bool pivot) const {
    AT_ERROR("_th_btrifact is not implemented for type ", toString());
}
std::tuple<Tensor &,Tensor &,Tensor &> TypeDefault::_th_btrifact_with_info_out(Tensor & result, Tensor & pivots, Tensor & info, const Tensor & self, bool pivot) const {
    AT_ERROR("_th_btrifact_with_info_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor,Tensor> TypeDefault::_th_btrifact_with_info(const Tensor & self, bool pivot) const {
    AT_ERROR("_th_btrifact_with_info is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_btrisolve_out(Tensor & result, const Tensor & self, const Tensor & LU_data, const Tensor & LU_pivots) const {
    AT_ERROR("_th_btrisolve_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_btrisolve(const Tensor & self, const Tensor & LU_data, const Tensor & LU_pivots) const {
    AT_ERROR("_th_btrisolve is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_random_(Tensor & self, int64_t from, int64_t to, Generator * generator) const {
    AT_ERROR("_th_random_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_random_(Tensor & self, int64_t to, Generator * generator) const {
    AT_ERROR("_th_random_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_random_(Tensor & self, Generator * generator) const {
    AT_ERROR("_th_random_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_multinomial_out(Tensor & result, const Tensor & self, int64_t num_samples, bool replacement, Generator * generator) const {
    AT_ERROR("_th_multinomial_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_multinomial(const Tensor & self, int64_t num_samples, bool replacement, Generator * generator) const {
    AT_ERROR("_th_multinomial is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_uniform_(Tensor & self, double from, double to, Generator * generator) const {
    AT_ERROR("_th_uniform_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_normal_out(Tensor & output, const Tensor & mean, double std, Generator * generator) const {
    AT_ERROR("_th_normal_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_normal(const Tensor & mean, double std, Generator * generator) const {
    AT_ERROR("_th_normal is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_normal_out(Tensor & output, double mean, const Tensor & std, Generator * generator) const {
    AT_ERROR("_th_normal_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_normal(double mean, const Tensor & std, Generator * generator) const {
    AT_ERROR("_th_normal is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_normal_out(Tensor & output, const Tensor & mean, const Tensor & std, Generator * generator) const {
    AT_ERROR("_th_normal_out is not implemented for type ", toString());
}
Tensor TypeDefault::_th_normal(const Tensor & mean, const Tensor & std, Generator * generator) const {
    AT_ERROR("_th_normal is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_normal_(Tensor & self, double mean, double std, Generator * generator) const {
    AT_ERROR("_th_normal_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_cauchy_(Tensor & self, double median, double sigma, Generator * generator) const {
    AT_ERROR("_th_cauchy_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_log_normal_(Tensor & self, double mean, double std, Generator * generator) const {
    AT_ERROR("_th_log_normal_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_exponential_(Tensor & self, double lambd, Generator * generator) const {
    AT_ERROR("_th_exponential_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_th_geometric_(Tensor & self, double p, Generator * generator) const {
    AT_ERROR("_th_geometric_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_dirichlet_grad_out(Tensor & output, const Tensor & x, const Tensor & alpha, const Tensor & total) const {
    AT_ERROR("_dirichlet_grad_out is not implemented for type ", toString());
}
Tensor TypeDefault::_dirichlet_grad(const Tensor & x, const Tensor & alpha, const Tensor & total) const {
    AT_ERROR("_dirichlet_grad is not implemented for type ", toString());
}
Tensor TypeDefault::tensor(Storage storage, int64_t storageOffset, IntList size, IntList stride) const {
    AT_ERROR("tensor is not implemented for type ", toString());
}
Tensor TypeDefault::tensor(IntList size, IntList stride) const {
    AT_ERROR("tensor is not implemented for type ", toString());
}
Tensor TypeDefault::_th_alias(const Tensor & self) const {
    AT_ERROR("_th_alias is not implemented for type ", toString());
}
Tensor & TypeDefault::_copy_ignoring_overlaps_(Tensor & self, const Tensor & src) const {
    AT_ERROR("_copy_ignoring_overlaps_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_cat_out(Tensor & self, TensorList tensors, int64_t dim) const {
    AT_ERROR("_cat_out is not implemented for type ", toString());
}
Tensor TypeDefault::_cat(TensorList tensors, int64_t dim) const {
    AT_ERROR("_cat is not implemented for type ", toString());
}
Tensor & TypeDefault::binary_cross_entropy_out(Tensor & output, const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction) const {
    const DeviceGuard device_guard(output);
    return binary_cross_entropy_forward_out(output, self, target, weight, reduction);
}
Tensor TypeDefault::binary_cross_entropy(const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction) const {
    const DeviceGuard device_guard(self);
    return binary_cross_entropy_forward(self, target, weight, reduction);
}
Tensor & TypeDefault::binary_cross_entropy_forward_out(Tensor & output, const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction) const {
    AT_ERROR("binary_cross_entropy_forward_out is not implemented for type ", toString());
}
Tensor TypeDefault::binary_cross_entropy_forward(const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction) const {
    AT_ERROR("binary_cross_entropy_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::binary_cross_entropy_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction) const {
    AT_ERROR("binary_cross_entropy_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::binary_cross_entropy_backward(const Tensor & grad_output, const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction) const {
    AT_ERROR("binary_cross_entropy_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::l1_loss_out(Tensor & output, const Tensor & self, const Tensor & target, int64_t reduction) const {
    const DeviceGuard device_guard(output);
    return l1_loss_forward_out(output, self, target, reduction);
}
Tensor TypeDefault::l1_loss(const Tensor & self, const Tensor & target, int64_t reduction) const {
    const DeviceGuard device_guard(self);
    return l1_loss_forward(self, target, reduction);
}
Tensor & TypeDefault::l1_loss_forward_out(Tensor & output, const Tensor & self, const Tensor & target, int64_t reduction) const {
    AT_ERROR("l1_loss_forward_out is not implemented for type ", toString());
}
Tensor TypeDefault::l1_loss_forward(const Tensor & self, const Tensor & target, int64_t reduction) const {
    AT_ERROR("l1_loss_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::l1_loss_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, const Tensor & target, int64_t reduction) const {
    AT_ERROR("l1_loss_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::l1_loss_backward(const Tensor & grad_output, const Tensor & self, const Tensor & target, int64_t reduction) const {
    AT_ERROR("l1_loss_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::mse_loss_out(Tensor & output, const Tensor & self, const Tensor & target, int64_t reduction) const {
    const DeviceGuard device_guard(output);
    return mse_loss_forward_out(output, self, target, reduction);
}
Tensor TypeDefault::mse_loss(const Tensor & self, const Tensor & target, int64_t reduction) const {
    const DeviceGuard device_guard(self);
    return mse_loss_forward(self, target, reduction);
}
Tensor & TypeDefault::mse_loss_forward_out(Tensor & output, const Tensor & self, const Tensor & target, int64_t reduction) const {
    AT_ERROR("mse_loss_forward_out is not implemented for type ", toString());
}
Tensor TypeDefault::mse_loss_forward(const Tensor & self, const Tensor & target, int64_t reduction) const {
    AT_ERROR("mse_loss_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::mse_loss_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, const Tensor & target, int64_t reduction) const {
    AT_ERROR("mse_loss_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::mse_loss_backward(const Tensor & grad_output, const Tensor & self, const Tensor & target, int64_t reduction) const {
    AT_ERROR("mse_loss_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::multi_margin_loss_out(Tensor & output, const Tensor & self, const Tensor & target, Scalar p, Scalar margin, const Tensor & weight, int64_t reduction) const {
    const DeviceGuard device_guard(output);
    return multi_margin_loss_forward_out(output, self, target, p, margin, weight, reduction);
}
Tensor TypeDefault::multi_margin_loss(const Tensor & self, const Tensor & target, Scalar p, Scalar margin, const Tensor & weight, int64_t reduction) const {
    const DeviceGuard device_guard(self);
    return multi_margin_loss_forward(self, target, p, margin, weight, reduction);
}
Tensor & TypeDefault::multi_margin_loss_forward_out(Tensor & output, const Tensor & self, const Tensor & target, Scalar p, Scalar margin, const Tensor & weight, int64_t reduction) const {
    AT_ERROR("multi_margin_loss_forward_out is not implemented for type ", toString());
}
Tensor TypeDefault::multi_margin_loss_forward(const Tensor & self, const Tensor & target, Scalar p, Scalar margin, const Tensor & weight, int64_t reduction) const {
    AT_ERROR("multi_margin_loss_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::multi_margin_loss_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, const Tensor & target, Scalar p, Scalar margin, const Tensor & weight, int64_t reduction) const {
    AT_ERROR("multi_margin_loss_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::multi_margin_loss_backward(const Tensor & grad_output, const Tensor & self, const Tensor & target, Scalar p, Scalar margin, const Tensor & weight, int64_t reduction) const {
    AT_ERROR("multi_margin_loss_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::multilabel_margin_loss_out(Tensor & output, const Tensor & self, const Tensor & target, int64_t reduction) const {
    const DeviceGuard device_guard(output);
    Tensor is_target = at::empty({0}, this->options());
    return std::get<0>(multilabel_margin_loss_forward_out(output, is_target, self, target, reduction));
}
Tensor TypeDefault::multilabel_margin_loss(const Tensor & self, const Tensor & target, int64_t reduction) const {
    const DeviceGuard device_guard(self);
    return std::get<0>(multilabel_margin_loss_forward(self, target, reduction));
}
std::tuple<Tensor &,Tensor &> TypeDefault::multilabel_margin_loss_forward_out(Tensor & output, Tensor & is_target, const Tensor & self, const Tensor & target, int64_t reduction) const {
    AT_ERROR("multilabel_margin_loss_forward_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::multilabel_margin_loss_forward(const Tensor & self, const Tensor & target, int64_t reduction) const {
    AT_ERROR("multilabel_margin_loss_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::multilabel_margin_loss_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, const Tensor & target, int64_t reduction, const Tensor & is_target) const {
    AT_ERROR("multilabel_margin_loss_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::multilabel_margin_loss_backward(const Tensor & grad_output, const Tensor & self, const Tensor & target, int64_t reduction, const Tensor & is_target) const {
    AT_ERROR("multilabel_margin_loss_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::nll_loss_out(Tensor & output, const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction, int64_t ignore_index) const {
    const DeviceGuard device_guard(output);
    Tensor total_weight = at::empty({0}, this->options());
    return std::get<0>(nll_loss_forward_out(output, total_weight, self, target, weight, reduction, ignore_index));
}
Tensor TypeDefault::nll_loss(const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction, int64_t ignore_index) const {
    const DeviceGuard device_guard(self);
    return std::get<0>(nll_loss_forward(self, target, weight, reduction, ignore_index));
}
std::tuple<Tensor &,Tensor &> TypeDefault::nll_loss_forward_out(Tensor & output, Tensor & total_weight, const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction, int64_t ignore_index) const {
    AT_ERROR("nll_loss_forward_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::nll_loss_forward(const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction, int64_t ignore_index) const {
    AT_ERROR("nll_loss_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::nll_loss_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction, int64_t ignore_index, const Tensor & total_weight) const {
    AT_ERROR("nll_loss_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::nll_loss_backward(const Tensor & grad_output, const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction, int64_t ignore_index, const Tensor & total_weight) const {
    AT_ERROR("nll_loss_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::nll_loss2d_out(Tensor & output, const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction, int64_t ignore_index) const {
    const DeviceGuard device_guard(output);
    Tensor total_weight = at::empty({0}, this->options());
    return std::get<0>(nll_loss2d_forward_out(output, total_weight, self, target, weight, reduction, ignore_index));
}
Tensor TypeDefault::nll_loss2d(const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction, int64_t ignore_index) const {
    const DeviceGuard device_guard(self);
    return std::get<0>(nll_loss2d_forward(self, target, weight, reduction, ignore_index));
}
std::tuple<Tensor &,Tensor &> TypeDefault::nll_loss2d_forward_out(Tensor & output, Tensor & total_weight, const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction, int64_t ignore_index) const {
    AT_ERROR("nll_loss2d_forward_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::nll_loss2d_forward(const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction, int64_t ignore_index) const {
    AT_ERROR("nll_loss2d_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::nll_loss2d_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction, int64_t ignore_index, const Tensor & total_weight) const {
    AT_ERROR("nll_loss2d_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::nll_loss2d_backward(const Tensor & grad_output, const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction, int64_t ignore_index, const Tensor & total_weight) const {
    AT_ERROR("nll_loss2d_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::smooth_l1_loss_out(Tensor & output, const Tensor & self, const Tensor & target, int64_t reduction) const {
    const DeviceGuard device_guard(output);
    return smooth_l1_loss_forward_out(output, self, target, reduction);
}
Tensor TypeDefault::smooth_l1_loss(const Tensor & self, const Tensor & target, int64_t reduction) const {
    const DeviceGuard device_guard(self);
    return smooth_l1_loss_forward(self, target, reduction);
}
Tensor & TypeDefault::smooth_l1_loss_forward_out(Tensor & output, const Tensor & self, const Tensor & target, int64_t reduction) const {
    AT_ERROR("smooth_l1_loss_forward_out is not implemented for type ", toString());
}
Tensor TypeDefault::smooth_l1_loss_forward(const Tensor & self, const Tensor & target, int64_t reduction) const {
    AT_ERROR("smooth_l1_loss_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::smooth_l1_loss_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, const Tensor & target, int64_t reduction) const {
    AT_ERROR("smooth_l1_loss_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::smooth_l1_loss_backward(const Tensor & grad_output, const Tensor & self, const Tensor & target, int64_t reduction) const {
    AT_ERROR("smooth_l1_loss_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::soft_margin_loss_out(Tensor & output, const Tensor & self, const Tensor & target, int64_t reduction) const {
    const DeviceGuard device_guard(output);
    return soft_margin_loss_forward_out(output, self, target, reduction);
}
Tensor TypeDefault::soft_margin_loss(const Tensor & self, const Tensor & target, int64_t reduction) const {
    const DeviceGuard device_guard(self);
    return soft_margin_loss_forward(self, target, reduction);
}
Tensor & TypeDefault::soft_margin_loss_forward_out(Tensor & output, const Tensor & self, const Tensor & target, int64_t reduction) const {
    AT_ERROR("soft_margin_loss_forward_out is not implemented for type ", toString());
}
Tensor TypeDefault::soft_margin_loss_forward(const Tensor & self, const Tensor & target, int64_t reduction) const {
    AT_ERROR("soft_margin_loss_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::soft_margin_loss_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, const Tensor & target, int64_t reduction) const {
    AT_ERROR("soft_margin_loss_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::soft_margin_loss_backward(const Tensor & grad_output, const Tensor & self, const Tensor & target, int64_t reduction) const {
    AT_ERROR("soft_margin_loss_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::elu_out(Tensor & output, const Tensor & self, Scalar alpha, Scalar scale, Scalar input_scale) const {
    const DeviceGuard device_guard(output);
    return elu_forward_out(output, self, alpha, scale, input_scale);
}
Tensor TypeDefault::elu(const Tensor & self, Scalar alpha, Scalar scale, Scalar input_scale) const {
    const DeviceGuard device_guard(self);
    return elu_forward(self, alpha, scale, input_scale);
}
Tensor & TypeDefault::elu_forward_out(Tensor & output, const Tensor & self, Scalar alpha, Scalar scale, Scalar input_scale) const {
    AT_ERROR("elu_forward_out is not implemented for type ", toString());
}
Tensor TypeDefault::elu_forward(const Tensor & self, Scalar alpha, Scalar scale, Scalar input_scale) const {
    AT_ERROR("elu_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::elu_backward_out(Tensor & grad_input, const Tensor & grad_output, Scalar alpha, Scalar scale, Scalar input_scale, const Tensor & output) const {
    AT_ERROR("elu_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::elu_backward(const Tensor & grad_output, Scalar alpha, Scalar scale, Scalar input_scale, const Tensor & output) const {
    AT_ERROR("elu_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::elu_(Tensor & self, Scalar alpha, Scalar scale, Scalar input_scale) const {
    const DeviceGuard device_guard(self);
    return elu_forward_(self, alpha, scale, input_scale);
}
Tensor & TypeDefault::elu_forward_(Tensor & self, Scalar alpha, Scalar scale, Scalar input_scale) const {
    AT_ERROR("elu_forward_ is not implemented for type ", toString());
}
Tensor & TypeDefault::glu_out(Tensor & output, const Tensor & self, int64_t dim) const {
    const DeviceGuard device_guard(output);
    return glu_forward_out(output, self, dim);
}
Tensor TypeDefault::glu(const Tensor & self, int64_t dim) const {
    const DeviceGuard device_guard(self);
    return glu_forward(self, dim);
}
Tensor & TypeDefault::glu_forward_out(Tensor & output, const Tensor & self, int64_t dim) const {
    AT_ERROR("glu_forward_out is not implemented for type ", toString());
}
Tensor TypeDefault::glu_forward(const Tensor & self, int64_t dim) const {
    AT_ERROR("glu_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::glu_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, int64_t dim) const {
    AT_ERROR("glu_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::glu_backward(const Tensor & grad_output, const Tensor & self, int64_t dim) const {
    AT_ERROR("glu_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::hardtanh_out(Tensor & output, const Tensor & self, Scalar min_val, Scalar max_val) const {
    const DeviceGuard device_guard(output);
    return hardtanh_forward_out(output, self, min_val, max_val);
}
Tensor TypeDefault::hardtanh(const Tensor & self, Scalar min_val, Scalar max_val) const {
    const DeviceGuard device_guard(self);
    return hardtanh_forward(self, min_val, max_val);
}
Tensor & TypeDefault::hardtanh_forward_out(Tensor & output, const Tensor & self, Scalar min_val, Scalar max_val) const {
    AT_ERROR("hardtanh_forward_out is not implemented for type ", toString());
}
Tensor TypeDefault::hardtanh_forward(const Tensor & self, Scalar min_val, Scalar max_val) const {
    AT_ERROR("hardtanh_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::hardtanh_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, Scalar min_val, Scalar max_val) const {
    AT_ERROR("hardtanh_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::hardtanh_backward(const Tensor & grad_output, const Tensor & self, Scalar min_val, Scalar max_val) const {
    AT_ERROR("hardtanh_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::hardtanh_(Tensor & self, Scalar min_val, Scalar max_val) const {
    const DeviceGuard device_guard(self);
    return hardtanh_forward_(self, min_val, max_val);
}
Tensor & TypeDefault::hardtanh_forward_(Tensor & self, Scalar min_val, Scalar max_val) const {
    AT_ERROR("hardtanh_forward_ is not implemented for type ", toString());
}
Tensor & TypeDefault::leaky_relu_out(Tensor & output, const Tensor & self, Scalar negative_slope) const {
    const DeviceGuard device_guard(output);
    return leaky_relu_forward_out(output, self, negative_slope);
}
Tensor TypeDefault::leaky_relu(const Tensor & self, Scalar negative_slope) const {
    const DeviceGuard device_guard(self);
    return leaky_relu_forward(self, negative_slope);
}
Tensor & TypeDefault::leaky_relu_forward_out(Tensor & output, const Tensor & self, Scalar negative_slope) const {
    AT_ERROR("leaky_relu_forward_out is not implemented for type ", toString());
}
Tensor TypeDefault::leaky_relu_forward(const Tensor & self, Scalar negative_slope) const {
    AT_ERROR("leaky_relu_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::leaky_relu_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, Scalar negative_slope) const {
    AT_ERROR("leaky_relu_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::leaky_relu_backward(const Tensor & grad_output, const Tensor & self, Scalar negative_slope) const {
    AT_ERROR("leaky_relu_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::leaky_relu_(Tensor & self, Scalar negative_slope) const {
    const DeviceGuard device_guard(self);
    return leaky_relu_forward_(self, negative_slope);
}
Tensor & TypeDefault::leaky_relu_forward_(Tensor & self, Scalar negative_slope) const {
    AT_ERROR("leaky_relu_forward_ is not implemented for type ", toString());
}
Tensor & TypeDefault::log_sigmoid_out(Tensor & output, const Tensor & self) const {
    const DeviceGuard device_guard(output);
    Tensor buffer = at::empty({0}, this->options());
    return std::get<0>(log_sigmoid_forward_out(output, buffer, self));
}
Tensor TypeDefault::log_sigmoid(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return std::get<0>(log_sigmoid_forward(self));
}
std::tuple<Tensor &,Tensor &> TypeDefault::log_sigmoid_forward_out(Tensor & output, Tensor & buffer, const Tensor & self) const {
    AT_ERROR("log_sigmoid_forward_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::log_sigmoid_forward(const Tensor & self) const {
    AT_ERROR("log_sigmoid_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::log_sigmoid_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, const Tensor & buffer) const {
    AT_ERROR("log_sigmoid_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::log_sigmoid_backward(const Tensor & grad_output, const Tensor & self, const Tensor & buffer) const {
    AT_ERROR("log_sigmoid_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::rrelu_with_noise_out(Tensor & output, const Tensor & self, const Tensor & noise, Scalar lower, Scalar upper, bool training, Generator * generator) const {
    const DeviceGuard device_guard(output);
    return rrelu_with_noise_forward_out(output, self, noise, lower, upper, training, generator);
}
Tensor TypeDefault::rrelu_with_noise(const Tensor & self, const Tensor & noise, Scalar lower, Scalar upper, bool training, Generator * generator) const {
    const DeviceGuard device_guard(self);
    return rrelu_with_noise_forward(self, noise, lower, upper, training, generator);
}
Tensor & TypeDefault::rrelu_with_noise_forward_out(Tensor & output, const Tensor & self, const Tensor & noise, Scalar lower, Scalar upper, bool training, Generator * generator) const {
    AT_ERROR("rrelu_with_noise_forward_out is not implemented for type ", toString());
}
Tensor TypeDefault::rrelu_with_noise_forward(const Tensor & self, const Tensor & noise, Scalar lower, Scalar upper, bool training, Generator * generator) const {
    AT_ERROR("rrelu_with_noise_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::rrelu_with_noise_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, const Tensor & noise, Scalar lower, Scalar upper, bool training) const {
    AT_ERROR("rrelu_with_noise_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::rrelu_with_noise_backward(const Tensor & grad_output, const Tensor & self, const Tensor & noise, Scalar lower, Scalar upper, bool training) const {
    AT_ERROR("rrelu_with_noise_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::rrelu_with_noise_(Tensor & self, const Tensor & noise, Scalar lower, Scalar upper, bool training, Generator * generator) const {
    const DeviceGuard device_guard(self);
    return rrelu_with_noise_forward_(self, noise, lower, upper, training, generator);
}
Tensor & TypeDefault::rrelu_with_noise_forward_(Tensor & self, const Tensor & noise, Scalar lower, Scalar upper, bool training, Generator * generator) const {
    AT_ERROR("rrelu_with_noise_forward_ is not implemented for type ", toString());
}
Tensor & TypeDefault::softplus_out(Tensor & output, const Tensor & self, Scalar beta, Scalar threshold) const {
    const DeviceGuard device_guard(output);
    return softplus_forward_out(output, self, beta, threshold);
}
Tensor TypeDefault::softplus(const Tensor & self, Scalar beta, Scalar threshold) const {
    const DeviceGuard device_guard(self);
    return softplus_forward(self, beta, threshold);
}
Tensor & TypeDefault::softplus_forward_out(Tensor & output, const Tensor & self, Scalar beta, Scalar threshold) const {
    AT_ERROR("softplus_forward_out is not implemented for type ", toString());
}
Tensor TypeDefault::softplus_forward(const Tensor & self, Scalar beta, Scalar threshold) const {
    AT_ERROR("softplus_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::softplus_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, Scalar beta, Scalar threshold, const Tensor & output) const {
    AT_ERROR("softplus_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::softplus_backward(const Tensor & grad_output, const Tensor & self, Scalar beta, Scalar threshold, const Tensor & output) const {
    AT_ERROR("softplus_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::softshrink_out(Tensor & output, const Tensor & self, Scalar lambd) const {
    const DeviceGuard device_guard(output);
    return softshrink_forward_out(output, self, lambd);
}
Tensor TypeDefault::softshrink(const Tensor & self, Scalar lambd) const {
    const DeviceGuard device_guard(self);
    return softshrink_forward(self, lambd);
}
Tensor & TypeDefault::softshrink_forward_out(Tensor & output, const Tensor & self, Scalar lambd) const {
    AT_ERROR("softshrink_forward_out is not implemented for type ", toString());
}
Tensor TypeDefault::softshrink_forward(const Tensor & self, Scalar lambd) const {
    AT_ERROR("softshrink_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::softshrink_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, Scalar lambd) const {
    AT_ERROR("softshrink_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::softshrink_backward(const Tensor & grad_output, const Tensor & self, Scalar lambd) const {
    AT_ERROR("softshrink_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::threshold_out(Tensor & output, const Tensor & self, Scalar threshold, Scalar value) const {
    const DeviceGuard device_guard(output);
    return threshold_forward_out(output, self, threshold, value);
}
Tensor TypeDefault::threshold(const Tensor & self, Scalar threshold, Scalar value) const {
    const DeviceGuard device_guard(self);
    return threshold_forward(self, threshold, value);
}
Tensor & TypeDefault::threshold_forward_out(Tensor & output, const Tensor & self, Scalar threshold, Scalar value) const {
    AT_ERROR("threshold_forward_out is not implemented for type ", toString());
}
Tensor TypeDefault::threshold_forward(const Tensor & self, Scalar threshold, Scalar value) const {
    AT_ERROR("threshold_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::threshold_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, Scalar threshold, Scalar value) const {
    AT_ERROR("threshold_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::threshold_backward(const Tensor & grad_output, const Tensor & self, Scalar threshold, Scalar value) const {
    AT_ERROR("threshold_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::threshold_(Tensor & self, Scalar threshold, Scalar value) const {
    const DeviceGuard device_guard(self);
    return threshold_forward_(self, threshold, value);
}
Tensor & TypeDefault::threshold_forward_(Tensor & self, Scalar threshold, Scalar value) const {
    AT_ERROR("threshold_forward_ is not implemented for type ", toString());
}
Tensor & TypeDefault::adaptive_avg_pool2d_out(Tensor & output, const Tensor & self, IntList output_size) const {
    const DeviceGuard device_guard(output);
    return adaptive_avg_pool2d_forward_out(output, self, output_size);
}
Tensor TypeDefault::adaptive_avg_pool2d(const Tensor & self, IntList output_size) const {
    const DeviceGuard device_guard(self);
    return adaptive_avg_pool2d_forward(self, output_size);
}
Tensor & TypeDefault::adaptive_avg_pool2d_forward_out(Tensor & output, const Tensor & self, IntList output_size) const {
    AT_ERROR("adaptive_avg_pool2d_forward_out is not implemented for type ", toString());
}
Tensor TypeDefault::adaptive_avg_pool2d_forward(const Tensor & self, IntList output_size) const {
    AT_ERROR("adaptive_avg_pool2d_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::adaptive_avg_pool2d_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self) const {
    AT_ERROR("adaptive_avg_pool2d_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::adaptive_avg_pool2d_backward(const Tensor & grad_output, const Tensor & self) const {
    AT_ERROR("adaptive_avg_pool2d_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::adaptive_avg_pool3d_out(Tensor & output, const Tensor & self, IntList output_size) const {
    const DeviceGuard device_guard(output);
    return adaptive_avg_pool3d_forward_out(output, self, output_size);
}
Tensor TypeDefault::adaptive_avg_pool3d(const Tensor & self, IntList output_size) const {
    const DeviceGuard device_guard(self);
    return adaptive_avg_pool3d_forward(self, output_size);
}
Tensor & TypeDefault::adaptive_avg_pool3d_forward_out(Tensor & output, const Tensor & self, IntList output_size) const {
    AT_ERROR("adaptive_avg_pool3d_forward_out is not implemented for type ", toString());
}
Tensor TypeDefault::adaptive_avg_pool3d_forward(const Tensor & self, IntList output_size) const {
    AT_ERROR("adaptive_avg_pool3d_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::adaptive_avg_pool3d_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self) const {
    AT_ERROR("adaptive_avg_pool3d_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::adaptive_avg_pool3d_backward(const Tensor & grad_output, const Tensor & self) const {
    AT_ERROR("adaptive_avg_pool3d_backward is not implemented for type ", toString());
}
std::tuple<Tensor &,Tensor &> TypeDefault::adaptive_max_pool2d_out(Tensor & output, Tensor & indices, const Tensor & self, IntList output_size) const {
    const DeviceGuard device_guard(output);
    return adaptive_max_pool2d_forward_out(output, indices, self, output_size);
}
std::tuple<Tensor,Tensor> TypeDefault::adaptive_max_pool2d(const Tensor & self, IntList output_size) const {
    const DeviceGuard device_guard(self);
    return adaptive_max_pool2d_forward(self, output_size);
}
std::tuple<Tensor &,Tensor &> TypeDefault::adaptive_max_pool2d_forward_out(Tensor & output, Tensor & indices, const Tensor & self, IntList output_size) const {
    AT_ERROR("adaptive_max_pool2d_forward_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::adaptive_max_pool2d_forward(const Tensor & self, IntList output_size) const {
    AT_ERROR("adaptive_max_pool2d_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::adaptive_max_pool2d_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, const Tensor & indices) const {
    AT_ERROR("adaptive_max_pool2d_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::adaptive_max_pool2d_backward(const Tensor & grad_output, const Tensor & self, const Tensor & indices) const {
    AT_ERROR("adaptive_max_pool2d_backward is not implemented for type ", toString());
}
std::tuple<Tensor &,Tensor &> TypeDefault::adaptive_max_pool3d_out(Tensor & output, Tensor & indices, const Tensor & self, IntList output_size) const {
    const DeviceGuard device_guard(output);
    return adaptive_max_pool3d_forward_out(output, indices, self, output_size);
}
std::tuple<Tensor,Tensor> TypeDefault::adaptive_max_pool3d(const Tensor & self, IntList output_size) const {
    const DeviceGuard device_guard(self);
    return adaptive_max_pool3d_forward(self, output_size);
}
std::tuple<Tensor &,Tensor &> TypeDefault::adaptive_max_pool3d_forward_out(Tensor & output, Tensor & indices, const Tensor & self, IntList output_size) const {
    AT_ERROR("adaptive_max_pool3d_forward_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::adaptive_max_pool3d_forward(const Tensor & self, IntList output_size) const {
    AT_ERROR("adaptive_max_pool3d_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::adaptive_max_pool3d_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, const Tensor & indices) const {
    AT_ERROR("adaptive_max_pool3d_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::adaptive_max_pool3d_backward(const Tensor & grad_output, const Tensor & self, const Tensor & indices) const {
    AT_ERROR("adaptive_max_pool3d_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::avg_pool2d_out(Tensor & output, const Tensor & self, IntList kernel_size, IntList stride, IntList padding, bool ceil_mode, bool count_include_pad) const {
    const DeviceGuard device_guard(output);
    return avg_pool2d_forward_out(output, self, kernel_size, stride, padding, ceil_mode, count_include_pad);
}
Tensor TypeDefault::avg_pool2d(const Tensor & self, IntList kernel_size, IntList stride, IntList padding, bool ceil_mode, bool count_include_pad) const {
    const DeviceGuard device_guard(self);
    return avg_pool2d_forward(self, kernel_size, stride, padding, ceil_mode, count_include_pad);
}
Tensor & TypeDefault::avg_pool2d_forward_out(Tensor & output, const Tensor & self, IntList kernel_size, IntList stride, IntList padding, bool ceil_mode, bool count_include_pad) const {
    AT_ERROR("avg_pool2d_forward_out is not implemented for type ", toString());
}
Tensor TypeDefault::avg_pool2d_forward(const Tensor & self, IntList kernel_size, IntList stride, IntList padding, bool ceil_mode, bool count_include_pad) const {
    AT_ERROR("avg_pool2d_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::avg_pool2d_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, IntList kernel_size, IntList stride, IntList padding, bool ceil_mode, bool count_include_pad) const {
    AT_ERROR("avg_pool2d_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::avg_pool2d_backward(const Tensor & grad_output, const Tensor & self, IntList kernel_size, IntList stride, IntList padding, bool ceil_mode, bool count_include_pad) const {
    AT_ERROR("avg_pool2d_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::avg_pool3d_out(Tensor & output, const Tensor & self, IntList kernel_size, IntList stride, IntList padding, bool ceil_mode, bool count_include_pad) const {
    const DeviceGuard device_guard(output);
    return avg_pool3d_forward_out(output, self, kernel_size, stride, padding, ceil_mode, count_include_pad);
}
Tensor TypeDefault::avg_pool3d(const Tensor & self, IntList kernel_size, IntList stride, IntList padding, bool ceil_mode, bool count_include_pad) const {
    const DeviceGuard device_guard(self);
    return avg_pool3d_forward(self, kernel_size, stride, padding, ceil_mode, count_include_pad);
}
Tensor & TypeDefault::avg_pool3d_forward_out(Tensor & output, const Tensor & self, IntList kernel_size, IntList stride, IntList padding, bool ceil_mode, bool count_include_pad) const {
    AT_ERROR("avg_pool3d_forward_out is not implemented for type ", toString());
}
Tensor TypeDefault::avg_pool3d_forward(const Tensor & self, IntList kernel_size, IntList stride, IntList padding, bool ceil_mode, bool count_include_pad) const {
    AT_ERROR("avg_pool3d_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::avg_pool3d_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, IntList kernel_size, IntList stride, IntList padding, bool ceil_mode, bool count_include_pad) const {
    AT_ERROR("avg_pool3d_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::avg_pool3d_backward(const Tensor & grad_output, const Tensor & self, IntList kernel_size, IntList stride, IntList padding, bool ceil_mode, bool count_include_pad) const {
    AT_ERROR("avg_pool3d_backward is not implemented for type ", toString());
}
std::tuple<Tensor &,Tensor &> TypeDefault::fractional_max_pool2d_out(Tensor & output, Tensor & indices, const Tensor & self, IntList kernel_size, IntList output_size, const Tensor & random_samples) const {
    const DeviceGuard device_guard(output);
    return fractional_max_pool2d_forward_out(output, indices, self, kernel_size, output_size, random_samples);
}
std::tuple<Tensor,Tensor> TypeDefault::fractional_max_pool2d(const Tensor & self, IntList kernel_size, IntList output_size, const Tensor & random_samples) const {
    const DeviceGuard device_guard(self);
    return fractional_max_pool2d_forward(self, kernel_size, output_size, random_samples);
}
std::tuple<Tensor &,Tensor &> TypeDefault::fractional_max_pool2d_forward_out(Tensor & output, Tensor & indices, const Tensor & self, IntList kernel_size, IntList output_size, const Tensor & random_samples) const {
    AT_ERROR("fractional_max_pool2d_forward_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::fractional_max_pool2d_forward(const Tensor & self, IntList kernel_size, IntList output_size, const Tensor & random_samples) const {
    AT_ERROR("fractional_max_pool2d_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::fractional_max_pool2d_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, IntList kernel_size, IntList output_size, const Tensor & indices) const {
    AT_ERROR("fractional_max_pool2d_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::fractional_max_pool2d_backward(const Tensor & grad_output, const Tensor & self, IntList kernel_size, IntList output_size, const Tensor & indices) const {
    AT_ERROR("fractional_max_pool2d_backward is not implemented for type ", toString());
}
std::tuple<Tensor &,Tensor &> TypeDefault::max_pool2d_with_indices_out(Tensor & output, Tensor & indices, const Tensor & self, IntList kernel_size, IntList stride, IntList padding, IntList dilation, bool ceil_mode) const {
    const DeviceGuard device_guard(output);
    return max_pool2d_with_indices_forward_out(output, indices, self, kernel_size, stride, padding, dilation, ceil_mode);
}
std::tuple<Tensor,Tensor> TypeDefault::max_pool2d_with_indices(const Tensor & self, IntList kernel_size, IntList stride, IntList padding, IntList dilation, bool ceil_mode) const {
    const DeviceGuard device_guard(self);
    return max_pool2d_with_indices_forward(self, kernel_size, stride, padding, dilation, ceil_mode);
}
std::tuple<Tensor &,Tensor &> TypeDefault::max_pool2d_with_indices_forward_out(Tensor & output, Tensor & indices, const Tensor & self, IntList kernel_size, IntList stride, IntList padding, IntList dilation, bool ceil_mode) const {
    AT_ERROR("max_pool2d_with_indices_forward_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::max_pool2d_with_indices_forward(const Tensor & self, IntList kernel_size, IntList stride, IntList padding, IntList dilation, bool ceil_mode) const {
    AT_ERROR("max_pool2d_with_indices_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::max_pool2d_with_indices_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, IntList kernel_size, IntList stride, IntList padding, IntList dilation, bool ceil_mode, const Tensor & indices) const {
    AT_ERROR("max_pool2d_with_indices_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::max_pool2d_with_indices_backward(const Tensor & grad_output, const Tensor & self, IntList kernel_size, IntList stride, IntList padding, IntList dilation, bool ceil_mode, const Tensor & indices) const {
    AT_ERROR("max_pool2d_with_indices_backward is not implemented for type ", toString());
}
std::tuple<Tensor &,Tensor &> TypeDefault::max_pool3d_with_indices_out(Tensor & output, Tensor & indices, const Tensor & self, IntList kernel_size, IntList stride, IntList padding, IntList dilation, bool ceil_mode) const {
    const DeviceGuard device_guard(output);
    return max_pool3d_with_indices_forward_out(output, indices, self, kernel_size, stride, padding, dilation, ceil_mode);
}
std::tuple<Tensor,Tensor> TypeDefault::max_pool3d_with_indices(const Tensor & self, IntList kernel_size, IntList stride, IntList padding, IntList dilation, bool ceil_mode) const {
    const DeviceGuard device_guard(self);
    return max_pool3d_with_indices_forward(self, kernel_size, stride, padding, dilation, ceil_mode);
}
std::tuple<Tensor &,Tensor &> TypeDefault::max_pool3d_with_indices_forward_out(Tensor & output, Tensor & indices, const Tensor & self, IntList kernel_size, IntList stride, IntList padding, IntList dilation, bool ceil_mode) const {
    AT_ERROR("max_pool3d_with_indices_forward_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::max_pool3d_with_indices_forward(const Tensor & self, IntList kernel_size, IntList stride, IntList padding, IntList dilation, bool ceil_mode) const {
    AT_ERROR("max_pool3d_with_indices_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::max_pool3d_with_indices_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, IntList kernel_size, IntList stride, IntList padding, IntList dilation, bool ceil_mode, const Tensor & indices) const {
    AT_ERROR("max_pool3d_with_indices_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::max_pool3d_with_indices_backward(const Tensor & grad_output, const Tensor & self, IntList kernel_size, IntList stride, IntList padding, IntList dilation, bool ceil_mode, const Tensor & indices) const {
    AT_ERROR("max_pool3d_with_indices_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::max_unpool2d_out(Tensor & output, const Tensor & self, const Tensor & indices, IntList output_size) const {
    const DeviceGuard device_guard(output);
    return max_unpool2d_forward_out(output, self, indices, output_size);
}
Tensor TypeDefault::max_unpool2d(const Tensor & self, const Tensor & indices, IntList output_size) const {
    const DeviceGuard device_guard(self);
    return max_unpool2d_forward(self, indices, output_size);
}
Tensor & TypeDefault::max_unpool2d_forward_out(Tensor & output, const Tensor & self, const Tensor & indices, IntList output_size) const {
    AT_ERROR("max_unpool2d_forward_out is not implemented for type ", toString());
}
Tensor TypeDefault::max_unpool2d_forward(const Tensor & self, const Tensor & indices, IntList output_size) const {
    AT_ERROR("max_unpool2d_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::max_unpool2d_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, const Tensor & indices, IntList output_size) const {
    AT_ERROR("max_unpool2d_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::max_unpool2d_backward(const Tensor & grad_output, const Tensor & self, const Tensor & indices, IntList output_size) const {
    AT_ERROR("max_unpool2d_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::max_unpool3d_out(Tensor & output, const Tensor & self, const Tensor & indices, IntList output_size, IntList stride, IntList padding) const {
    const DeviceGuard device_guard(output);
    return max_unpool3d_forward_out(output, self, indices, output_size, stride, padding);
}
Tensor TypeDefault::max_unpool3d(const Tensor & self, const Tensor & indices, IntList output_size, IntList stride, IntList padding) const {
    const DeviceGuard device_guard(self);
    return max_unpool3d_forward(self, indices, output_size, stride, padding);
}
Tensor & TypeDefault::max_unpool3d_forward_out(Tensor & output, const Tensor & self, const Tensor & indices, IntList output_size, IntList stride, IntList padding) const {
    AT_ERROR("max_unpool3d_forward_out is not implemented for type ", toString());
}
Tensor TypeDefault::max_unpool3d_forward(const Tensor & self, const Tensor & indices, IntList output_size, IntList stride, IntList padding) const {
    AT_ERROR("max_unpool3d_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::max_unpool3d_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, const Tensor & indices, IntList output_size, IntList stride, IntList padding) const {
    AT_ERROR("max_unpool3d_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::max_unpool3d_backward(const Tensor & grad_output, const Tensor & self, const Tensor & indices, IntList output_size, IntList stride, IntList padding) const {
    AT_ERROR("max_unpool3d_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::reflection_pad1d_out(Tensor & output, const Tensor & self, IntList padding) const {
    const DeviceGuard device_guard(output);
    return reflection_pad1d_forward_out(output, self, padding);
}
Tensor TypeDefault::reflection_pad1d(const Tensor & self, IntList padding) const {
    const DeviceGuard device_guard(self);
    return reflection_pad1d_forward(self, padding);
}
Tensor & TypeDefault::reflection_pad1d_forward_out(Tensor & output, const Tensor & self, IntList padding) const {
    AT_ERROR("reflection_pad1d_forward_out is not implemented for type ", toString());
}
Tensor TypeDefault::reflection_pad1d_forward(const Tensor & self, IntList padding) const {
    AT_ERROR("reflection_pad1d_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::reflection_pad1d_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, IntList padding) const {
    AT_ERROR("reflection_pad1d_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::reflection_pad1d_backward(const Tensor & grad_output, const Tensor & self, IntList padding) const {
    AT_ERROR("reflection_pad1d_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::reflection_pad2d_out(Tensor & output, const Tensor & self, IntList padding) const {
    const DeviceGuard device_guard(output);
    return reflection_pad2d_forward_out(output, self, padding);
}
Tensor TypeDefault::reflection_pad2d(const Tensor & self, IntList padding) const {
    const DeviceGuard device_guard(self);
    return reflection_pad2d_forward(self, padding);
}
Tensor & TypeDefault::reflection_pad2d_forward_out(Tensor & output, const Tensor & self, IntList padding) const {
    AT_ERROR("reflection_pad2d_forward_out is not implemented for type ", toString());
}
Tensor TypeDefault::reflection_pad2d_forward(const Tensor & self, IntList padding) const {
    AT_ERROR("reflection_pad2d_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::reflection_pad2d_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, IntList padding) const {
    AT_ERROR("reflection_pad2d_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::reflection_pad2d_backward(const Tensor & grad_output, const Tensor & self, IntList padding) const {
    AT_ERROR("reflection_pad2d_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::replication_pad1d_out(Tensor & output, const Tensor & self, IntList padding) const {
    const DeviceGuard device_guard(output);
    return replication_pad1d_forward_out(output, self, padding);
}
Tensor TypeDefault::replication_pad1d(const Tensor & self, IntList padding) const {
    const DeviceGuard device_guard(self);
    return replication_pad1d_forward(self, padding);
}
Tensor & TypeDefault::replication_pad1d_forward_out(Tensor & output, const Tensor & self, IntList padding) const {
    AT_ERROR("replication_pad1d_forward_out is not implemented for type ", toString());
}
Tensor TypeDefault::replication_pad1d_forward(const Tensor & self, IntList padding) const {
    AT_ERROR("replication_pad1d_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::replication_pad1d_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, IntList padding) const {
    AT_ERROR("replication_pad1d_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::replication_pad1d_backward(const Tensor & grad_output, const Tensor & self, IntList padding) const {
    AT_ERROR("replication_pad1d_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::replication_pad2d_out(Tensor & output, const Tensor & self, IntList padding) const {
    const DeviceGuard device_guard(output);
    return replication_pad2d_forward_out(output, self, padding);
}
Tensor TypeDefault::replication_pad2d(const Tensor & self, IntList padding) const {
    const DeviceGuard device_guard(self);
    return replication_pad2d_forward(self, padding);
}
Tensor & TypeDefault::replication_pad2d_forward_out(Tensor & output, const Tensor & self, IntList padding) const {
    AT_ERROR("replication_pad2d_forward_out is not implemented for type ", toString());
}
Tensor TypeDefault::replication_pad2d_forward(const Tensor & self, IntList padding) const {
    AT_ERROR("replication_pad2d_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::replication_pad2d_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, IntList padding) const {
    AT_ERROR("replication_pad2d_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::replication_pad2d_backward(const Tensor & grad_output, const Tensor & self, IntList padding) const {
    AT_ERROR("replication_pad2d_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::replication_pad3d_out(Tensor & output, const Tensor & self, IntList padding) const {
    const DeviceGuard device_guard(output);
    return replication_pad3d_forward_out(output, self, padding);
}
Tensor TypeDefault::replication_pad3d(const Tensor & self, IntList padding) const {
    const DeviceGuard device_guard(self);
    return replication_pad3d_forward(self, padding);
}
Tensor & TypeDefault::replication_pad3d_forward_out(Tensor & output, const Tensor & self, IntList padding) const {
    AT_ERROR("replication_pad3d_forward_out is not implemented for type ", toString());
}
Tensor TypeDefault::replication_pad3d_forward(const Tensor & self, IntList padding) const {
    AT_ERROR("replication_pad3d_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::replication_pad3d_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, IntList padding) const {
    AT_ERROR("replication_pad3d_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::replication_pad3d_backward(const Tensor & grad_output, const Tensor & self, IntList padding) const {
    AT_ERROR("replication_pad3d_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::upsample_linear1d_out(Tensor & output, const Tensor & self, IntList output_size, bool align_corners) const {
    const DeviceGuard device_guard(output);
    return upsample_linear1d_forward_out(output, self, output_size, align_corners);
}
Tensor TypeDefault::upsample_linear1d(const Tensor & self, IntList output_size, bool align_corners) const {
    const DeviceGuard device_guard(self);
    return upsample_linear1d_forward(self, output_size, align_corners);
}
Tensor & TypeDefault::upsample_linear1d_forward_out(Tensor & output, const Tensor & self, IntList output_size, bool align_corners) const {
    AT_ERROR("upsample_linear1d_forward_out is not implemented for type ", toString());
}
Tensor TypeDefault::upsample_linear1d_forward(const Tensor & self, IntList output_size, bool align_corners) const {
    AT_ERROR("upsample_linear1d_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::upsample_linear1d_backward_out(Tensor & grad_input, const Tensor & grad_output, IntList output_size, IntList input_size, bool align_corners) const {
    AT_ERROR("upsample_linear1d_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::upsample_linear1d_backward(const Tensor & grad_output, IntList output_size, IntList input_size, bool align_corners) const {
    AT_ERROR("upsample_linear1d_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::upsample_bilinear2d_out(Tensor & output, const Tensor & self, IntList output_size, bool align_corners) const {
    const DeviceGuard device_guard(output);
    return upsample_bilinear2d_forward_out(output, self, output_size, align_corners);
}
Tensor TypeDefault::upsample_bilinear2d(const Tensor & self, IntList output_size, bool align_corners) const {
    const DeviceGuard device_guard(self);
    return upsample_bilinear2d_forward(self, output_size, align_corners);
}
Tensor & TypeDefault::upsample_bilinear2d_forward_out(Tensor & output, const Tensor & self, IntList output_size, bool align_corners) const {
    AT_ERROR("upsample_bilinear2d_forward_out is not implemented for type ", toString());
}
Tensor TypeDefault::upsample_bilinear2d_forward(const Tensor & self, IntList output_size, bool align_corners) const {
    AT_ERROR("upsample_bilinear2d_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::upsample_bilinear2d_backward_out(Tensor & grad_input, const Tensor & grad_output, IntList output_size, IntList input_size, bool align_corners) const {
    AT_ERROR("upsample_bilinear2d_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::upsample_bilinear2d_backward(const Tensor & grad_output, IntList output_size, IntList input_size, bool align_corners) const {
    AT_ERROR("upsample_bilinear2d_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::upsample_trilinear3d_out(Tensor & output, const Tensor & self, IntList output_size, bool align_corners) const {
    const DeviceGuard device_guard(output);
    return upsample_trilinear3d_forward_out(output, self, output_size, align_corners);
}
Tensor TypeDefault::upsample_trilinear3d(const Tensor & self, IntList output_size, bool align_corners) const {
    const DeviceGuard device_guard(self);
    return upsample_trilinear3d_forward(self, output_size, align_corners);
}
Tensor & TypeDefault::upsample_trilinear3d_forward_out(Tensor & output, const Tensor & self, IntList output_size, bool align_corners) const {
    AT_ERROR("upsample_trilinear3d_forward_out is not implemented for type ", toString());
}
Tensor TypeDefault::upsample_trilinear3d_forward(const Tensor & self, IntList output_size, bool align_corners) const {
    AT_ERROR("upsample_trilinear3d_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::upsample_trilinear3d_backward_out(Tensor & grad_input, const Tensor & grad_output, IntList output_size, IntList input_size, bool align_corners) const {
    AT_ERROR("upsample_trilinear3d_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::upsample_trilinear3d_backward(const Tensor & grad_output, IntList output_size, IntList input_size, bool align_corners) const {
    AT_ERROR("upsample_trilinear3d_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::upsample_nearest1d_out(Tensor & output, const Tensor & self, IntList output_size) const {
    const DeviceGuard device_guard(output);
    return upsample_nearest1d_forward_out(output, self, output_size);
}
Tensor TypeDefault::upsample_nearest1d(const Tensor & self, IntList output_size) const {
    const DeviceGuard device_guard(self);
    return upsample_nearest1d_forward(self, output_size);
}
Tensor & TypeDefault::upsample_nearest1d_forward_out(Tensor & output, const Tensor & self, IntList output_size) const {
    AT_ERROR("upsample_nearest1d_forward_out is not implemented for type ", toString());
}
Tensor TypeDefault::upsample_nearest1d_forward(const Tensor & self, IntList output_size) const {
    AT_ERROR("upsample_nearest1d_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::upsample_nearest1d_backward_out(Tensor & grad_input, const Tensor & grad_output, IntList output_size, IntList input_size) const {
    AT_ERROR("upsample_nearest1d_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::upsample_nearest1d_backward(const Tensor & grad_output, IntList output_size, IntList input_size) const {
    AT_ERROR("upsample_nearest1d_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::upsample_nearest2d_out(Tensor & output, const Tensor & self, IntList output_size) const {
    const DeviceGuard device_guard(output);
    return upsample_nearest2d_forward_out(output, self, output_size);
}
Tensor TypeDefault::upsample_nearest2d(const Tensor & self, IntList output_size) const {
    const DeviceGuard device_guard(self);
    return upsample_nearest2d_forward(self, output_size);
}
Tensor & TypeDefault::upsample_nearest2d_forward_out(Tensor & output, const Tensor & self, IntList output_size) const {
    AT_ERROR("upsample_nearest2d_forward_out is not implemented for type ", toString());
}
Tensor TypeDefault::upsample_nearest2d_forward(const Tensor & self, IntList output_size) const {
    AT_ERROR("upsample_nearest2d_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::upsample_nearest2d_backward_out(Tensor & grad_input, const Tensor & grad_output, IntList output_size, IntList input_size) const {
    AT_ERROR("upsample_nearest2d_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::upsample_nearest2d_backward(const Tensor & grad_output, IntList output_size, IntList input_size) const {
    AT_ERROR("upsample_nearest2d_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::upsample_nearest3d_out(Tensor & output, const Tensor & self, IntList output_size) const {
    const DeviceGuard device_guard(output);
    return upsample_nearest3d_forward_out(output, self, output_size);
}
Tensor TypeDefault::upsample_nearest3d(const Tensor & self, IntList output_size) const {
    const DeviceGuard device_guard(self);
    return upsample_nearest3d_forward(self, output_size);
}
Tensor & TypeDefault::upsample_nearest3d_forward_out(Tensor & output, const Tensor & self, IntList output_size) const {
    AT_ERROR("upsample_nearest3d_forward_out is not implemented for type ", toString());
}
Tensor TypeDefault::upsample_nearest3d_forward(const Tensor & self, IntList output_size) const {
    AT_ERROR("upsample_nearest3d_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::upsample_nearest3d_backward_out(Tensor & grad_input, const Tensor & grad_output, IntList output_size, IntList input_size) const {
    AT_ERROR("upsample_nearest3d_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::upsample_nearest3d_backward(const Tensor & grad_output, IntList output_size, IntList input_size) const {
    AT_ERROR("upsample_nearest3d_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::_sigmoid_out(Tensor & output, const Tensor & self) const {
    const DeviceGuard device_guard(output);
    return _sigmoid_forward_out(output, self);
}
Tensor TypeDefault::_sigmoid(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return _sigmoid_forward(self);
}
Tensor & TypeDefault::_sigmoid_forward_out(Tensor & output, const Tensor & self) const {
    AT_ERROR("_sigmoid_forward_out is not implemented for type ", toString());
}
Tensor TypeDefault::_sigmoid_forward(const Tensor & self) const {
    AT_ERROR("_sigmoid_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::_sigmoid_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & output) const {
    AT_ERROR("_sigmoid_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::_sigmoid_backward(const Tensor & grad_output, const Tensor & output) const {
    AT_ERROR("_sigmoid_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::_tanh_out(Tensor & output, const Tensor & self) const {
    const DeviceGuard device_guard(output);
    return _tanh_forward_out(output, self);
}
Tensor TypeDefault::_tanh(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return _tanh_forward(self);
}
Tensor & TypeDefault::_tanh_forward_out(Tensor & output, const Tensor & self) const {
    AT_ERROR("_tanh_forward_out is not implemented for type ", toString());
}
Tensor TypeDefault::_tanh_forward(const Tensor & self) const {
    AT_ERROR("_tanh_forward is not implemented for type ", toString());
}
Tensor & TypeDefault::_tanh_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & output) const {
    AT_ERROR("_tanh_backward_out is not implemented for type ", toString());
}
Tensor TypeDefault::_tanh_backward(const Tensor & grad_output, const Tensor & output) const {
    AT_ERROR("_tanh_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::thnn_conv_transpose2d_out(Tensor & output, const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding, IntList output_padding, IntList dilation) const {
    const DeviceGuard device_guard(output);
    Tensor columns = at::empty({0}, this->options());
    Tensor ones = at::empty({0}, this->options());
    return std::get<0>(thnn_conv_transpose2d_forward_out(output, columns, ones, self, weight, kernel_size, bias, stride, padding, output_padding, dilation));
}
Tensor TypeDefault::thnn_conv_transpose2d(const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding, IntList output_padding, IntList dilation) const {
    const DeviceGuard device_guard(self);
    return std::get<0>(thnn_conv_transpose2d_forward(self, weight, kernel_size, bias, stride, padding, output_padding, dilation));
}
std::tuple<Tensor &,Tensor &,Tensor &> TypeDefault::thnn_conv_transpose2d_forward_out(Tensor & output, Tensor & columns, Tensor & ones, const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding, IntList output_padding, IntList dilation) const {
    AT_ERROR("thnn_conv_transpose2d_forward_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor,Tensor> TypeDefault::thnn_conv_transpose2d_forward(const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding, IntList output_padding, IntList dilation) const {
    AT_ERROR("thnn_conv_transpose2d_forward is not implemented for type ", toString());
}
std::tuple<Tensor &,Tensor &,Tensor &> TypeDefault::thnn_conv_transpose2d_backward_out(Tensor & grad_input, Tensor & grad_weight, Tensor & grad_bias, const Tensor & grad_output, const Tensor & self, const Tensor & weight, IntList kernel_size, IntList stride, IntList padding, IntList output_padding, IntList dilation, const Tensor & columns, const Tensor & ones) const {
    AT_ERROR("thnn_conv_transpose2d_backward_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor,Tensor> TypeDefault::thnn_conv_transpose2d_backward(const Tensor & grad_output, const Tensor & self, const Tensor & weight, IntList kernel_size, IntList stride, IntList padding, IntList output_padding, IntList dilation, const Tensor & columns, const Tensor & ones, std::array<bool,3> output_mask) const {
    AT_ERROR("thnn_conv_transpose2d_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::thnn_conv_transpose3d_out(Tensor & output, const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding, IntList output_padding, IntList dilation) const {
    const DeviceGuard device_guard(output);
    Tensor finput = at::empty({0}, this->options());
    Tensor fgrad_input = at::empty({0}, this->options());
    return std::get<0>(thnn_conv_transpose3d_forward_out(output, finput, fgrad_input, self, weight, kernel_size, bias, stride, padding, output_padding, dilation));
}
Tensor TypeDefault::thnn_conv_transpose3d(const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding, IntList output_padding, IntList dilation) const {
    const DeviceGuard device_guard(self);
    return std::get<0>(thnn_conv_transpose3d_forward(self, weight, kernel_size, bias, stride, padding, output_padding, dilation));
}
std::tuple<Tensor &,Tensor &,Tensor &> TypeDefault::thnn_conv_transpose3d_forward_out(Tensor & output, Tensor & finput, Tensor & fgrad_input, const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding, IntList output_padding, IntList dilation) const {
    AT_ERROR("thnn_conv_transpose3d_forward_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor,Tensor> TypeDefault::thnn_conv_transpose3d_forward(const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding, IntList output_padding, IntList dilation) const {
    AT_ERROR("thnn_conv_transpose3d_forward is not implemented for type ", toString());
}
std::tuple<Tensor &,Tensor &,Tensor &> TypeDefault::thnn_conv_transpose3d_backward_out(Tensor & grad_input, Tensor & grad_weight, Tensor & grad_bias, const Tensor & grad_output, const Tensor & self, const Tensor & weight, IntList kernel_size, IntList stride, IntList padding, IntList output_padding, IntList dilation, const Tensor & finput, const Tensor & fgrad_input) const {
    AT_ERROR("thnn_conv_transpose3d_backward_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor,Tensor> TypeDefault::thnn_conv_transpose3d_backward(const Tensor & grad_output, const Tensor & self, const Tensor & weight, IntList kernel_size, IntList stride, IntList padding, IntList output_padding, IntList dilation, const Tensor & finput, const Tensor & fgrad_input, std::array<bool,3> output_mask) const {
    AT_ERROR("thnn_conv_transpose3d_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::thnn_conv2d_out(Tensor & output, const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding) const {
    const DeviceGuard device_guard(output);
    Tensor finput = at::empty({0}, this->options());
    Tensor fgrad_input = at::empty({0}, this->options());
    return std::get<0>(thnn_conv2d_forward_out(output, finput, fgrad_input, self, weight, kernel_size, bias, stride, padding));
}
Tensor TypeDefault::thnn_conv2d(const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding) const {
    const DeviceGuard device_guard(self);
    return std::get<0>(thnn_conv2d_forward(self, weight, kernel_size, bias, stride, padding));
}
std::tuple<Tensor &,Tensor &,Tensor &> TypeDefault::thnn_conv2d_forward_out(Tensor & output, Tensor & finput, Tensor & fgrad_input, const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding) const {
    AT_ERROR("thnn_conv2d_forward_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor,Tensor> TypeDefault::thnn_conv2d_forward(const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding) const {
    AT_ERROR("thnn_conv2d_forward is not implemented for type ", toString());
}
std::tuple<Tensor &,Tensor &,Tensor &> TypeDefault::thnn_conv2d_backward_out(Tensor & grad_input, Tensor & grad_weight, Tensor & grad_bias, const Tensor & grad_output, const Tensor & self, const Tensor & weight, IntList kernel_size, IntList stride, IntList padding, const Tensor & finput, const Tensor & fgrad_input) const {
    AT_ERROR("thnn_conv2d_backward_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor,Tensor> TypeDefault::thnn_conv2d_backward(const Tensor & grad_output, const Tensor & self, const Tensor & weight, IntList kernel_size, IntList stride, IntList padding, const Tensor & finput, const Tensor & fgrad_input, std::array<bool,3> output_mask) const {
    AT_ERROR("thnn_conv2d_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::thnn_conv_depthwise2d_out(Tensor & output, const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding, IntList dilation) const {
    const DeviceGuard device_guard(output);
    return thnn_conv_depthwise2d_forward_out(output, self, weight, kernel_size, bias, stride, padding, dilation);
}
Tensor TypeDefault::thnn_conv_depthwise2d(const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding, IntList dilation) const {
    const DeviceGuard device_guard(self);
    return thnn_conv_depthwise2d_forward(self, weight, kernel_size, bias, stride, padding, dilation);
}
Tensor & TypeDefault::thnn_conv_depthwise2d_forward_out(Tensor & output, const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding, IntList dilation) const {
    AT_ERROR("thnn_conv_depthwise2d_forward_out is not implemented for type ", toString());
}
Tensor TypeDefault::thnn_conv_depthwise2d_forward(const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding, IntList dilation) const {
    AT_ERROR("thnn_conv_depthwise2d_forward is not implemented for type ", toString());
}
std::tuple<Tensor &,Tensor &> TypeDefault::thnn_conv_depthwise2d_backward_out(Tensor & grad_input, Tensor & grad_weight, const Tensor & grad_output, const Tensor & self, const Tensor & weight, IntList kernel_size, IntList stride, IntList padding, IntList dilation) const {
    AT_ERROR("thnn_conv_depthwise2d_backward_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::thnn_conv_depthwise2d_backward(const Tensor & grad_output, const Tensor & self, const Tensor & weight, IntList kernel_size, IntList stride, IntList padding, IntList dilation, std::array<bool,2> output_mask) const {
    AT_ERROR("thnn_conv_depthwise2d_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::thnn_conv3d_out(Tensor & output, const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding) const {
    const DeviceGuard device_guard(output);
    Tensor finput = at::empty({0}, this->options());
    Tensor fgrad_input = at::empty({0}, this->options());
    return std::get<0>(thnn_conv3d_forward_out(output, finput, fgrad_input, self, weight, kernel_size, bias, stride, padding));
}
Tensor TypeDefault::thnn_conv3d(const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding) const {
    const DeviceGuard device_guard(self);
    return std::get<0>(thnn_conv3d_forward(self, weight, kernel_size, bias, stride, padding));
}
std::tuple<Tensor &,Tensor &,Tensor &> TypeDefault::thnn_conv3d_forward_out(Tensor & output, Tensor & finput, Tensor & fgrad_input, const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding) const {
    AT_ERROR("thnn_conv3d_forward_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor,Tensor> TypeDefault::thnn_conv3d_forward(const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding) const {
    AT_ERROR("thnn_conv3d_forward is not implemented for type ", toString());
}
std::tuple<Tensor &,Tensor &,Tensor &> TypeDefault::thnn_conv3d_backward_out(Tensor & grad_input, Tensor & grad_weight, Tensor & grad_bias, const Tensor & grad_output, const Tensor & self, const Tensor & weight, IntList kernel_size, IntList stride, IntList padding, const Tensor & finput, const Tensor & fgrad_input) const {
    AT_ERROR("thnn_conv3d_backward_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor,Tensor> TypeDefault::thnn_conv3d_backward(const Tensor & grad_output, const Tensor & self, const Tensor & weight, IntList kernel_size, IntList stride, IntList padding, const Tensor & finput, const Tensor & fgrad_input, std::array<bool,3> output_mask) const {
    AT_ERROR("thnn_conv3d_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::thnn_conv_dilated2d_out(Tensor & output, const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding, IntList dilation) const {
    const DeviceGuard device_guard(output);
    Tensor columns = at::empty({0}, this->options());
    Tensor ones = at::empty({0}, this->options());
    return std::get<0>(thnn_conv_dilated2d_forward_out(output, columns, ones, self, weight, kernel_size, bias, stride, padding, dilation));
}
Tensor TypeDefault::thnn_conv_dilated2d(const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding, IntList dilation) const {
    const DeviceGuard device_guard(self);
    return std::get<0>(thnn_conv_dilated2d_forward(self, weight, kernel_size, bias, stride, padding, dilation));
}
std::tuple<Tensor &,Tensor &,Tensor &> TypeDefault::thnn_conv_dilated2d_forward_out(Tensor & output, Tensor & columns, Tensor & ones, const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding, IntList dilation) const {
    AT_ERROR("thnn_conv_dilated2d_forward_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor,Tensor> TypeDefault::thnn_conv_dilated2d_forward(const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding, IntList dilation) const {
    AT_ERROR("thnn_conv_dilated2d_forward is not implemented for type ", toString());
}
std::tuple<Tensor &,Tensor &,Tensor &> TypeDefault::thnn_conv_dilated2d_backward_out(Tensor & grad_input, Tensor & grad_weight, Tensor & grad_bias, const Tensor & grad_output, const Tensor & self, const Tensor & weight, IntList kernel_size, IntList stride, IntList padding, IntList dilation, const Tensor & columns, const Tensor & ones) const {
    AT_ERROR("thnn_conv_dilated2d_backward_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor,Tensor> TypeDefault::thnn_conv_dilated2d_backward(const Tensor & grad_output, const Tensor & self, const Tensor & weight, IntList kernel_size, IntList stride, IntList padding, IntList dilation, const Tensor & columns, const Tensor & ones, std::array<bool,3> output_mask) const {
    AT_ERROR("thnn_conv_dilated2d_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::thnn_conv_dilated3d_out(Tensor & output, const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding, IntList dilation) const {
    const DeviceGuard device_guard(output);
    Tensor columns = at::empty({0}, this->options());
    Tensor ones = at::empty({0}, this->options());
    return std::get<0>(thnn_conv_dilated3d_forward_out(output, columns, ones, self, weight, kernel_size, bias, stride, padding, dilation));
}
Tensor TypeDefault::thnn_conv_dilated3d(const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding, IntList dilation) const {
    const DeviceGuard device_guard(self);
    return std::get<0>(thnn_conv_dilated3d_forward(self, weight, kernel_size, bias, stride, padding, dilation));
}
std::tuple<Tensor &,Tensor &,Tensor &> TypeDefault::thnn_conv_dilated3d_forward_out(Tensor & output, Tensor & columns, Tensor & ones, const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding, IntList dilation) const {
    AT_ERROR("thnn_conv_dilated3d_forward_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor,Tensor> TypeDefault::thnn_conv_dilated3d_forward(const Tensor & self, const Tensor & weight, IntList kernel_size, const Tensor & bias, IntList stride, IntList padding, IntList dilation) const {
    AT_ERROR("thnn_conv_dilated3d_forward is not implemented for type ", toString());
}
std::tuple<Tensor &,Tensor &,Tensor &> TypeDefault::thnn_conv_dilated3d_backward_out(Tensor & grad_input, Tensor & grad_weight, Tensor & grad_bias, const Tensor & grad_output, const Tensor & self, const Tensor & weight, IntList kernel_size, IntList stride, IntList padding, IntList dilation, const Tensor & columns, const Tensor & ones) const {
    AT_ERROR("thnn_conv_dilated3d_backward_out is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor,Tensor> TypeDefault::thnn_conv_dilated3d_backward(const Tensor & grad_output, const Tensor & self, const Tensor & weight, IntList kernel_size, IntList stride, IntList padding, IntList dilation, const Tensor & columns, const Tensor & ones, std::array<bool,3> output_mask) const {
    AT_ERROR("thnn_conv_dilated3d_backward is not implemented for type ", toString());
}
Tensor TypeDefault::_cast_Byte(const Tensor & self, bool non_blocking) const {
    const DeviceGuard device_guard(self);
    return at::native::_cast_Byte(/* native_actuals */ self, non_blocking);
}
Tensor TypeDefault::_cast_Char(const Tensor & self, bool non_blocking) const {
    const DeviceGuard device_guard(self);
    return at::native::_cast_Char(/* native_actuals */ self, non_blocking);
}
Tensor TypeDefault::_cast_Double(const Tensor & self, bool non_blocking) const {
    const DeviceGuard device_guard(self);
    return at::native::_cast_Double(/* native_actuals */ self, non_blocking);
}
Tensor TypeDefault::_cast_Float(const Tensor & self, bool non_blocking) const {
    const DeviceGuard device_guard(self);
    return at::native::_cast_Float(/* native_actuals */ self, non_blocking);
}
Tensor TypeDefault::_cast_Int(const Tensor & self, bool non_blocking) const {
    const DeviceGuard device_guard(self);
    return at::native::_cast_Int(/* native_actuals */ self, non_blocking);
}
Tensor TypeDefault::_cast_Long(const Tensor & self, bool non_blocking) const {
    const DeviceGuard device_guard(self);
    return at::native::_cast_Long(/* native_actuals */ self, non_blocking);
}
Tensor TypeDefault::_cast_Short(const Tensor & self, bool non_blocking) const {
    const DeviceGuard device_guard(self);
    return at::native::_cast_Short(/* native_actuals */ self, non_blocking);
}
Tensor TypeDefault::_cast_Half(const Tensor & self, bool non_blocking) const {
    const DeviceGuard device_guard(self);
    return at::native::_cast_Half(/* native_actuals */ self, non_blocking);
}
std::tuple<Tensor,Tensor> TypeDefault::_cudnn_ctc_loss(const Tensor & log_probs, const Tensor & targets, IntList input_lengths, IntList target_lengths, int64_t blank, bool deterministic) const {
    AT_ERROR("_cudnn_ctc_loss is not implemented for type ", toString());
}
Tensor TypeDefault::_cudnn_rnn_flatten_weight(TensorList weight_arr, int64_t weight_stride0, int64_t input_size, int64_t mode, int64_t hidden_size, int64_t num_layers, bool batch_first, bool bidirectional) const {
    AT_ERROR("_cudnn_rnn_flatten_weight is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor,Tensor,Tensor,Tensor> TypeDefault::_cudnn_rnn(const Tensor & input, TensorList weight, int64_t weight_stride0, const Tensor & weight_buf, const Tensor & hx, const Tensor & cx, int64_t mode, int64_t hidden_size, int64_t num_layers, bool batch_first, double dropout, bool train, bool bidirectional, IntList batch_sizes, const Tensor & dropout_state) const {
    AT_ERROR("_cudnn_rnn is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor,Tensor,std::vector<Tensor>> TypeDefault::_cudnn_rnn_backward(const Tensor & input, TensorList weight, int64_t weight_stride0, const Tensor & weight_buf, const Tensor & hx, const Tensor & cx, const Tensor & output, const Tensor & grad_output, const Tensor & grad_hy, const Tensor & grad_cy, int64_t mode, int64_t hidden_size, int64_t num_layers, bool batch_first, double dropout, bool train, bool bidirectional, IntList batch_sizes, const Tensor & dropout_state, const Tensor & reserve, std::array<bool,4> output_mask) const {
    AT_ERROR("_cudnn_rnn_backward is not implemented for type ", toString());
}
Tensor TypeDefault::_cudnn_init_dropout_state(double dropout, bool train, int64_t dropout_seed, const TensorOptions & options) const {
    AT_ERROR("_cudnn_init_dropout_state is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::_fused_dropout(const Tensor & self, double p, Generator * generator) const {
    AT_ERROR("_fused_dropout is not implemented for type ", toString());
}
Tensor TypeDefault::_masked_scale(const Tensor & self, const Tensor & mask, double scale) const {
    AT_ERROR("_masked_scale is not implemented for type ", toString());
}
Tensor TypeDefault::_reshape_from_tensor(const Tensor & self, const Tensor & shape) const {
    const DeviceGuard device_guard(self);
    return at::native::_reshape_from_tensor(/* native_actuals */ self, shape);
}
Tensor TypeDefault::_shape_as_tensor(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::_shape_as_tensor(/* native_actuals */ self);
}
Tensor TypeDefault::dropout(const Tensor & input, double p, bool train) const {
    const DeviceGuard device_guard(input);
    return at::native::dropout(/* native_actuals */ input, p, train);
}
Tensor & TypeDefault::dropout_(Tensor & self, double p, bool train) const {
    const DeviceGuard device_guard(self);
    return at::native::dropout_(/* native_actuals */ self, p, train);
}
Tensor TypeDefault::feature_dropout(const Tensor & input, double p, bool train) const {
    const DeviceGuard device_guard(input);
    return at::native::feature_dropout(/* native_actuals */ input, p, train);
}
Tensor & TypeDefault::feature_dropout_(Tensor & self, double p, bool train) const {
    const DeviceGuard device_guard(self);
    return at::native::feature_dropout_(/* native_actuals */ self, p, train);
}
Tensor TypeDefault::alpha_dropout(const Tensor & input, double p, bool train) const {
    const DeviceGuard device_guard(input);
    return at::native::alpha_dropout(/* native_actuals */ input, p, train);
}
Tensor & TypeDefault::alpha_dropout_(Tensor & self, double p, bool train) const {
    const DeviceGuard device_guard(self);
    return at::native::alpha_dropout_(/* native_actuals */ self, p, train);
}
Tensor TypeDefault::feature_alpha_dropout(const Tensor & input, double p, bool train) const {
    const DeviceGuard device_guard(input);
    return at::native::feature_alpha_dropout(/* native_actuals */ input, p, train);
}
Tensor & TypeDefault::feature_alpha_dropout_(Tensor & self, double p, bool train) const {
    const DeviceGuard device_guard(self);
    return at::native::feature_alpha_dropout_(/* native_actuals */ self, p, train);
}
Tensor TypeDefault::abs(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::abs(/* native_actuals */ self);
}
Tensor & TypeDefault::abs_(Tensor & self) const {
    AT_ERROR("abs_ is not implemented for type ", toString());
}
Tensor & TypeDefault::abs_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("abs_out is not implemented for type ", toString());
}
Tensor TypeDefault::acos(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::acos(/* native_actuals */ self);
}
Tensor & TypeDefault::acos_(Tensor & self) const {
    AT_ERROR("acos_ is not implemented for type ", toString());
}
Tensor & TypeDefault::acos_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("acos_out is not implemented for type ", toString());
}
Tensor TypeDefault::avg_pool1d(const Tensor & self, IntList kernel_size, IntList stride, IntList padding, bool ceil_mode, bool count_include_pad) const {
    const DeviceGuard device_guard(self);
    return at::native::avg_pool1d(/* native_actuals */ self, kernel_size, stride, padding, ceil_mode, count_include_pad);
}
Tensor TypeDefault::adaptive_avg_pool1d(const Tensor & self, IntList output_size) const {
    const DeviceGuard device_guard(self);
    return at::native::adaptive_avg_pool1d(/* native_actuals */ self, output_size);
}
std::tuple<Tensor,Tensor> TypeDefault::adaptive_max_pool1d(const Tensor & self, IntList output_size) const {
    const DeviceGuard device_guard(self);
    return at::native::adaptive_max_pool1d(/* native_actuals */ self, output_size);
}
Tensor TypeDefault::add(const Tensor & self, const Tensor & other, Scalar alpha) const {
    const DeviceGuard device_guard(self);
    return at::native::add(/* native_actuals */ self, other, alpha);
}
Tensor & TypeDefault::add_(Tensor & self, const Tensor & other, Scalar alpha) const {
    const DeviceGuard device_guard(self);
    return at::native::add_(/* native_actuals */ self, other, alpha);
}
Tensor & TypeDefault::add_out(Tensor & result, const Tensor & self, const Tensor & other, Scalar alpha) const {
    const DeviceGuard device_guard(result);
    return at::native::add_out(/* native_actuals */ result, self, other, alpha);
}
Tensor TypeDefault::add(const Tensor & self, Scalar other, Scalar alpha) const {
    const DeviceGuard device_guard(self);
    return at::native::add(/* native_actuals */ self, other, alpha);
}
Tensor & TypeDefault::add_(Tensor & self, Scalar other, Scalar alpha) const {
    const DeviceGuard device_guard(self);
    return at::native::add_(/* native_actuals */ self, other, alpha);
}
Tensor TypeDefault::addmv(const Tensor & self, const Tensor & mat, const Tensor & vec, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(self);
    return at::native::addmv(/* native_actuals */ self, mat, vec, beta, alpha);
}
Tensor & TypeDefault::addmv_(Tensor & self, const Tensor & mat, const Tensor & vec, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(self);
    return at::native::addmv_(/* native_actuals */ self, mat, vec, beta, alpha);
}
Tensor & TypeDefault::addmv_out(Tensor & result, const Tensor & self, const Tensor & mat, const Tensor & vec, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(result);
    return at::native::addmv_out(/* native_actuals */ result, self, mat, vec, beta, alpha);
}
Tensor TypeDefault::addr(const Tensor & self, const Tensor & vec1, const Tensor & vec2, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(self);
    return at::native::addr(/* native_actuals */ self, vec1, vec2, beta, alpha);
}
Tensor & TypeDefault::addr_(Tensor & self, const Tensor & vec1, const Tensor & vec2, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(self);
    return at::native::addr_(/* native_actuals */ self, vec1, vec2, beta, alpha);
}
Tensor & TypeDefault::addr_out(Tensor & result, const Tensor & self, const Tensor & vec1, const Tensor & vec2, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(result);
    return at::native::addr_out(/* native_actuals */ result, self, vec1, vec2, beta, alpha);
}
Tensor TypeDefault::all(const Tensor & self, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(self);
    return at::native::all(/* native_actuals */ self, dim, keepdim);
}
Tensor & TypeDefault::all_out(Tensor & result, const Tensor & self, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(result);
    return at::native::all_out(/* native_actuals */ result, self, dim, keepdim);
}
bool TypeDefault::allclose(const Tensor & self, const Tensor & other, double rtol, double atol, bool equal_nan) const {
    const DeviceGuard device_guard(self);
    return at::native::allclose(/* native_actuals */ self, other, rtol, atol, equal_nan);
}
Tensor TypeDefault::any(const Tensor & self, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(self);
    return at::native::any(/* native_actuals */ self, dim, keepdim);
}
Tensor & TypeDefault::any_out(Tensor & result, const Tensor & self, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(result);
    return at::native::any_out(/* native_actuals */ result, self, dim, keepdim);
}
Tensor & TypeDefault::arange_out(Tensor & result, Scalar start, Scalar end) const {
    const DeviceGuard device_guard(result);
    return at::native::arange_out(/* native_actuals */ result, start, end);
}
Tensor & TypeDefault::arange_out(Tensor & result, Scalar start, Scalar end, Scalar step) const {
    const DeviceGuard device_guard(result);
    return at::native::arange_out(/* native_actuals */ result, start, end, step);
}
Tensor & TypeDefault::arange_out(Tensor & result, Scalar end) const {
    const DeviceGuard device_guard(result);
    return at::native::arange_out(/* native_actuals */ result, end);
}
Tensor TypeDefault::_dim_arange(const Tensor & like, int64_t dim) const {
    const DeviceGuard device_guard(like);
    return at::native::_dim_arange(/* native_actuals */ like, dim);
}
Tensor TypeDefault::argmax(const Tensor & self, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(self);
    return at::native::argmax(/* native_actuals */ self, dim, keepdim);
}
Tensor TypeDefault::argmax(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::argmax(/* native_actuals */ self);
}
Tensor TypeDefault::_argmax(const Tensor & self, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(self);
    return at::native::_argmax(/* native_actuals */ self, dim, keepdim);
}
Tensor TypeDefault::argmin(const Tensor & self, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(self);
    return at::native::argmin(/* native_actuals */ self, dim, keepdim);
}
Tensor TypeDefault::argmin(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::argmin(/* native_actuals */ self);
}
Tensor TypeDefault::_argmin(const Tensor & self, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(self);
    return at::native::_argmin(/* native_actuals */ self, dim, keepdim);
}
Tensor TypeDefault::as_strided(const Tensor & self, IntList size, IntList stride) const {
    const DeviceGuard device_guard(self);
    return at::native::as_strided(/* native_actuals */ self, size, stride);
}
Tensor & TypeDefault::as_strided_(Tensor & self, IntList size, IntList stride) const {
    const DeviceGuard device_guard(self);
    return at::native::as_strided_(/* native_actuals */ self, size, stride);
}
Tensor TypeDefault::as_strided(const Tensor & self, IntList size, IntList stride, int64_t storage_offset) const {
    const DeviceGuard device_guard(self);
    return at::native::as_strided(/* native_actuals */ self, size, stride, storage_offset);
}
Tensor & TypeDefault::as_strided_(Tensor & self, IntList size, IntList stride, int64_t storage_offset) const {
    const DeviceGuard device_guard(self);
    return at::native::as_strided_(/* native_actuals */ self, size, stride, storage_offset);
}
Tensor TypeDefault::asin(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::asin(/* native_actuals */ self);
}
Tensor & TypeDefault::asin_(Tensor & self) const {
    AT_ERROR("asin_ is not implemented for type ", toString());
}
Tensor & TypeDefault::asin_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("asin_out is not implemented for type ", toString());
}
Tensor TypeDefault::atan(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::atan(/* native_actuals */ self);
}
Tensor & TypeDefault::atan_(Tensor & self) const {
    AT_ERROR("atan_ is not implemented for type ", toString());
}
Tensor & TypeDefault::atan_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("atan_out is not implemented for type ", toString());
}
Tensor TypeDefault::baddbmm(const Tensor & self, const Tensor & batch1, const Tensor & batch2, Scalar beta, Scalar alpha) const {
    AT_ERROR("baddbmm is not implemented for type ", toString());
}
Tensor & TypeDefault::baddbmm_(Tensor & self, const Tensor & batch1, const Tensor & batch2, Scalar beta, Scalar alpha) const {
    AT_ERROR("baddbmm_ is not implemented for type ", toString());
}
Tensor & TypeDefault::_baddbmm_mkl_(Tensor & self, const Tensor & batch1, const Tensor & batch2, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(self);
    return at::native::_baddbmm_mkl_(/* native_actuals */ self, batch1, batch2, beta, alpha);
}
Tensor & TypeDefault::baddbmm_out(Tensor & result, const Tensor & self, const Tensor & batch1, const Tensor & batch2, Scalar beta, Scalar alpha) const {
    AT_ERROR("baddbmm_out is not implemented for type ", toString());
}
Tensor TypeDefault::batch_norm(const Tensor & input, const Tensor & weight, const Tensor & bias, const Tensor & running_mean, const Tensor & running_var, bool training, double momentum, double eps, bool cudnn_enabled) const {
    const DeviceGuard device_guard(input);
    return at::native::batch_norm(/* native_actuals */ input, weight, bias, running_mean, running_var, training, momentum, eps, cudnn_enabled);
}
Tensor TypeDefault::bernoulli(const Tensor & self, Generator * generator) const {
    const DeviceGuard device_guard(self);
    return at::native::bernoulli(/* native_actuals */ self, generator);
}
Tensor & TypeDefault::bernoulli_out(Tensor & result, const Tensor & self, Generator * generator) const {
    const DeviceGuard device_guard(result);
    return at::native::bernoulli_out(/* native_actuals */ result, self, generator);
}
Tensor & TypeDefault::bernoulli_(Tensor & self, const Tensor & p, Generator * generator) const {
    AT_ERROR("bernoulli_ is not implemented for type ", toString());
}
Tensor & TypeDefault::bernoulli_(Tensor & self, double p, Generator * generator) const {
    AT_ERROR("bernoulli_ is not implemented for type ", toString());
}
Tensor TypeDefault::bernoulli(const Tensor & self, double p, Generator * generator) const {
    const DeviceGuard device_guard(self);
    return at::native::bernoulli(/* native_actuals */ self, p, generator);
}
Tensor TypeDefault::bilinear(const Tensor & input1, const Tensor & input2, const Tensor & weight, const Tensor & bias) const {
    const DeviceGuard device_guard(input1);
    return at::native::bilinear(/* native_actuals */ input1, input2, weight, bias);
}
Tensor TypeDefault::binary_cross_entropy_with_logits(const Tensor & self, const Tensor & target, const Tensor & weight, const Tensor & pos_weight, int64_t reduction) const {
    const DeviceGuard device_guard(self);
    return at::native::binary_cross_entropy_with_logits(/* native_actuals */ self, target, weight, pos_weight, reduction);
}
Tensor TypeDefault::binary_cross_entropy_with_logits_backward(const Tensor & grad_output, const Tensor & self, const Tensor & target, const Tensor & weight, const Tensor & pos_weight, int64_t reduction) const {
    const DeviceGuard device_guard(grad_output);
    return at::native::binary_cross_entropy_with_logits_backward(/* native_actuals */ grad_output, self, target, weight, pos_weight, reduction);
}
Tensor TypeDefault::bincount(const Tensor & self, const Tensor & weights, int64_t minlength) const {
    AT_ERROR("bincount is not implemented for type ", toString());
}
Tensor TypeDefault::bmm(const Tensor & self, const Tensor & mat2) const {
    AT_ERROR("bmm is not implemented for type ", toString());
}
Tensor & TypeDefault::bmm_out(Tensor & result, const Tensor & self, const Tensor & mat2) const {
    AT_ERROR("bmm_out is not implemented for type ", toString());
}
std::vector<Tensor> TypeDefault::broadcast_tensors(TensorList tensors) const {
    const DeviceGuard device_guard(tensors);
    return at::native::broadcast_tensors(/* native_actuals */ tensors);
}
Tensor TypeDefault::cat(TensorList tensors, int64_t dim) const {
    const DeviceGuard device_guard(tensors);
    return at::native::cat(/* native_actuals */ tensors, dim);
}
Tensor & TypeDefault::cat_out(Tensor & result, TensorList tensors, int64_t dim) const {
    const DeviceGuard device_guard(result);
    return at::native::cat_out(/* native_actuals */ result, tensors, dim);
}
Tensor TypeDefault::ceil(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::ceil(/* native_actuals */ self);
}
Tensor & TypeDefault::ceil_(Tensor & self) const {
    AT_ERROR("ceil_ is not implemented for type ", toString());
}
Tensor & TypeDefault::ceil_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("ceil_out is not implemented for type ", toString());
}
Tensor TypeDefault::chain_matmul(TensorList matrices) const {
    const DeviceGuard device_guard(matrices);
    return at::native::chain_matmul(/* native_actuals */ matrices);
}
std::vector<Tensor> TypeDefault::chunk(const Tensor & self, int64_t chunks, int64_t dim) const {
    const DeviceGuard device_guard(self);
    return at::native::chunk(/* native_actuals */ self, chunks, dim);
}
Tensor TypeDefault::clamp(const Tensor & self, c10::optional<Scalar> min, c10::optional<Scalar> max) const {
    const DeviceGuard device_guard(self);
    return at::native::clamp(/* native_actuals */ self, min, max);
}
Tensor & TypeDefault::clamp_(Tensor & self, c10::optional<Scalar> min, c10::optional<Scalar> max) const {
    AT_ERROR("clamp_ is not implemented for type ", toString());
}
Tensor & TypeDefault::clamp_out(Tensor & result, const Tensor & self, c10::optional<Scalar> min, c10::optional<Scalar> max) const {
    AT_ERROR("clamp_out is not implemented for type ", toString());
}
Tensor TypeDefault::clamp_max(const Tensor & self, Scalar max) const {
    const DeviceGuard device_guard(self);
    return at::native::clamp_max(/* native_actuals */ self, max);
}
Tensor & TypeDefault::clamp_max_(Tensor & self, Scalar max) const {
    AT_ERROR("clamp_max_ is not implemented for type ", toString());
}
Tensor & TypeDefault::clamp_max_out(Tensor & result, const Tensor & self, Scalar max) const {
    AT_ERROR("clamp_max_out is not implemented for type ", toString());
}
Tensor TypeDefault::clamp_min(const Tensor & self, Scalar min) const {
    const DeviceGuard device_guard(self);
    return at::native::clamp_min(/* native_actuals */ self, min);
}
Tensor & TypeDefault::clamp_min_(Tensor & self, Scalar min) const {
    AT_ERROR("clamp_min_ is not implemented for type ", toString());
}
Tensor & TypeDefault::clamp_min_out(Tensor & result, const Tensor & self, Scalar min) const {
    AT_ERROR("clamp_min_out is not implemented for type ", toString());
}
bool TypeDefault::cudnn_is_acceptable(const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::cudnn_is_acceptable(/* native_actuals */ self);
}
Tensor TypeDefault::constant_pad_nd(const Tensor & self, IntList pad, Scalar value) const {
    const DeviceGuard device_guard(self);
    return at::native::constant_pad_nd(/* native_actuals */ self, pad, value);
}
Tensor TypeDefault::contiguous(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::contiguous(/* native_actuals */ self);
}
Tensor TypeDefault::convolution(const Tensor & input, const Tensor & weight, const Tensor & bias, IntList stride, IntList padding, IntList dilation, bool transposed, IntList output_padding, int64_t groups) const {
    const DeviceGuard device_guard(input);
    return at::native::convolution(/* native_actuals */ input, weight, bias, stride, padding, dilation, transposed, output_padding, groups);
}
Tensor TypeDefault::_convolution(const Tensor & input, const Tensor & weight, const Tensor & bias, IntList stride, IntList padding, IntList dilation, bool transposed, IntList output_padding, int64_t groups, bool benchmark, bool deterministic, bool cudnn_enabled) const {
    const DeviceGuard device_guard(input);
    return at::native::_convolution(/* native_actuals */ input, weight, bias, stride, padding, dilation, transposed, output_padding, groups, benchmark, deterministic, cudnn_enabled);
}
Tensor TypeDefault::_convolution_nogroup(const Tensor & input, const Tensor & weight, const Tensor & bias, IntList stride, IntList padding, IntList dilation, bool transposed, IntList output_padding) const {
    const DeviceGuard device_guard(input);
    return at::native::_convolution_nogroup(/* native_actuals */ input, weight, bias, stride, padding, dilation, transposed, output_padding);
}
std::tuple<Tensor,Tensor,Tensor> TypeDefault::_convolution_double_backward(const Tensor & ggI, const Tensor & ggW, const Tensor & ggb, const Tensor & gO, const Tensor & weight, const Tensor & self, IntList stride, IntList padding, IntList dilation, bool transposed, IntList output_padding, int64_t groups, bool benchmark, bool deterministic, bool cudnn_enabled, std::array<bool,3> output_mask) const {
    const DeviceGuard device_guard(ggI);
    return at::native::_convolution_double_backward(/* native_actuals */ ggI, ggW, ggb, gO, weight, self, stride, padding, dilation, transposed, output_padding, groups, benchmark, deterministic, cudnn_enabled, output_mask);
}
Tensor TypeDefault::conv1d(const Tensor & input, const Tensor & weight, const Tensor & bias, IntList stride, IntList padding, IntList dilation, int64_t groups) const {
    const DeviceGuard device_guard(input);
    return at::native::conv1d(/* native_actuals */ input, weight, bias, stride, padding, dilation, groups);
}
Tensor TypeDefault::conv2d(const Tensor & input, const Tensor & weight, const Tensor & bias, IntList stride, IntList padding, IntList dilation, int64_t groups) const {
    const DeviceGuard device_guard(input);
    return at::native::conv2d(/* native_actuals */ input, weight, bias, stride, padding, dilation, groups);
}
Tensor TypeDefault::conv3d(const Tensor & input, const Tensor & weight, const Tensor & bias, IntList stride, IntList padding, IntList dilation, int64_t groups) const {
    const DeviceGuard device_guard(input);
    return at::native::conv3d(/* native_actuals */ input, weight, bias, stride, padding, dilation, groups);
}
Tensor TypeDefault::conv_tbc(const Tensor & self, const Tensor & weight, const Tensor & bias, int64_t pad) const {
    const DeviceGuard device_guard(self);
    return at::native::conv_tbc(/* native_actuals */ self, weight, bias, pad);
}
std::tuple<Tensor,Tensor,Tensor> TypeDefault::conv_tbc_backward(const Tensor & self, const Tensor & input, const Tensor & weight, const Tensor & bias, int64_t pad) const {
    const DeviceGuard device_guard(self);
    return at::native::conv_tbc_backward(/* native_actuals */ self, input, weight, bias, pad);
}
Tensor TypeDefault::conv_transpose1d(const Tensor & input, const Tensor & weight, const Tensor & bias, IntList stride, IntList padding, IntList output_padding, int64_t groups, IntList dilation) const {
    const DeviceGuard device_guard(input);
    return at::native::conv_transpose1d(/* native_actuals */ input, weight, bias, stride, padding, output_padding, groups, dilation);
}
Tensor TypeDefault::conv_transpose2d(const Tensor & input, const Tensor & weight, const Tensor & bias, IntList stride, IntList padding, IntList output_padding, int64_t groups, IntList dilation) const {
    const DeviceGuard device_guard(input);
    return at::native::conv_transpose2d(/* native_actuals */ input, weight, bias, stride, padding, output_padding, groups, dilation);
}
Tensor TypeDefault::conv_transpose3d(const Tensor & input, const Tensor & weight, const Tensor & bias, IntList stride, IntList padding, IntList output_padding, int64_t groups, IntList dilation) const {
    const DeviceGuard device_guard(input);
    return at::native::conv_transpose3d(/* native_actuals */ input, weight, bias, stride, padding, output_padding, groups, dilation);
}
Tensor TypeDefault::cos(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::cos(/* native_actuals */ self);
}
Tensor & TypeDefault::cos_(Tensor & self) const {
    AT_ERROR("cos_ is not implemented for type ", toString());
}
Tensor & TypeDefault::cos_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("cos_out is not implemented for type ", toString());
}
Tensor TypeDefault::cosh(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::cosh(/* native_actuals */ self);
}
Tensor & TypeDefault::cosh_(Tensor & self) const {
    AT_ERROR("cosh_ is not implemented for type ", toString());
}
Tensor & TypeDefault::cosh_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("cosh_out is not implemented for type ", toString());
}
Tensor TypeDefault::cosine_embedding_loss(const Tensor & input1, const Tensor & input2, const Tensor & target, double margin, int64_t reduction) const {
    const DeviceGuard device_guard(input1);
    return at::native::cosine_embedding_loss(/* native_actuals */ input1, input2, target, margin, reduction);
}
Tensor TypeDefault::cudnn_affine_grid_generator(const Tensor & theta, int64_t N, int64_t C, int64_t H, int64_t W) const {
    AT_ERROR("cudnn_affine_grid_generator is not implemented for type ", toString());
}
Tensor TypeDefault::cudnn_affine_grid_generator_backward(const Tensor & grad, int64_t N, int64_t C, int64_t H, int64_t W) const {
    AT_ERROR("cudnn_affine_grid_generator_backward is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor,Tensor> TypeDefault::cudnn_batch_norm(const Tensor & input, const Tensor & weight, const Tensor & bias, const Tensor & running_mean, const Tensor & running_var, bool training, double exponential_average_factor, double epsilon) const {
    AT_ERROR("cudnn_batch_norm is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor,Tensor> TypeDefault::cudnn_batch_norm_backward(const Tensor & input, const Tensor & grad_output, const Tensor & weight, const Tensor & running_mean, const Tensor & running_var, const Tensor & save_mean, const Tensor & save_var, double epsilon) const {
    AT_ERROR("cudnn_batch_norm_backward is not implemented for type ", toString());
}
Tensor TypeDefault::cudnn_convolution(const Tensor & self, const Tensor & weight, const Tensor & bias, IntList padding, IntList stride, IntList dilation, int64_t groups, bool benchmark, bool deterministic) const {
    AT_ERROR("cudnn_convolution is not implemented for type ", toString());
}
Tensor TypeDefault::cudnn_convolution_backward_input(IntList self_size, const Tensor & grad_output, const Tensor & weight, IntList padding, IntList stride, IntList dilation, int64_t groups, bool benchmark, bool deterministic) const {
    AT_ERROR("cudnn_convolution_backward_input is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor,Tensor> TypeDefault::cudnn_convolution_backward(const Tensor & self, const Tensor & grad_output, const Tensor & weight, IntList padding, IntList stride, IntList dilation, int64_t groups, bool benchmark, bool deterministic, std::array<bool,3> output_mask) const {
    AT_ERROR("cudnn_convolution_backward is not implemented for type ", toString());
}
Tensor TypeDefault::cudnn_convolution_backward_bias(const Tensor & grad_output) const {
    AT_ERROR("cudnn_convolution_backward_bias is not implemented for type ", toString());
}
Tensor TypeDefault::cudnn_convolution_backward_weight(IntList weight_size, const Tensor & grad_output, const Tensor & self, IntList padding, IntList stride, IntList dilation, int64_t groups, bool benchmark, bool deterministic) const {
    AT_ERROR("cudnn_convolution_backward_weight is not implemented for type ", toString());
}
Tensor TypeDefault::cudnn_convolution_transpose(const Tensor & self, const Tensor & weight, const Tensor & bias, IntList padding, IntList output_padding, IntList stride, IntList dilation, int64_t groups, bool benchmark, bool deterministic) const {
    AT_ERROR("cudnn_convolution_transpose is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor,Tensor> TypeDefault::cudnn_convolution_transpose_backward(const Tensor & self, const Tensor & grad_output, const Tensor & weight, IntList padding, IntList output_padding, IntList stride, IntList dilation, int64_t groups, bool benchmark, bool deterministic, std::array<bool,3> output_mask) const {
    AT_ERROR("cudnn_convolution_transpose_backward is not implemented for type ", toString());
}
Tensor TypeDefault::cudnn_convolution_transpose_backward_bias(const Tensor & grad_output) const {
    AT_ERROR("cudnn_convolution_transpose_backward_bias is not implemented for type ", toString());
}
Tensor TypeDefault::cudnn_convolution_transpose_backward_input(const Tensor & grad_output, const Tensor & weight, IntList padding, IntList stride, IntList dilation, int64_t groups, bool benchmark, bool deterministic) const {
    AT_ERROR("cudnn_convolution_transpose_backward_input is not implemented for type ", toString());
}
Tensor TypeDefault::cudnn_convolution_transpose_backward_weight(IntList weight_size, const Tensor & grad_output, const Tensor & self, IntList padding, IntList stride, IntList dilation, int64_t groups, bool benchmark, bool deterministic) const {
    AT_ERROR("cudnn_convolution_transpose_backward_weight is not implemented for type ", toString());
}
Tensor TypeDefault::cudnn_grid_sampler(const Tensor & self, const Tensor & grid) const {
    AT_ERROR("cudnn_grid_sampler is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::cudnn_grid_sampler_backward(const Tensor & self, const Tensor & grid, const Tensor & grad_output) const {
    AT_ERROR("cudnn_grid_sampler_backward is not implemented for type ", toString());
}
Tensor TypeDefault::cumsum(const Tensor & self, int64_t dim, ScalarType dtype) const {
    const DeviceGuard device_guard(self);
    return at::native::cumsum(/* native_actuals */ self, dim, dtype);
}
Tensor TypeDefault::cumsum(const Tensor & self, int64_t dim) const {
    const DeviceGuard device_guard(self);
    return at::native::cumsum(/* native_actuals */ self, dim);
}
Tensor & TypeDefault::cumsum_out(Tensor & result, const Tensor & self, int64_t dim, ScalarType dtype) const {
    const DeviceGuard device_guard(result);
    return at::native::cumsum_out(/* native_actuals */ result, self, dim, dtype);
}
Tensor & TypeDefault::cumsum_out(Tensor & result, const Tensor & self, int64_t dim) const {
    const DeviceGuard device_guard(result);
    return at::native::cumsum_out(/* native_actuals */ result, self, dim);
}
Tensor TypeDefault::cumprod(const Tensor & self, int64_t dim, ScalarType dtype) const {
    const DeviceGuard device_guard(self);
    return at::native::cumprod(/* native_actuals */ self, dim, dtype);
}
Tensor TypeDefault::cumprod(const Tensor & self, int64_t dim) const {
    const DeviceGuard device_guard(self);
    return at::native::cumprod(/* native_actuals */ self, dim);
}
Tensor & TypeDefault::cumprod_out(Tensor & result, const Tensor & self, int64_t dim, ScalarType dtype) const {
    const DeviceGuard device_guard(result);
    return at::native::cumprod_out(/* native_actuals */ result, self, dim, dtype);
}
Tensor & TypeDefault::cumprod_out(Tensor & result, const Tensor & self, int64_t dim) const {
    const DeviceGuard device_guard(result);
    return at::native::cumprod_out(/* native_actuals */ result, self, dim);
}
Tensor TypeDefault::ctc_loss(const Tensor & log_probs, const Tensor & targets, IntList input_lengths, IntList target_lengths, int64_t blank, int64_t reduction) const {
    const DeviceGuard device_guard(log_probs);
    return at::native::ctc_loss(/* native_actuals */ log_probs, targets, input_lengths, target_lengths, blank, reduction);
}
Tensor TypeDefault::ctc_loss(const Tensor & log_probs, const Tensor & targets, const Tensor & input_lengths, const Tensor & target_lengths, int64_t blank, int64_t reduction) const {
    const DeviceGuard device_guard(log_probs);
    return at::native::ctc_loss(/* native_actuals */ log_probs, targets, input_lengths, target_lengths, blank, reduction);
}
std::tuple<Tensor,Tensor> TypeDefault::_ctc_loss(const Tensor & log_probs, const Tensor & targets, IntList input_lengths, IntList target_lengths, int64_t blank) const {
    AT_ERROR("_ctc_loss is not implemented for type ", toString());
}
Tensor TypeDefault::_ctc_loss_backward(const Tensor & grad, const Tensor & log_probs, const Tensor & targets, IntList input_lengths, IntList target_lengths, const Tensor & neg_log_likelihood, const Tensor & log_alpha, int64_t blank) const {
    AT_ERROR("_ctc_loss_backward is not implemented for type ", toString());
}
Tensor TypeDefault::det(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::det(/* native_actuals */ self);
}
Tensor TypeDefault::diagflat(const Tensor & self, int64_t offset) const {
    const DeviceGuard device_guard(self);
    return at::native::diagflat(/* native_actuals */ self, offset);
}
Tensor TypeDefault::diagonal(const Tensor & self, int64_t offset, int64_t dim1, int64_t dim2) const {
    const DeviceGuard device_guard(self);
    return at::native::diagonal(/* native_actuals */ self, offset, dim1, dim2);
}
Tensor TypeDefault::div(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    return at::native::div(/* native_actuals */ self, other);
}
Tensor & TypeDefault::div_(Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    return at::native::div_(/* native_actuals */ self, other);
}
Tensor & TypeDefault::div_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(result);
    return at::native::div_out(/* native_actuals */ result, self, other);
}
Tensor TypeDefault::div(const Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    return at::native::div(/* native_actuals */ self, other);
}
Tensor & TypeDefault::div_(Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    return at::native::div_(/* native_actuals */ self, other);
}
Tensor TypeDefault::dot(const Tensor & self, const Tensor & tensor) const {
    const DeviceGuard device_guard(self);
    return at::native::dot(/* native_actuals */ self, tensor);
}
Tensor & TypeDefault::dot_out(Tensor & result, const Tensor & self, const Tensor & tensor) const {
    const DeviceGuard device_guard(result);
    return at::native::dot_out(/* native_actuals */ result, self, tensor);
}
Tensor TypeDefault::einsum(std::string equation, TensorList tensors) const {
    const DeviceGuard device_guard(tensors);
    return at::native::einsum(/* native_actuals */ equation, tensors);
}
Tensor TypeDefault::embedding(const Tensor & weight, const Tensor & indices, int64_t padding_idx, bool scale_grad_by_freq, bool sparse) const {
    const DeviceGuard device_guard(weight);
    return at::native::embedding(/* native_actuals */ weight, indices, padding_idx, scale_grad_by_freq, sparse);
}
Tensor TypeDefault::embedding_backward(const Tensor & grad, const Tensor & indices, int64_t num_weights, int64_t padding_idx, bool scale_grad_by_freq, bool sparse) const {
    const DeviceGuard device_guard(grad);
    return at::native::embedding_backward(/* native_actuals */ grad, indices, num_weights, padding_idx, scale_grad_by_freq, sparse);
}
Tensor TypeDefault::embedding_dense_backward(const Tensor & grad, const Tensor & indices, int64_t num_weights, int64_t padding_idx, bool scale_grad_by_freq) const {
    AT_ERROR("embedding_dense_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::embedding_renorm_(Tensor & self, const Tensor & indices, double max_norm, double norm_type) const {
    AT_ERROR("embedding_renorm_ is not implemented for type ", toString());
}
Tensor TypeDefault::embedding_sparse_backward(const Tensor & grad, const Tensor & indices, int64_t num_weights, int64_t padding_idx, bool scale_grad_by_freq) const {
    const DeviceGuard device_guard(grad);
    return at::native::embedding_sparse_backward(/* native_actuals */ grad, indices, num_weights, padding_idx, scale_grad_by_freq);
}
std::tuple<Tensor,Tensor,Tensor,Tensor> TypeDefault::embedding_bag(const Tensor & weight, const Tensor & indices, const Tensor & offsets, bool scale_grad_by_freq, int64_t mode, bool sparse) const {
    const DeviceGuard device_guard(weight);
    return at::native::embedding_bag(/* native_actuals */ weight, indices, offsets, scale_grad_by_freq, mode, sparse);
}
std::tuple<Tensor,Tensor,Tensor,Tensor> TypeDefault::_embedding_bag(const Tensor & weight, const Tensor & indices, const Tensor & offsets, bool scale_grad_by_freq, int64_t mode, bool sparse) const {
    AT_ERROR("_embedding_bag is not implemented for type ", toString());
}
Tensor TypeDefault::_embedding_bag_backward(const Tensor & grad, const Tensor & indices, const Tensor & offsets, const Tensor & offset2bag, const Tensor & bag_size, const Tensor & maximum_indices, int64_t num_weights, bool scale_grad_by_freq, int64_t mode, bool sparse) const {
    const DeviceGuard device_guard(grad);
    return at::native::_embedding_bag_backward(/* native_actuals */ grad, indices, offsets, offset2bag, bag_size, maximum_indices, num_weights, scale_grad_by_freq, mode, sparse);
}
Tensor TypeDefault::_embedding_bag_sparse_backward(const Tensor & grad, const Tensor & indices, const Tensor & offsets, const Tensor & offset2bag, const Tensor & bag_size, int64_t num_weights, bool scale_grad_by_freq, int64_t mode) const {
    const DeviceGuard device_guard(grad);
    return at::native::_embedding_bag_sparse_backward(/* native_actuals */ grad, indices, offsets, offset2bag, bag_size, num_weights, scale_grad_by_freq, mode);
}
Tensor TypeDefault::_embedding_bag_dense_backward(const Tensor & grad, const Tensor & indices, const Tensor & offsets, const Tensor & offset2bag, const Tensor & bag_size, const Tensor & maximum_indices, int64_t num_weights, bool scale_grad_by_freq, int64_t mode) const {
    AT_ERROR("_embedding_bag_dense_backward is not implemented for type ", toString());
}
Tensor TypeDefault::empty(IntList size, const TensorOptions & options) const {
    AT_ERROR("empty is not implemented for type ", toString());
}
Tensor & TypeDefault::resize_(Tensor & self, IntList size) const {
    AT_ERROR("resize_ is not implemented for type ", toString());
}
Tensor & TypeDefault::empty_out(Tensor & result, IntList size) const {
    const DeviceGuard device_guard(result);
    return at::native::empty_out(/* native_actuals */ result, size);
}
Tensor TypeDefault::empty_like(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::empty_like(/* native_actuals */ self);
}
Tensor TypeDefault::erf(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::erf(/* native_actuals */ self);
}
Tensor & TypeDefault::erf_(Tensor & self) const {
    AT_ERROR("erf_ is not implemented for type ", toString());
}
Tensor & TypeDefault::erf_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("erf_out is not implemented for type ", toString());
}
Tensor TypeDefault::erfc(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::erfc(/* native_actuals */ self);
}
Tensor & TypeDefault::erfc_(Tensor & self) const {
    AT_ERROR("erfc_ is not implemented for type ", toString());
}
Tensor & TypeDefault::erfc_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("erfc_out is not implemented for type ", toString());
}
Tensor TypeDefault::exp(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::exp(/* native_actuals */ self);
}
Tensor & TypeDefault::exp_(Tensor & self) const {
    AT_ERROR("exp_ is not implemented for type ", toString());
}
Tensor & TypeDefault::exp_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("exp_out is not implemented for type ", toString());
}
Tensor TypeDefault::expm1(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::expm1(/* native_actuals */ self);
}
Tensor & TypeDefault::expm1_(Tensor & self) const {
    AT_ERROR("expm1_ is not implemented for type ", toString());
}
Tensor & TypeDefault::expm1_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("expm1_out is not implemented for type ", toString());
}
Tensor TypeDefault::expand(const Tensor & self, IntList size, bool implicit) const {
    const DeviceGuard device_guard(self);
    return at::native::expand(/* native_actuals */ self, size, implicit);
}
Tensor TypeDefault::expand_as(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    return at::native::expand_as(/* native_actuals */ self, other);
}
Tensor & TypeDefault::eye_out(Tensor & result, int64_t n) const {
    AT_ERROR("eye_out is not implemented for type ", toString());
}
Tensor & TypeDefault::eye_out(Tensor & result, int64_t n, int64_t m) const {
    AT_ERROR("eye_out is not implemented for type ", toString());
}
Tensor TypeDefault::flatten(const Tensor & self, int64_t start_dim, int64_t end_dim) const {
    const DeviceGuard device_guard(self);
    return at::native::flatten(/* native_actuals */ self, start_dim, end_dim);
}
Tensor & TypeDefault::fill_(Tensor & self, Scalar value) const {
    const DeviceGuard device_guard(self);
    return at::native::fill_(/* native_actuals */ self, value);
}
Tensor & TypeDefault::fill_(Tensor & self, const Tensor & value) const {
    const DeviceGuard device_guard(self);
    return at::native::fill_(/* native_actuals */ self, value);
}
Tensor TypeDefault::floor(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::floor(/* native_actuals */ self);
}
Tensor & TypeDefault::floor_(Tensor & self) const {
    AT_ERROR("floor_ is not implemented for type ", toString());
}
Tensor & TypeDefault::floor_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("floor_out is not implemented for type ", toString());
}
Tensor & TypeDefault::full_out(Tensor & result, IntList size, Scalar fill_value) const {
    const DeviceGuard device_guard(result);
    return at::native::full_out(/* native_actuals */ result, size, fill_value);
}
Tensor TypeDefault::full_like(const Tensor & self, Scalar fill_value) const {
    const DeviceGuard device_guard(self);
    return at::native::full_like(/* native_actuals */ self, fill_value);
}
Tensor TypeDefault::grid_sampler(const Tensor & input, const Tensor & grid, int64_t interpolation_mode, int64_t padding_mode) const {
    const DeviceGuard device_guard(input);
    return at::native::grid_sampler(/* native_actuals */ input, grid, interpolation_mode, padding_mode);
}
Tensor TypeDefault::grid_sampler_2d(const Tensor & input, const Tensor & grid, int64_t interpolation_mode, int64_t padding_mode) const {
    AT_ERROR("grid_sampler_2d is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::grid_sampler_2d_backward(const Tensor & grad_output, const Tensor & input, const Tensor & grid, int64_t interpolation_mode, int64_t padding_mode) const {
    AT_ERROR("grid_sampler_2d_backward is not implemented for type ", toString());
}
Tensor TypeDefault::grid_sampler_3d(const Tensor & input, const Tensor & grid, int64_t interpolation_mode, int64_t padding_mode) const {
    AT_ERROR("grid_sampler_3d is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::grid_sampler_3d_backward(const Tensor & grad_output, const Tensor & input, const Tensor & grid, int64_t interpolation_mode, int64_t padding_mode) const {
    AT_ERROR("grid_sampler_3d_backward is not implemented for type ", toString());
}
Tensor TypeDefault::hinge_embedding_loss(const Tensor & self, const Tensor & target, double margin, int64_t reduction) const {
    const DeviceGuard device_guard(self);
    return at::native::hinge_embedding_loss(/* native_actuals */ self, target, margin, reduction);
}
Tensor TypeDefault::ger(const Tensor & self, const Tensor & vec2) const {
    const DeviceGuard device_guard(self);
    return at::native::ger(/* native_actuals */ self, vec2);
}
Tensor & TypeDefault::ger_out(Tensor & result, const Tensor & self, const Tensor & vec2) const {
    const DeviceGuard device_guard(result);
    return at::native::ger_out(/* native_actuals */ result, self, vec2);
}
std::tuple<Tensor,Tensor> TypeDefault::gesv(const Tensor & self, const Tensor & A) const {
    const DeviceGuard device_guard(self);
    return at::native::gesv(/* native_actuals */ self, A);
}
std::tuple<Tensor &,Tensor &> TypeDefault::gesv_out(Tensor & solution, Tensor & lu, const Tensor & self, const Tensor & A) const {
    const DeviceGuard device_guard(solution);
    return at::native::gesv_out(/* native_actuals */ solution, lu, self, A);
}
std::tuple<Tensor,Tensor> TypeDefault::_gesv_helper(const Tensor & self, const Tensor & A) const {
    AT_ERROR("_gesv_helper is not implemented for type ", toString());
}
Tensor TypeDefault::group_norm(const Tensor & input, int64_t num_groups, const Tensor & weight, const Tensor & bias, double eps, bool cudnn_enabled) const {
    const DeviceGuard device_guard(input);
    return at::native::group_norm(/* native_actuals */ input, num_groups, weight, bias, eps, cudnn_enabled);
}
Tensor TypeDefault::fft(const Tensor & self, int64_t signal_ndim, bool normalized) const {
    const DeviceGuard device_guard(self);
    return at::native::fft(/* native_actuals */ self, signal_ndim, normalized);
}
Tensor TypeDefault::ifft(const Tensor & self, int64_t signal_ndim, bool normalized) const {
    const DeviceGuard device_guard(self);
    return at::native::ifft(/* native_actuals */ self, signal_ndim, normalized);
}
Tensor TypeDefault::rfft(const Tensor & self, int64_t signal_ndim, bool normalized, bool onesided) const {
    const DeviceGuard device_guard(self);
    return at::native::rfft(/* native_actuals */ self, signal_ndim, normalized, onesided);
}
Tensor TypeDefault::irfft(const Tensor & self, int64_t signal_ndim, bool normalized, bool onesided, IntList signal_sizes) const {
    const DeviceGuard device_guard(self);
    return at::native::irfft(/* native_actuals */ self, signal_ndim, normalized, onesided, signal_sizes);
}
Tensor TypeDefault::_fft_with_size(const Tensor & self, int64_t signal_ndim, bool complex_input, bool complex_output, bool inverse, IntList checked_signal_sizes, bool normalized, bool onesided, IntList output_sizes) const {
    AT_ERROR("_fft_with_size is not implemented for type ", toString());
}
int64_t TypeDefault::_cufft_get_plan_cache_size() const {
    // DeviceGuard omitted
    return at::native::_cufft_get_plan_cache_size(/* native_actuals */ );
}
int64_t TypeDefault::_cufft_get_plan_cache_max_size() const {
    // DeviceGuard omitted
    return at::native::_cufft_get_plan_cache_max_size(/* native_actuals */ );
}
void TypeDefault::_cufft_set_plan_cache_max_size(int64_t max_size) const {
    // DeviceGuard omitted
     at::native::_cufft_set_plan_cache_max_size(/* native_actuals */ max_size);
}
void TypeDefault::_cufft_clear_plan_cache() const {
    // DeviceGuard omitted
     at::native::_cufft_clear_plan_cache(/* native_actuals */ );
}
Tensor TypeDefault::index(const Tensor & self, TensorList indices) const {
    const DeviceGuard device_guard(self);
    return at::native::index(/* native_actuals */ self, indices);
}
Tensor & TypeDefault::index_copy_(Tensor & self, int64_t dim, const Tensor & index, const Tensor & source) const {
    const DeviceGuard device_guard(self);
    return at::native::index_copy_(/* native_actuals */ self, dim, index, source);
}
Tensor TypeDefault::index_put(const Tensor & self, TensorList indices, const Tensor & values) const {
    const DeviceGuard device_guard(self);
    return at::native::index_put(/* native_actuals */ self, indices, values);
}
Tensor & TypeDefault::index_put_(Tensor & self, TensorList indices, const Tensor & values) const {
    const DeviceGuard device_guard(self);
    return at::native::index_put_(/* native_actuals */ self, indices, values);
}
Tensor TypeDefault::instance_norm(const Tensor & input, const Tensor & weight, const Tensor & bias, const Tensor & running_mean, const Tensor & running_var, bool use_input_stats, double momentum, double eps, bool cudnn_enabled) const {
    const DeviceGuard device_guard(input);
    return at::native::instance_norm(/* native_actuals */ input, weight, bias, running_mean, running_var, use_input_stats, momentum, eps, cudnn_enabled);
}
Tensor TypeDefault::inverse(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::inverse(/* native_actuals */ self);
}
Tensor & TypeDefault::inverse_out(Tensor & result, const Tensor & self) const {
    const DeviceGuard device_guard(result);
    return at::native::inverse_out(/* native_actuals */ result, self);
}
Tensor TypeDefault::isclose(const Tensor & self, const Tensor & other, double rtol, double atol, bool equal_nan) const {
    const DeviceGuard device_guard(self);
    return at::native::isclose(/* native_actuals */ self, other, rtol, atol, equal_nan);
}
bool TypeDefault::is_distributed(const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::is_distributed(/* native_actuals */ self);
}
bool TypeDefault::is_floating_point(const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::is_floating_point(/* native_actuals */ self);
}
bool TypeDefault::is_complex(const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::is_complex(/* native_actuals */ self);
}
bool TypeDefault::is_nonzero(const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::is_nonzero(/* native_actuals */ self);
}
bool TypeDefault::is_same_size(const Tensor & self, const Tensor & other) const {
    // DeviceGuard omitted
    return at::native::is_same_size(/* native_actuals */ self, other);
}
bool TypeDefault::is_signed(const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::is_signed(/* native_actuals */ self);
}
Tensor TypeDefault::kl_div(const Tensor & self, const Tensor & target, int64_t reduction) const {
    const DeviceGuard device_guard(self);
    return at::native::kl_div(/* native_actuals */ self, target, reduction);
}
Tensor TypeDefault::kl_div_backward(const Tensor & grad_output, const Tensor & self, const Tensor & target, int64_t reduction) const {
    AT_ERROR("kl_div_backward is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::kthvalue(const Tensor & self, int64_t k, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(self);
    return at::native::kthvalue(/* native_actuals */ self, k, dim, keepdim);
}
std::tuple<Tensor &,Tensor &> TypeDefault::kthvalue_out(Tensor & values, Tensor & indices, const Tensor & self, int64_t k, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(values);
    return at::native::kthvalue_out(/* native_actuals */ values, indices, self, k, dim, keepdim);
}
Tensor TypeDefault::layer_norm(const Tensor & input, IntList normalized_shape, const Tensor & weight, const Tensor & bias, double eps, bool cudnn_enable) const {
    const DeviceGuard device_guard(input);
    return at::native::layer_norm(/* native_actuals */ input, normalized_shape, weight, bias, eps, cudnn_enable);
}
Tensor TypeDefault::linear(const Tensor & input, const Tensor & weight, const Tensor & bias) const {
    const DeviceGuard device_guard(input);
    return at::native::linear(/* native_actuals */ input, weight, bias);
}
Tensor & TypeDefault::linspace_out(Tensor & result, Scalar start, Scalar end) const {
    const DeviceGuard device_guard(result);
    return at::native::linspace_out(/* native_actuals */ result, start, end);
}
Tensor & TypeDefault::linspace_out(Tensor & result, Scalar start, Scalar end, int64_t steps) const {
    const DeviceGuard device_guard(result);
    return at::native::linspace_out(/* native_actuals */ result, start, end, steps);
}
Tensor TypeDefault::log(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::log(/* native_actuals */ self);
}
Tensor & TypeDefault::log_(Tensor & self) const {
    AT_ERROR("log_ is not implemented for type ", toString());
}
Tensor & TypeDefault::log_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("log_out is not implemented for type ", toString());
}
Tensor TypeDefault::log10(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::log10(/* native_actuals */ self);
}
Tensor & TypeDefault::log10_(Tensor & self) const {
    AT_ERROR("log10_ is not implemented for type ", toString());
}
Tensor & TypeDefault::log10_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("log10_out is not implemented for type ", toString());
}
Tensor TypeDefault::log1p(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::log1p(/* native_actuals */ self);
}
Tensor & TypeDefault::log1p_(Tensor & self) const {
    AT_ERROR("log1p_ is not implemented for type ", toString());
}
Tensor & TypeDefault::log1p_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("log1p_out is not implemented for type ", toString());
}
Tensor TypeDefault::log2(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::log2(/* native_actuals */ self);
}
Tensor & TypeDefault::log2_(Tensor & self) const {
    AT_ERROR("log2_ is not implemented for type ", toString());
}
Tensor & TypeDefault::log2_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("log2_out is not implemented for type ", toString());
}
Tensor TypeDefault::logdet(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::logdet(/* native_actuals */ self);
}
Tensor & TypeDefault::logspace_out(Tensor & result, Scalar start, Scalar end) const {
    const DeviceGuard device_guard(result);
    return at::native::logspace_out(/* native_actuals */ result, start, end);
}
Tensor & TypeDefault::logspace_out(Tensor & result, Scalar start, Scalar end, int64_t steps) const {
    const DeviceGuard device_guard(result);
    return at::native::logspace_out(/* native_actuals */ result, start, end, steps);
}
Tensor TypeDefault::log_softmax(const Tensor & self, int64_t dim, ScalarType dtype) const {
    const DeviceGuard device_guard(self);
    return at::native::log_softmax(/* native_actuals */ self, dim, dtype);
}
Tensor TypeDefault::log_softmax(const Tensor & self, int64_t dim) const {
    const DeviceGuard device_guard(self);
    return at::native::log_softmax(/* native_actuals */ self, dim);
}
Tensor TypeDefault::_log_softmax(const Tensor & self, int64_t dim, bool half_to_float) const {
    AT_ERROR("_log_softmax is not implemented for type ", toString());
}
Tensor TypeDefault::_log_softmax_backward_data(const Tensor & grad_output, const Tensor & output, int64_t dim, const Tensor & self) const {
    AT_ERROR("_log_softmax_backward_data is not implemented for type ", toString());
}
Tensor TypeDefault::logsumexp(const Tensor & self, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(self);
    return at::native::logsumexp(/* native_actuals */ self, dim, keepdim);
}
Tensor & TypeDefault::logsumexp_out(Tensor & result, const Tensor & self, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(result);
    return at::native::logsumexp_out(/* native_actuals */ result, self, dim, keepdim);
}
Tensor TypeDefault::margin_ranking_loss(const Tensor & input1, const Tensor & input2, const Tensor & target, double margin, int64_t reduction) const {
    const DeviceGuard device_guard(input1);
    return at::native::margin_ranking_loss(/* native_actuals */ input1, input2, target, margin, reduction);
}
Tensor TypeDefault::matmul(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    return at::native::matmul(/* native_actuals */ self, other);
}
Tensor & TypeDefault::matmul_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(result);
    return at::native::matmul_out(/* native_actuals */ result, self, other);
}
Tensor TypeDefault::matrix_rank(const Tensor & self, double tol, bool symmetric) const {
    const DeviceGuard device_guard(self);
    return at::native::matrix_rank(/* native_actuals */ self, tol, symmetric);
}
Tensor TypeDefault::matrix_rank(const Tensor & self, bool symmetric) const {
    const DeviceGuard device_guard(self);
    return at::native::matrix_rank(/* native_actuals */ self, symmetric);
}
Tensor TypeDefault::matrix_power(const Tensor & self, int64_t n) const {
    const DeviceGuard device_guard(self);
    return at::native::matrix_power(/* native_actuals */ self, n);
}
std::tuple<Tensor,Tensor> TypeDefault::max(const Tensor & self, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(self);
    return at::native::max(/* native_actuals */ self, dim, keepdim);
}
std::tuple<Tensor &,Tensor &> TypeDefault::max_out(Tensor & max, Tensor & max_values, const Tensor & self, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(max);
    return at::native::max_out(/* native_actuals */ max, max_values, self, dim, keepdim);
}
Tensor TypeDefault::max_values(const Tensor & self, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(self);
    return at::native::max_values(/* native_actuals */ self, dim, keepdim);
}
std::tuple<Tensor,Tensor> TypeDefault::max_pool1d_with_indices(const Tensor & self, IntList kernel_size, IntList stride, IntList padding, IntList dilation, bool ceil_mode) const {
    const DeviceGuard device_guard(self);
    return at::native::max_pool1d_with_indices(/* native_actuals */ self, kernel_size, stride, padding, dilation, ceil_mode);
}
Tensor TypeDefault::max_pool1d(const Tensor & self, IntList kernel_size, IntList stride, IntList padding, IntList dilation, bool ceil_mode) const {
    const DeviceGuard device_guard(self);
    return at::native::max_pool1d(/* native_actuals */ self, kernel_size, stride, padding, dilation, ceil_mode);
}
Tensor TypeDefault::max_pool2d(const Tensor & self, IntList kernel_size, IntList stride, IntList padding, IntList dilation, bool ceil_mode) const {
    const DeviceGuard device_guard(self);
    return at::native::max_pool2d(/* native_actuals */ self, kernel_size, stride, padding, dilation, ceil_mode);
}
Tensor TypeDefault::max_pool3d(const Tensor & self, IntList kernel_size, IntList stride, IntList padding, IntList dilation, bool ceil_mode) const {
    const DeviceGuard device_guard(self);
    return at::native::max_pool3d(/* native_actuals */ self, kernel_size, stride, padding, dilation, ceil_mode);
}
Tensor TypeDefault::mean(const Tensor & self, ScalarType dtype) const {
    const DeviceGuard device_guard(self);
    return at::native::mean(/* native_actuals */ self, dtype);
}
Tensor TypeDefault::mean(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::mean(/* native_actuals */ self);
}
Tensor TypeDefault::mean(const Tensor & self, int64_t dim, bool keepdim, ScalarType dtype) const {
    const DeviceGuard device_guard(self);
    return at::native::mean(/* native_actuals */ self, dim, keepdim, dtype);
}
Tensor TypeDefault::mean(const Tensor & self, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(self);
    return at::native::mean(/* native_actuals */ self, dim, keepdim);
}
Tensor TypeDefault::mean(const Tensor & self, int64_t dim, ScalarType dtype) const {
    const DeviceGuard device_guard(self);
    return at::native::mean(/* native_actuals */ self, dim, dtype);
}
Tensor & TypeDefault::mean_out(Tensor & result, const Tensor & self, int64_t dim, bool keepdim, ScalarType dtype) const {
    const DeviceGuard device_guard(result);
    return at::native::mean_out(/* native_actuals */ result, self, dim, keepdim, dtype);
}
Tensor & TypeDefault::mean_out(Tensor & result, const Tensor & self, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(result);
    return at::native::mean_out(/* native_actuals */ result, self, dim, keepdim);
}
Tensor & TypeDefault::mean_out(Tensor & result, const Tensor & self, int64_t dim, ScalarType dtype) const {
    const DeviceGuard device_guard(result);
    return at::native::mean_out(/* native_actuals */ result, self, dim, dtype);
}
std::tuple<Tensor,Tensor> TypeDefault::median(const Tensor & self, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(self);
    return at::native::median(/* native_actuals */ self, dim, keepdim);
}
std::tuple<Tensor &,Tensor &> TypeDefault::median_out(Tensor & values, Tensor & indices, const Tensor & self, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(values);
    return at::native::median_out(/* native_actuals */ values, indices, self, dim, keepdim);
}
std::tuple<Tensor,Tensor> TypeDefault::min(const Tensor & self, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(self);
    return at::native::min(/* native_actuals */ self, dim, keepdim);
}
std::tuple<Tensor &,Tensor &> TypeDefault::min_out(Tensor & min, Tensor & min_indices, const Tensor & self, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(min);
    return at::native::min_out(/* native_actuals */ min, min_indices, self, dim, keepdim);
}
Tensor TypeDefault::min_values(const Tensor & self, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(self);
    return at::native::min_values(/* native_actuals */ self, dim, keepdim);
}
Tensor TypeDefault::mkldnn_convolution(const Tensor & self, const Tensor & weight, const Tensor & bias, IntList padding, IntList stride, IntList dilation, int64_t groups) const {
    const DeviceGuard device_guard(self);
    return at::native::mkldnn_convolution(/* native_actuals */ self, weight, bias, padding, stride, dilation, groups);
}
Tensor TypeDefault::mkldnn_convolution_backward_input(IntList self_size, const Tensor & grad_output, const Tensor & weight, IntList padding, IntList stride, IntList dilation, int64_t groups, bool bias_defined) const {
    const DeviceGuard device_guard(grad_output);
    return at::native::mkldnn_convolution_backward_input(/* native_actuals */ self_size, grad_output, weight, padding, stride, dilation, groups, bias_defined);
}
std::tuple<Tensor,Tensor> TypeDefault::mkldnn_convolution_backward_weights(IntList weight_size, const Tensor & grad_output, const Tensor & self, IntList padding, IntList stride, IntList dilation, int64_t groups, bool bias_defined) const {
    const DeviceGuard device_guard(grad_output);
    return at::native::mkldnn_convolution_backward_weights(/* native_actuals */ weight_size, grad_output, self, padding, stride, dilation, groups, bias_defined);
}
std::tuple<Tensor,Tensor,Tensor> TypeDefault::mkldnn_convolution_backward(const Tensor & self, const Tensor & grad_output, const Tensor & weight, IntList padding, IntList stride, IntList dilation, int64_t groups, std::array<bool,3> output_mask) const {
    const DeviceGuard device_guard(self);
    return at::native::mkldnn_convolution_backward(/* native_actuals */ self, grad_output, weight, padding, stride, dilation, groups, output_mask);
}
std::tuple<Tensor,Tensor,Tensor> TypeDefault::miopen_batch_norm(const Tensor & input, const Tensor & weight, const Tensor & bias, const Tensor & running_mean, const Tensor & running_var, bool training, double exponential_average_factor, double epsilon) const {
    AT_ERROR("miopen_batch_norm is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor,Tensor> TypeDefault::miopen_batch_norm_backward(const Tensor & input, const Tensor & grad_output, const Tensor & weight, const Tensor & running_mean, const Tensor & running_var, const Tensor & save_mean, const Tensor & save_var, double epsilon) const {
    AT_ERROR("miopen_batch_norm_backward is not implemented for type ", toString());
}
Tensor TypeDefault::miopen_convolution(const Tensor & self, const Tensor & weight, const Tensor & bias, IntList padding, IntList stride, IntList dilation, int64_t groups, bool benchmark, bool deterministic) const {
    AT_ERROR("miopen_convolution is not implemented for type ", toString());
}
Tensor TypeDefault::miopen_convolution_backward_input(IntList self_size, const Tensor & grad_output, const Tensor & weight, IntList padding, IntList stride, IntList dilation, int64_t groups, bool benchmark, bool deterministic) const {
    AT_ERROR("miopen_convolution_backward_input is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor,Tensor> TypeDefault::miopen_convolution_backward(const Tensor & self, const Tensor & grad_output, const Tensor & weight, IntList padding, IntList stride, IntList dilation, int64_t groups, bool benchmark, bool deterministic, std::array<bool,3> output_mask) const {
    AT_ERROR("miopen_convolution_backward is not implemented for type ", toString());
}
Tensor TypeDefault::miopen_convolution_backward_bias(const Tensor & grad_output) const {
    AT_ERROR("miopen_convolution_backward_bias is not implemented for type ", toString());
}
Tensor TypeDefault::miopen_convolution_backward_weight(IntList weight_size, const Tensor & grad_output, const Tensor & self, IntList padding, IntList stride, IntList dilation, int64_t groups, bool benchmark, bool deterministic) const {
    AT_ERROR("miopen_convolution_backward_weight is not implemented for type ", toString());
}
Tensor TypeDefault::miopen_convolution_transpose(const Tensor & self, const Tensor & weight, const Tensor & bias, IntList padding, IntList output_padding, IntList stride, IntList dilation, int64_t groups, bool benchmark, bool deterministic) const {
    AT_ERROR("miopen_convolution_transpose is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor,Tensor> TypeDefault::miopen_convolution_transpose_backward(const Tensor & self, const Tensor & grad_output, const Tensor & weight, IntList padding, IntList output_padding, IntList stride, IntList dilation, int64_t groups, bool benchmark, bool deterministic, std::array<bool,3> output_mask) const {
    AT_ERROR("miopen_convolution_transpose_backward is not implemented for type ", toString());
}
Tensor TypeDefault::miopen_convolution_transpose_backward_input(const Tensor & grad_output, const Tensor & weight, IntList padding, IntList stride, IntList dilation, int64_t groups, bool benchmark, bool deterministic) const {
    AT_ERROR("miopen_convolution_transpose_backward_input is not implemented for type ", toString());
}
Tensor TypeDefault::miopen_convolution_transpose_backward_weight(IntList weight_size, const Tensor & grad_output, const Tensor & self, IntList padding, IntList stride, IntList dilation, int64_t groups, bool benchmark, bool deterministic) const {
    AT_ERROR("miopen_convolution_transpose_backward_weight is not implemented for type ", toString());
}
Tensor TypeDefault::mm(const Tensor & self, const Tensor & mat2) const {
    const DeviceGuard device_guard(self);
    return at::native::mm(/* native_actuals */ self, mat2);
}
Tensor & TypeDefault::mm_out(Tensor & result, const Tensor & self, const Tensor & mat2) const {
    const DeviceGuard device_guard(result);
    return at::native::mm_out(/* native_actuals */ result, self, mat2);
}
std::tuple<Tensor,Tensor> TypeDefault::mode(const Tensor & self, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(self);
    return at::native::mode(/* native_actuals */ self, dim, keepdim);
}
std::tuple<Tensor &,Tensor &> TypeDefault::mode_out(Tensor & values, Tensor & indices, const Tensor & self, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(values);
    return at::native::mode_out(/* native_actuals */ values, indices, self, dim, keepdim);
}
Tensor TypeDefault::mul(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    return at::native::mul(/* native_actuals */ self, other);
}
Tensor & TypeDefault::mul_(Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    return at::native::mul_(/* native_actuals */ self, other);
}
Tensor & TypeDefault::mul_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(result);
    return at::native::mul_out(/* native_actuals */ result, self, other);
}
Tensor TypeDefault::mul(const Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    return at::native::mul(/* native_actuals */ self, other);
}
Tensor & TypeDefault::mul_(Tensor & self, Scalar other) const {
    const DeviceGuard device_guard(self);
    return at::native::mul_(/* native_actuals */ self, other);
}
Tensor TypeDefault::mv(const Tensor & self, const Tensor & vec) const {
    const DeviceGuard device_guard(self);
    return at::native::mv(/* native_actuals */ self, vec);
}
Tensor & TypeDefault::mv_out(Tensor & result, const Tensor & self, const Tensor & vec) const {
    const DeviceGuard device_guard(result);
    return at::native::mv_out(/* native_actuals */ result, self, vec);
}
Tensor TypeDefault::mvlgamma(const Tensor & self, int64_t p) const {
    const DeviceGuard device_guard(self);
    return at::native::mvlgamma(/* native_actuals */ self, p);
}
Tensor & TypeDefault::mvlgamma_(Tensor & self, int64_t p) const {
    const DeviceGuard device_guard(self);
    return at::native::mvlgamma_(/* native_actuals */ self, p);
}
Tensor TypeDefault::narrow_copy(const Tensor & self, int64_t dim, int64_t start, int64_t length) const {
    AT_ERROR("narrow_copy is not implemented for type ", toString());
}
Tensor TypeDefault::narrow(const Tensor & self, int64_t dim, int64_t start, int64_t length) const {
    const DeviceGuard device_guard(self);
    return at::native::narrow(/* native_actuals */ self, dim, start, length);
}
std::tuple<Tensor,Tensor,Tensor> TypeDefault::native_batch_norm(const Tensor & input, const Tensor & weight, const Tensor & bias, const Tensor & running_mean, const Tensor & running_var, bool training, double momentum, double eps) const {
    AT_ERROR("native_batch_norm is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor,Tensor> TypeDefault::native_batch_norm_backward(const Tensor & grad_out, const Tensor & input, const Tensor & weight, const Tensor & running_mean, const Tensor & running_var, const Tensor & save_mean, const Tensor & save_invstd, bool train, double eps, std::array<bool,3> output_mask) const {
    AT_ERROR("native_batch_norm_backward is not implemented for type ", toString());
}
Tensor & TypeDefault::ones_out(Tensor & result, IntList size) const {
    const DeviceGuard device_guard(result);
    return at::native::ones_out(/* native_actuals */ result, size);
}
Tensor TypeDefault::ones_like(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::ones_like(/* native_actuals */ self);
}
Tensor TypeDefault::pairwise_distance(const Tensor & x1, const Tensor & x2, double p, double eps, bool keepdim) const {
    const DeviceGuard device_guard(x1);
    return at::native::pairwise_distance(/* native_actuals */ x1, x2, p, eps, keepdim);
}
Tensor TypeDefault::pdist(const Tensor & self, double p) const {
    const DeviceGuard device_guard(self);
    return at::native::pdist(/* native_actuals */ self, p);
}
Tensor TypeDefault::_pdist_forward(const Tensor & self, double p) const {
    const DeviceGuard device_guard(self);
    return at::native::_pdist_forward(/* native_actuals */ self, p);
}
Tensor TypeDefault::_pdist_backward(const Tensor & grad, const Tensor & self, double p, const Tensor & pdist) const {
    const DeviceGuard device_guard(grad);
    return at::native::_pdist_backward(/* native_actuals */ grad, self, p, pdist);
}
Tensor TypeDefault::permute(const Tensor & self, IntList dims) const {
    const DeviceGuard device_guard(self);
    return at::native::permute(/* native_actuals */ self, dims);
}
Tensor TypeDefault::pixel_shuffle(const Tensor & self, int64_t upscale_factor) const {
    const DeviceGuard device_guard(self);
    return at::native::pixel_shuffle(/* native_actuals */ self, upscale_factor);
}
Tensor TypeDefault::pin_memory(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::pin_memory(/* native_actuals */ self);
}
Tensor TypeDefault::pinverse(const Tensor & self, double rcond) const {
    const DeviceGuard device_guard(self);
    return at::native::pinverse(/* native_actuals */ self, rcond);
}
Tensor & TypeDefault::rand_out(Tensor & result, IntList size) const {
    const DeviceGuard device_guard(result);
    return at::native::rand_out(/* native_actuals */ result, size);
}
Tensor & TypeDefault::rand_out(Tensor & result, IntList size, Generator * generator) const {
    const DeviceGuard device_guard(result);
    return at::native::rand_out(/* native_actuals */ result, size, generator);
}
Tensor TypeDefault::rand_like(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::rand_like(/* native_actuals */ self);
}
Tensor & TypeDefault::randint_out(Tensor & result, int64_t high, IntList size) const {
    const DeviceGuard device_guard(result);
    return at::native::randint_out(/* native_actuals */ result, high, size);
}
Tensor & TypeDefault::randint_out(Tensor & result, int64_t high, IntList size, Generator * generator) const {
    const DeviceGuard device_guard(result);
    return at::native::randint_out(/* native_actuals */ result, high, size, generator);
}
Tensor & TypeDefault::randint_out(Tensor & result, int64_t low, int64_t high, IntList size) const {
    const DeviceGuard device_guard(result);
    return at::native::randint_out(/* native_actuals */ result, low, high, size);
}
Tensor & TypeDefault::randint_out(Tensor & result, int64_t low, int64_t high, IntList size, Generator * generator) const {
    const DeviceGuard device_guard(result);
    return at::native::randint_out(/* native_actuals */ result, low, high, size, generator);
}
Tensor TypeDefault::randint_like(const Tensor & self, int64_t high) const {
    const DeviceGuard device_guard(self);
    return at::native::randint_like(/* native_actuals */ self, high);
}
Tensor TypeDefault::randint_like(const Tensor & self, int64_t low, int64_t high) const {
    const DeviceGuard device_guard(self);
    return at::native::randint_like(/* native_actuals */ self, low, high);
}
Tensor & TypeDefault::randn_out(Tensor & result, IntList size) const {
    const DeviceGuard device_guard(result);
    return at::native::randn_out(/* native_actuals */ result, size);
}
Tensor & TypeDefault::randn_out(Tensor & result, IntList size, Generator * generator) const {
    const DeviceGuard device_guard(result);
    return at::native::randn_out(/* native_actuals */ result, size, generator);
}
Tensor TypeDefault::randn_like(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::randn_like(/* native_actuals */ self);
}
Tensor & TypeDefault::randperm_out(Tensor & result, int64_t n) const {
    const DeviceGuard device_guard(result);
    return at::native::randperm_out(/* native_actuals */ result, n);
}
Tensor & TypeDefault::randperm_out(Tensor & result, int64_t n, Generator * generator) const {
    AT_ERROR("randperm_out is not implemented for type ", toString());
}
Tensor & TypeDefault::range_out(Tensor & result, Scalar start, Scalar end) const {
    const DeviceGuard device_guard(result);
    return at::native::range_out(/* native_actuals */ result, start, end);
}
Tensor & TypeDefault::range_out(Tensor & result, Scalar start, Scalar end, Scalar step) const {
    const DeviceGuard device_guard(result);
    return at::native::range_out(/* native_actuals */ result, start, end, step);
}
Tensor TypeDefault::repeat(const Tensor & self, IntList repeats) const {
    const DeviceGuard device_guard(self);
    return at::native::repeat(/* native_actuals */ self, repeats);
}
Tensor TypeDefault::reshape(const Tensor & self, IntList shape) const {
    const DeviceGuard device_guard(self);
    return at::native::reshape(/* native_actuals */ self, shape);
}
Tensor TypeDefault::reshape_as(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    return at::native::reshape_as(/* native_actuals */ self, other);
}
std::tuple<Tensor,Tensor> TypeDefault::RoiPooling2d_forward(const Tensor & input, const Tensor & rois, int64_t pooledHeight, int64_t pooledWidth, double spatialScale) const {
    AT_ERROR("RoiPooling2d_forward is not implemented for type ", toString());
}
Tensor TypeDefault::RoiPooling2d_backward(const Tensor & input, const Tensor & rois, int64_t pooledHeight, int64_t pooledWidth, double spatialScale, const Tensor & gradOutput, const Tensor & argmaxes) const {
    AT_ERROR("RoiPooling2d_backward is not implemented for type ", toString());
}
Tensor TypeDefault::round(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::round(/* native_actuals */ self);
}
Tensor & TypeDefault::round_(Tensor & self) const {
    AT_ERROR("round_ is not implemented for type ", toString());
}
Tensor & TypeDefault::round_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("round_out is not implemented for type ", toString());
}
Tensor TypeDefault::rrelu(const Tensor & self, Scalar lower, Scalar upper, bool training, Generator * generator) const {
    const DeviceGuard device_guard(self);
    return at::native::rrelu(/* native_actuals */ self, lower, upper, training, generator);
}
Tensor & TypeDefault::rrelu_(Tensor & self, Scalar lower, Scalar upper, bool training, Generator * generator) const {
    const DeviceGuard device_guard(self);
    return at::native::rrelu_(/* native_actuals */ self, lower, upper, training, generator);
}
Tensor TypeDefault::relu(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::relu(/* native_actuals */ self);
}
Tensor & TypeDefault::relu_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::relu_(/* native_actuals */ self);
}
Tensor TypeDefault::prelu(const Tensor & self, const Tensor & weight) const {
    AT_ERROR("prelu is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::prelu_backward(const Tensor & grad_output, const Tensor & self, const Tensor & weight) const {
    AT_ERROR("prelu_backward is not implemented for type ", toString());
}
Tensor TypeDefault::hardshrink(const Tensor & self, Scalar lambd) const {
    AT_ERROR("hardshrink is not implemented for type ", toString());
}
Tensor TypeDefault::hardshrink_backward(const Tensor & grad_out, const Tensor & self, Scalar lambd) const {
    AT_ERROR("hardshrink_backward is not implemented for type ", toString());
}
Tensor TypeDefault::rsqrt(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::rsqrt(/* native_actuals */ self);
}
Tensor & TypeDefault::rsqrt_(Tensor & self) const {
    AT_ERROR("rsqrt_ is not implemented for type ", toString());
}
Tensor & TypeDefault::rsqrt_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("rsqrt_out is not implemented for type ", toString());
}
Tensor TypeDefault::select(const Tensor & self, int64_t dim, int64_t index) const {
    const DeviceGuard device_guard(self);
    return at::native::select(/* native_actuals */ self, dim, index);
}
Tensor TypeDefault::selu(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::selu(/* native_actuals */ self);
}
Tensor & TypeDefault::selu_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::selu_(/* native_actuals */ self);
}
Tensor TypeDefault::celu(const Tensor & self, Scalar alpha) const {
    const DeviceGuard device_guard(self);
    return at::native::celu(/* native_actuals */ self, alpha);
}
Tensor & TypeDefault::celu_(Tensor & self, Scalar alpha) const {
    const DeviceGuard device_guard(self);
    return at::native::celu_(/* native_actuals */ self, alpha);
}
Tensor TypeDefault::sigmoid(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::sigmoid(/* native_actuals */ self);
}
Tensor & TypeDefault::sigmoid_(Tensor & self) const {
    AT_ERROR("sigmoid_ is not implemented for type ", toString());
}
Tensor & TypeDefault::sigmoid_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("sigmoid_out is not implemented for type ", toString());
}
Tensor TypeDefault::sin(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::sin(/* native_actuals */ self);
}
Tensor & TypeDefault::sin_(Tensor & self) const {
    AT_ERROR("sin_ is not implemented for type ", toString());
}
Tensor & TypeDefault::sin_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("sin_out is not implemented for type ", toString());
}
Tensor TypeDefault::sinh(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::sinh(/* native_actuals */ self);
}
Tensor & TypeDefault::sinh_(Tensor & self) const {
    AT_ERROR("sinh_ is not implemented for type ", toString());
}
Tensor & TypeDefault::sinh_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("sinh_out is not implemented for type ", toString());
}
Tensor TypeDefault::detach(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::detach(/* native_actuals */ self);
}
Tensor & TypeDefault::detach_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::detach_(/* native_actuals */ self);
}
int64_t TypeDefault::size(const Tensor & self, int64_t dim) const {
    // DeviceGuard omitted
    return at::native::size(/* native_actuals */ self, dim);
}
Tensor TypeDefault::slice(const Tensor & self, int64_t dim, int64_t start, int64_t end, int64_t step) const {
    const DeviceGuard device_guard(self);
    return at::native::slice(/* native_actuals */ self, dim, start, end, step);
}
std::tuple<Tensor,Tensor> TypeDefault::slogdet(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::slogdet(/* native_actuals */ self);
}
Tensor TypeDefault::smm(const Tensor & self, const Tensor & mat2) const {
    const DeviceGuard device_guard(self);
    return at::native::smm(/* native_actuals */ self, mat2);
}
Tensor TypeDefault::softmax(const Tensor & self, int64_t dim, ScalarType dtype) const {
    const DeviceGuard device_guard(self);
    return at::native::softmax(/* native_actuals */ self, dim, dtype);
}
Tensor TypeDefault::softmax(const Tensor & self, int64_t dim) const {
    const DeviceGuard device_guard(self);
    return at::native::softmax(/* native_actuals */ self, dim);
}
Tensor TypeDefault::_softmax(const Tensor & self, int64_t dim, bool half_to_float) const {
    AT_ERROR("_softmax is not implemented for type ", toString());
}
Tensor TypeDefault::_softmax_backward_data(const Tensor & grad_output, const Tensor & output, int64_t dim, const Tensor & self) const {
    AT_ERROR("_softmax_backward_data is not implemented for type ", toString());
}
Tensor & TypeDefault::_sparse_add_out(Tensor & result, const Tensor & self, const Tensor & other, Scalar alpha) const {
    AT_ERROR("_sparse_add_out is not implemented for type ", toString());
}
Tensor & TypeDefault::_sparse_dense_add_out(Tensor & result, const Tensor & self, SparseTensorRef other, Scalar alpha) const {
    AT_ERROR("_sparse_dense_add_out is not implemented for type ", toString());
}
Tensor & TypeDefault::_sparse_div_zerodim_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    AT_ERROR("_sparse_div_zerodim_out is not implemented for type ", toString());
}
Tensor & TypeDefault::_sparse_div_scalar_out(Tensor & result, const Tensor & self, Scalar other) const {
    AT_ERROR("_sparse_div_scalar_out is not implemented for type ", toString());
}
Tensor & TypeDefault::_sparse_mul_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    AT_ERROR("_sparse_mul_out is not implemented for type ", toString());
}
Tensor & TypeDefault::_sparse_mul_zerodim_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    AT_ERROR("_sparse_mul_zerodim_out is not implemented for type ", toString());
}
Tensor & TypeDefault::_sparse_mul_scalar_out(Tensor & result, const Tensor & self, Scalar other) const {
    AT_ERROR("_sparse_mul_scalar_out is not implemented for type ", toString());
}
std::vector<Tensor> TypeDefault::split(const Tensor & self, int64_t split_size, int64_t dim) const {
    const DeviceGuard device_guard(self);
    return at::native::split(/* native_actuals */ self, split_size, dim);
}
std::vector<Tensor> TypeDefault::split_with_sizes(const Tensor & self, IntList split_sizes, int64_t dim) const {
    const DeviceGuard device_guard(self);
    return at::native::split_with_sizes(/* native_actuals */ self, split_sizes, dim);
}
Tensor TypeDefault::squeeze(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::squeeze(/* native_actuals */ self);
}
Tensor TypeDefault::squeeze(const Tensor & self, int64_t dim) const {
    const DeviceGuard device_guard(self);
    return at::native::squeeze(/* native_actuals */ self, dim);
}
Tensor & TypeDefault::squeeze_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::squeeze_(/* native_actuals */ self);
}
Tensor & TypeDefault::squeeze_(Tensor & self, int64_t dim) const {
    const DeviceGuard device_guard(self);
    return at::native::squeeze_(/* native_actuals */ self, dim);
}
Tensor TypeDefault::sspaddmm(const Tensor & self, const Tensor & mat1, const Tensor & mat2, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(self);
    return at::native::sspaddmm(/* native_actuals */ self, mat1, mat2, beta, alpha);
}
Tensor & TypeDefault::sspaddmm_out(Tensor & result, const Tensor & self, const Tensor & mat1, const Tensor & mat2, Scalar beta, Scalar alpha) const {
    AT_ERROR("sspaddmm_out is not implemented for type ", toString());
}
Tensor TypeDefault::stack(TensorList tensors, int64_t dim) const {
    const DeviceGuard device_guard(tensors);
    return at::native::stack(/* native_actuals */ tensors, dim);
}
Tensor & TypeDefault::stack_out(Tensor & result, TensorList tensors, int64_t dim) const {
    const DeviceGuard device_guard(result);
    return at::native::stack_out(/* native_actuals */ result, tensors, dim);
}
Tensor TypeDefault::stft(const Tensor & self, int64_t n_fft, int64_t hop_length, int64_t win_length, const Tensor & window, bool normalized, bool onesided) const {
    const DeviceGuard device_guard(self);
    return at::native::stft(/* native_actuals */ self, n_fft, hop_length, win_length, window, normalized, onesided);
}
int64_t TypeDefault::stride(const Tensor & self, int64_t dim) const {
    // DeviceGuard omitted
    return at::native::stride(/* native_actuals */ self, dim);
}
Tensor TypeDefault::sum(const Tensor & self, ScalarType dtype) const {
    const DeviceGuard device_guard(self);
    return at::native::sum(/* native_actuals */ self, dtype);
}
Tensor TypeDefault::sum(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::sum(/* native_actuals */ self);
}
Tensor TypeDefault::sum(const Tensor & self, IntList dim, bool keepdim, ScalarType dtype) const {
    const DeviceGuard device_guard(self);
    return at::native::sum(/* native_actuals */ self, dim, keepdim, dtype);
}
Tensor TypeDefault::sum(const Tensor & self, IntList dim, bool keepdim) const {
    const DeviceGuard device_guard(self);
    return at::native::sum(/* native_actuals */ self, dim, keepdim);
}
Tensor TypeDefault::sum(const Tensor & self, IntList dim, ScalarType dtype) const {
    const DeviceGuard device_guard(self);
    return at::native::sum(/* native_actuals */ self, dim, dtype);
}
Tensor & TypeDefault::sum_out(Tensor & result, const Tensor & self, IntList dim, bool keepdim, ScalarType dtype) const {
    const DeviceGuard device_guard(result);
    return at::native::sum_out(/* native_actuals */ result, self, dim, keepdim, dtype);
}
Tensor & TypeDefault::sum_out(Tensor & result, const Tensor & self, IntList dim, bool keepdim) const {
    const DeviceGuard device_guard(result);
    return at::native::sum_out(/* native_actuals */ result, self, dim, keepdim);
}
Tensor & TypeDefault::sum_out(Tensor & result, const Tensor & self, IntList dim, ScalarType dtype) const {
    const DeviceGuard device_guard(result);
    return at::native::sum_out(/* native_actuals */ result, self, dim, dtype);
}
Tensor TypeDefault::sqrt(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::sqrt(/* native_actuals */ self);
}
Tensor & TypeDefault::sqrt_(Tensor & self) const {
    AT_ERROR("sqrt_ is not implemented for type ", toString());
}
Tensor & TypeDefault::sqrt_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("sqrt_out is not implemented for type ", toString());
}
Tensor TypeDefault::std(const Tensor & self, bool unbiased) const {
    const DeviceGuard device_guard(self);
    return at::native::std(/* native_actuals */ self, unbiased);
}
Tensor TypeDefault::std(const Tensor & self, int64_t dim, bool unbiased, bool keepdim) const {
    const DeviceGuard device_guard(self);
    return at::native::std(/* native_actuals */ self, dim, unbiased, keepdim);
}
Tensor & TypeDefault::std_out(Tensor & result, const Tensor & self, int64_t dim, bool unbiased, bool keepdim) const {
    const DeviceGuard device_guard(result);
    return at::native::std_out(/* native_actuals */ result, self, dim, unbiased, keepdim);
}
Tensor TypeDefault::prod(const Tensor & self, ScalarType dtype) const {
    const DeviceGuard device_guard(self);
    return at::native::prod(/* native_actuals */ self, dtype);
}
Tensor TypeDefault::prod(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::prod(/* native_actuals */ self);
}
Tensor TypeDefault::prod(const Tensor & self, int64_t dim, bool keepdim, ScalarType dtype) const {
    const DeviceGuard device_guard(self);
    return at::native::prod(/* native_actuals */ self, dim, keepdim, dtype);
}
Tensor TypeDefault::prod(const Tensor & self, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(self);
    return at::native::prod(/* native_actuals */ self, dim, keepdim);
}
Tensor TypeDefault::prod(const Tensor & self, int64_t dim, ScalarType dtype) const {
    const DeviceGuard device_guard(self);
    return at::native::prod(/* native_actuals */ self, dim, dtype);
}
Tensor & TypeDefault::prod_out(Tensor & result, const Tensor & self, int64_t dim, bool keepdim, ScalarType dtype) const {
    const DeviceGuard device_guard(result);
    return at::native::prod_out(/* native_actuals */ result, self, dim, keepdim, dtype);
}
Tensor & TypeDefault::prod_out(Tensor & result, const Tensor & self, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(result);
    return at::native::prod_out(/* native_actuals */ result, self, dim, keepdim);
}
Tensor & TypeDefault::prod_out(Tensor & result, const Tensor & self, int64_t dim, ScalarType dtype) const {
    const DeviceGuard device_guard(result);
    return at::native::prod_out(/* native_actuals */ result, self, dim, dtype);
}
Tensor TypeDefault::t(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::t(/* native_actuals */ self);
}
Tensor & TypeDefault::t_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::t_(/* native_actuals */ self);
}
Tensor TypeDefault::tan(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::tan(/* native_actuals */ self);
}
Tensor & TypeDefault::tan_(Tensor & self) const {
    AT_ERROR("tan_ is not implemented for type ", toString());
}
Tensor & TypeDefault::tan_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("tan_out is not implemented for type ", toString());
}
Tensor TypeDefault::tanh(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::tanh(/* native_actuals */ self);
}
Tensor & TypeDefault::tanh_(Tensor & self) const {
    AT_ERROR("tanh_ is not implemented for type ", toString());
}
Tensor & TypeDefault::tanh_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("tanh_out is not implemented for type ", toString());
}
Tensor TypeDefault::tensordot(const Tensor & self, const Tensor & other, IntList dims_self, IntList dims_other) const {
    const DeviceGuard device_guard(self);
    return at::native::tensordot(/* native_actuals */ self, other, dims_self, dims_other);
}
Tensor TypeDefault::transpose(const Tensor & self, int64_t dim0, int64_t dim1) const {
    const DeviceGuard device_guard(self);
    return at::native::transpose(/* native_actuals */ self, dim0, dim1);
}
Tensor & TypeDefault::transpose_(Tensor & self, int64_t dim0, int64_t dim1) const {
    const DeviceGuard device_guard(self);
    return at::native::transpose_(/* native_actuals */ self, dim0, dim1);
}
Tensor TypeDefault::flip(const Tensor & self, IntList dims) const {
    AT_ERROR("flip is not implemented for type ", toString());
}
Tensor TypeDefault::rot90(const Tensor & self, int64_t k, IntList dims) const {
    const DeviceGuard device_guard(self);
    return at::native::rot90(/* native_actuals */ self, k, dims);
}
Tensor TypeDefault::_trilinear(const Tensor & i1, const Tensor & i2, const Tensor & i3, IntList expand1, IntList expand2, IntList expand3, IntList sumdim, int64_t unroll_dim) const {
    const DeviceGuard device_guard(i1);
    return at::native::_trilinear(/* native_actuals */ i1, i2, i3, expand1, expand2, expand3, sumdim, unroll_dim);
}
Tensor TypeDefault::triplet_margin_loss(const Tensor & anchor, const Tensor & positive, const Tensor & negative, double margin, double p, double eps, bool swap, int64_t reduction) const {
    const DeviceGuard device_guard(anchor);
    return at::native::triplet_margin_loss(/* native_actuals */ anchor, positive, negative, margin, p, eps, swap, reduction);
}
Tensor TypeDefault::trunc(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::trunc(/* native_actuals */ self);
}
Tensor & TypeDefault::trunc_(Tensor & self) const {
    AT_ERROR("trunc_ is not implemented for type ", toString());
}
Tensor & TypeDefault::trunc_out(Tensor & result, const Tensor & self) const {
    AT_ERROR("trunc_out is not implemented for type ", toString());
}
Tensor TypeDefault::type_as(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    return at::native::type_as(/* native_actuals */ self, other);
}
std::tuple<Tensor,Tensor> TypeDefault::_unique(const Tensor & self, bool sorted, bool return_inverse) const {
    AT_ERROR("_unique is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::_unique_dim(const Tensor & self, int64_t dim, bool sorted, bool return_inverse) const {
    AT_ERROR("_unique_dim is not implemented for type ", toString());
}
Tensor TypeDefault::_unsafe_view(const Tensor & self, IntList size) const {
    const DeviceGuard device_guard(self);
    return at::native::_unsafe_view(/* native_actuals */ self, size);
}
Tensor TypeDefault::unsqueeze(const Tensor & self, int64_t dim) const {
    const DeviceGuard device_guard(self);
    return at::native::unsqueeze(/* native_actuals */ self, dim);
}
Tensor & TypeDefault::unsqueeze_(Tensor & self, int64_t dim) const {
    const DeviceGuard device_guard(self);
    return at::native::unsqueeze_(/* native_actuals */ self, dim);
}
Tensor TypeDefault::var(const Tensor & self, bool unbiased) const {
    const DeviceGuard device_guard(self);
    return at::native::var(/* native_actuals */ self, unbiased);
}
Tensor TypeDefault::var(const Tensor & self, int64_t dim, bool unbiased, bool keepdim) const {
    const DeviceGuard device_guard(self);
    return at::native::var(/* native_actuals */ self, dim, unbiased, keepdim);
}
Tensor & TypeDefault::var_out(Tensor & result, const Tensor & self, int64_t dim, bool unbiased, bool keepdim) const {
    const DeviceGuard device_guard(result);
    return at::native::var_out(/* native_actuals */ result, self, dim, unbiased, keepdim);
}
Tensor TypeDefault::view_as(const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    return at::native::view_as(/* native_actuals */ self, other);
}
Tensor TypeDefault::where(const Tensor & condition, const Tensor & self, const Tensor & other) const {
    const DeviceGuard device_guard(self);
    return at::native::where(/* native_actuals */ condition, self, other);
}
Tensor TypeDefault::_s_where(const Tensor & condition, const Tensor & self, const Tensor & other) const {
    AT_ERROR("_s_where is not implemented for type ", toString());
}
Tensor TypeDefault::norm_except_dim(const Tensor & v, int64_t pow, int64_t dim) const {
    const DeviceGuard device_guard(v);
    return at::native::norm_except_dim(/* native_actuals */ v, pow, dim);
}
Tensor TypeDefault::_weight_norm(const Tensor & v, const Tensor & g, int64_t dim) const {
    const DeviceGuard device_guard(v);
    return at::native::_weight_norm(/* native_actuals */ v, g, dim);
}
std::tuple<Tensor,Tensor> TypeDefault::_weight_norm_cuda_interface(const Tensor & v, const Tensor & g, int64_t dim) const {
    AT_ERROR("_weight_norm_cuda_interface is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::_weight_norm_cuda_interface_backward(const Tensor & grad_w, const Tensor & saved_v, const Tensor & saved_g, const Tensor & saved_norms, int64_t dim) const {
    AT_ERROR("_weight_norm_cuda_interface_backward is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::_weight_norm_differentiable_backward(const Tensor & grad_w, const Tensor & saved_v, const Tensor & saved_g, const Tensor & saved_norms, int64_t dim) const {
    const DeviceGuard device_guard(grad_w);
    return at::native::_weight_norm_differentiable_backward(/* native_actuals */ grad_w, saved_v, saved_g, saved_norms, dim);
}
Tensor & TypeDefault::zeros_out(Tensor & result, IntList size) const {
    const DeviceGuard device_guard(result);
    return at::native::zeros_out(/* native_actuals */ result, size);
}
Tensor TypeDefault::zeros_like(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::zeros_like(/* native_actuals */ self);
}
Tensor TypeDefault::_standard_gamma_grad(const Tensor & self, const Tensor & output) const {
    AT_ERROR("_standard_gamma_grad is not implemented for type ", toString());
}
Tensor TypeDefault::_standard_gamma(const Tensor & self, Generator * generator) const {
    AT_ERROR("_standard_gamma is not implemented for type ", toString());
}
Tensor TypeDefault::poisson(const Tensor & self, Generator * generator) const {
    AT_ERROR("poisson is not implemented for type ", toString());
}
Tensor TypeDefault::native_norm(const Tensor & self, Scalar p) const {
    AT_ERROR("native_norm is not implemented for type ", toString());
}
Tensor TypeDefault::norm(const Tensor & self, Scalar p) const {
    const DeviceGuard device_guard(self);
    return at::native::norm(/* native_actuals */ self, p);
}
Tensor TypeDefault::norm(const Tensor & self, Scalar p, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(self);
    return at::native::norm(/* native_actuals */ self, p, dim, keepdim);
}
Tensor & TypeDefault::norm_out(Tensor & result, const Tensor & self, Scalar p, int64_t dim, bool keepdim) const {
    const DeviceGuard device_guard(result);
    return at::native::norm_out(/* native_actuals */ result, self, p, dim, keepdim);
}
Tensor TypeDefault::frobenius_norm(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::frobenius_norm(/* native_actuals */ self);
}
Tensor TypeDefault::frobenius_norm(const Tensor & self, IntList dim, bool keepdim) const {
    const DeviceGuard device_guard(self);
    return at::native::frobenius_norm(/* native_actuals */ self, dim, keepdim);
}
Tensor & TypeDefault::frobenius_norm_out(Tensor & result, const Tensor & self, IntList dim, bool keepdim) const {
    const DeviceGuard device_guard(result);
    return at::native::frobenius_norm_out(/* native_actuals */ result, self, dim, keepdim);
}
Tensor TypeDefault::nuclear_norm(const Tensor & self, bool keepdim) const {
    const DeviceGuard device_guard(self);
    return at::native::nuclear_norm(/* native_actuals */ self, keepdim);
}
Tensor & TypeDefault::nuclear_norm_out(Tensor & result, const Tensor & self, bool keepdim) const {
    const DeviceGuard device_guard(result);
    return at::native::nuclear_norm_out(/* native_actuals */ result, self, keepdim);
}
Tensor TypeDefault::native_clone(const Tensor & self) const {
    AT_ERROR("native_clone is not implemented for type ", toString());
}
Tensor TypeDefault::clone(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::clone(/* native_actuals */ self);
}
Tensor & TypeDefault::native_resize_as_(Tensor & self, const Tensor & the_template) const {
    AT_ERROR("native_resize_as_ is not implemented for type ", toString());
}
Tensor & TypeDefault::resize_as_(Tensor & self, const Tensor & the_template) const {
    const DeviceGuard device_guard(self);
    return at::native::resize_as_(/* native_actuals */ self, the_template);
}
Tensor & TypeDefault::native_pow_out(Tensor & result, const Tensor & self, Scalar exponent) const {
    AT_ERROR("native_pow_out is not implemented for type ", toString());
}
Tensor TypeDefault::native_pow(const Tensor & self, Scalar exponent) const {
    AT_ERROR("native_pow is not implemented for type ", toString());
}
Tensor & TypeDefault::pow_out(Tensor & result, const Tensor & self, Scalar exponent) const {
    const DeviceGuard device_guard(result);
    return at::native::pow_out(/* native_actuals */ result, self, exponent);
}
Tensor TypeDefault::pow(const Tensor & self, Scalar exponent) const {
    const DeviceGuard device_guard(self);
    return at::native::pow(/* native_actuals */ self, exponent);
}
Tensor & TypeDefault::native_zero_(Tensor & self) const {
    AT_ERROR("native_zero_ is not implemented for type ", toString());
}
Tensor & TypeDefault::zero_(Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::zero_(/* native_actuals */ self);
}
Tensor & TypeDefault::sub_out(Tensor & result, const Tensor & self, const Tensor & other, Scalar alpha) const {
    const DeviceGuard device_guard(result);
    return at::native::sub_out(/* native_actuals */ result, self, other, alpha);
}
Tensor TypeDefault::sub(const Tensor & self, const Tensor & other, Scalar alpha) const {
    const DeviceGuard device_guard(self);
    return at::native::sub(/* native_actuals */ self, other, alpha);
}
Tensor & TypeDefault::sub_(Tensor & self, const Tensor & other, Scalar alpha) const {
    const DeviceGuard device_guard(self);
    return at::native::sub_(/* native_actuals */ self, other, alpha);
}
Tensor TypeDefault::sub(const Tensor & self, Scalar other, Scalar alpha) const {
    const DeviceGuard device_guard(self);
    return at::native::sub(/* native_actuals */ self, other, alpha);
}
Tensor & TypeDefault::sub_(Tensor & self, Scalar other, Scalar alpha) const {
    const DeviceGuard device_guard(self);
    return at::native::sub_(/* native_actuals */ self, other, alpha);
}
Tensor & TypeDefault::s_native_addmm_out(Tensor & result, const Tensor & self, const Tensor & mat1, const Tensor & mat2, Scalar beta, Scalar alpha) const {
    AT_ERROR("s_native_addmm_out is not implemented for type ", toString());
}
Tensor TypeDefault::s_native_addmm(const Tensor & self, const Tensor & mat1, const Tensor & mat2, Scalar beta, Scalar alpha) const {
    AT_ERROR("s_native_addmm is not implemented for type ", toString());
}
Tensor & TypeDefault::s_native_addmm_(Tensor & self, const Tensor & mat1, const Tensor & mat2, Scalar beta, Scalar alpha) const {
    AT_ERROR("s_native_addmm_ is not implemented for type ", toString());
}
Tensor & TypeDefault::addmm_out(Tensor & result, const Tensor & self, const Tensor & mat1, const Tensor & mat2, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(result);
    return at::native::addmm_out(/* native_actuals */ result, self, mat1, mat2, beta, alpha);
}
Tensor TypeDefault::addmm(const Tensor & self, const Tensor & mat1, const Tensor & mat2, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(self);
    return at::native::addmm(/* native_actuals */ self, mat1, mat2, beta, alpha);
}
Tensor & TypeDefault::addmm_(Tensor & self, const Tensor & mat1, const Tensor & mat2, Scalar beta, Scalar alpha) const {
    const DeviceGuard device_guard(self);
    return at::native::addmm_(/* native_actuals */ self, mat1, mat2, beta, alpha);
}
Tensor TypeDefault::_sparse_coo_tensor_with_dims(int64_t sparse_dim, int64_t dense_dim, IntList size, const TensorOptions & options) const {
    AT_ERROR("_sparse_coo_tensor_with_dims is not implemented for type ", toString());
}
Tensor TypeDefault::_sparse_coo_tensor_with_dims_and_tensors(int64_t sparse_dim, int64_t dense_dim, IntList size, const Tensor & indices, const Tensor & values, const TensorOptions & options) const {
    AT_ERROR("_sparse_coo_tensor_with_dims_and_tensors is not implemented for type ", toString());
}
Tensor & TypeDefault::sparse_resize_(Tensor & self, IntList size, int64_t sparse_dim, int64_t dense_dim) const {
    AT_ERROR("sparse_resize_ is not implemented for type ", toString());
}
Tensor & TypeDefault::sparse_resize_and_clear_(Tensor & self, IntList size, int64_t sparse_dim, int64_t dense_dim) const {
    AT_ERROR("sparse_resize_and_clear_ is not implemented for type ", toString());
}
Tensor TypeDefault::sparse_mask(const Tensor & self, SparseTensorRef mask) const {
    AT_ERROR("sparse_mask is not implemented for type ", toString());
}
Tensor TypeDefault::to_dense(const Tensor & self) const {
    AT_ERROR("to_dense is not implemented for type ", toString());
}
int64_t TypeDefault::sparse_dim(const Tensor & self) const {
    AT_ERROR("sparse_dim is not implemented for type ", toString());
}
int64_t TypeDefault::_dimI(const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::sparse_dim_sparse(/* native_actuals */ self);
}
int64_t TypeDefault::dense_dim(const Tensor & self) const {
    AT_ERROR("dense_dim is not implemented for type ", toString());
}
int64_t TypeDefault::_dimV(const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::dense_dim_sparse(/* native_actuals */ self);
}
int64_t TypeDefault::_nnz(const Tensor & self) const {
    AT_ERROR("_nnz is not implemented for type ", toString());
}
Tensor TypeDefault::coalesce(const Tensor & self) const {
    AT_ERROR("coalesce is not implemented for type ", toString());
}
bool TypeDefault::is_coalesced(const Tensor & self) const {
    AT_ERROR("is_coalesced is not implemented for type ", toString());
}
Tensor TypeDefault::_indices(const Tensor & self) const {
    AT_ERROR("_indices is not implemented for type ", toString());
}
Tensor TypeDefault::_values(const Tensor & self) const {
    AT_ERROR("_values is not implemented for type ", toString());
}
Tensor & TypeDefault::_coalesced_(Tensor & self, bool coalesced) const {
    AT_ERROR("_coalesced_ is not implemented for type ", toString());
}
Tensor TypeDefault::indices(const Tensor & self) const {
    AT_ERROR("indices is not implemented for type ", toString());
}
Tensor TypeDefault::values(const Tensor & self) const {
    AT_ERROR("values is not implemented for type ", toString());
}
Tensor & TypeDefault::hspmm_out(Tensor & result, const Tensor & mat1, const Tensor & mat2) const {
    AT_ERROR("hspmm_out is not implemented for type ", toString());
}
Tensor TypeDefault::hspmm(const Tensor & mat1, const Tensor & mat2) const {
    AT_ERROR("hspmm is not implemented for type ", toString());
}
Tensor & TypeDefault::copy_sparse_to_sparse_(Tensor & self, const Tensor & src, bool non_blocking) const {
    AT_ERROR("copy_sparse_to_sparse_ is not implemented for type ", toString());
}
int64_t TypeDefault::numel(const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::numel(/* native_actuals */ self);
}
std::vector<Tensor> TypeDefault::unbind(const Tensor & self, int64_t dim) const {
    const DeviceGuard device_guard(self);
    return at::native::unbind(/* native_actuals */ self, dim);
}
Tensor TypeDefault::to(const Tensor & self, Device device, ScalarType dtype, bool non_blocking, bool copy) const {
    // DeviceGuard omitted
    return at::native::to(/* native_actuals */ self, device, dtype, non_blocking, copy);
}
Tensor TypeDefault::to(const Tensor & self, ScalarType dtype, bool non_blocking, bool copy) const {
    // DeviceGuard omitted
    return at::native::to(/* native_actuals */ self, dtype, non_blocking, copy);
}
Tensor TypeDefault::to(const Tensor & self, Device device, bool non_blocking, bool copy) const {
    // DeviceGuard omitted
    return at::native::to(/* native_actuals */ self, device, non_blocking, copy);
}
Tensor TypeDefault::to(const Tensor & self, const Tensor & other, bool non_blocking, bool copy) const {
    // DeviceGuard omitted
    return at::native::to(/* native_actuals */ self, other, non_blocking, copy);
}
std::vector<Tensor> TypeDefault::meshgrid(TensorList tensors) const {
    const DeviceGuard device_guard(tensors);
    return at::native::meshgrid(/* native_actuals */ tensors);
}
Scalar TypeDefault::_local_scalar(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::_local_scalar(/* native_actuals */ self);
}
Scalar TypeDefault::_local_scalar_dense(const Tensor & self) const {
    AT_ERROR("_local_scalar_dense is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor,Tensor> TypeDefault::_thnn_fused_lstm_cell(const Tensor & input_gates, const Tensor & hidden_gates, const Tensor & cx, const Tensor & input_bias, const Tensor & hidden_bias) const {
    AT_ERROR("_thnn_fused_lstm_cell is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor,Tensor,Tensor,Tensor> TypeDefault::_thnn_fused_lstm_cell_backward(const Tensor & grad_hy, const Tensor & grad_cy, const Tensor & cx, const Tensor & cy, const Tensor & workspace, bool has_bias) const {
    AT_ERROR("_thnn_fused_lstm_cell_backward is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor> TypeDefault::_thnn_fused_gru_cell(const Tensor & input_gates, const Tensor & hidden_gates, const Tensor & hx, const Tensor & input_bias, const Tensor & hidden_bias) const {
    AT_ERROR("_thnn_fused_gru_cell is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor,Tensor,Tensor,Tensor> TypeDefault::_thnn_fused_gru_cell_backward(const Tensor & grad_hy, const Tensor & workspace, bool has_bias) const {
    AT_ERROR("_thnn_fused_gru_cell_backward is not implemented for type ", toString());
}
std::tuple<Tensor,Tensor,Tensor> TypeDefault::lstm(const Tensor & input, TensorList hx, TensorList params, bool has_biases, int64_t num_layers, double dropout, bool train, bool bidirectional, bool batch_first) const {
    const DeviceGuard device_guard(input);
    return at::native::lstm(/* native_actuals */ input, hx, params, has_biases, num_layers, dropout, train, bidirectional, batch_first);
}
std::tuple<Tensor,Tensor,Tensor> TypeDefault::lstm(const Tensor & data, const Tensor & batch_sizes, TensorList hx, TensorList params, bool has_biases, int64_t num_layers, double dropout, bool train, bool bidirectional) const {
    const DeviceGuard device_guard(data);
    return at::native::lstm(/* native_actuals */ data, batch_sizes, hx, params, has_biases, num_layers, dropout, train, bidirectional);
}
std::tuple<Tensor,Tensor> TypeDefault::gru(const Tensor & input, const Tensor & hx, TensorList params, bool has_biases, int64_t num_layers, double dropout, bool train, bool bidirectional, bool batch_first) const {
    const DeviceGuard device_guard(input);
    return at::native::gru(/* native_actuals */ input, hx, params, has_biases, num_layers, dropout, train, bidirectional, batch_first);
}
std::tuple<Tensor,Tensor> TypeDefault::gru(const Tensor & data, const Tensor & batch_sizes, const Tensor & hx, TensorList params, bool has_biases, int64_t num_layers, double dropout, bool train, bool bidirectional) const {
    const DeviceGuard device_guard(data);
    return at::native::gru(/* native_actuals */ data, batch_sizes, hx, params, has_biases, num_layers, dropout, train, bidirectional);
}
std::tuple<Tensor,Tensor> TypeDefault::rnn_tanh(const Tensor & input, const Tensor & hx, TensorList params, bool has_biases, int64_t num_layers, double dropout, bool train, bool bidirectional, bool batch_first) const {
    const DeviceGuard device_guard(input);
    return at::native::rnn_tanh(/* native_actuals */ input, hx, params, has_biases, num_layers, dropout, train, bidirectional, batch_first);
}
std::tuple<Tensor,Tensor> TypeDefault::rnn_tanh(const Tensor & data, const Tensor & batch_sizes, const Tensor & hx, TensorList params, bool has_biases, int64_t num_layers, double dropout, bool train, bool bidirectional) const {
    const DeviceGuard device_guard(data);
    return at::native::rnn_tanh(/* native_actuals */ data, batch_sizes, hx, params, has_biases, num_layers, dropout, train, bidirectional);
}
std::tuple<Tensor,Tensor> TypeDefault::rnn_relu(const Tensor & input, const Tensor & hx, TensorList params, bool has_biases, int64_t num_layers, double dropout, bool train, bool bidirectional, bool batch_first) const {
    const DeviceGuard device_guard(input);
    return at::native::rnn_relu(/* native_actuals */ input, hx, params, has_biases, num_layers, dropout, train, bidirectional, batch_first);
}
std::tuple<Tensor,Tensor> TypeDefault::rnn_relu(const Tensor & data, const Tensor & batch_sizes, const Tensor & hx, TensorList params, bool has_biases, int64_t num_layers, double dropout, bool train, bool bidirectional) const {
    const DeviceGuard device_guard(data);
    return at::native::rnn_relu(/* native_actuals */ data, batch_sizes, hx, params, has_biases, num_layers, dropout, train, bidirectional);
}
std::tuple<Tensor,Tensor> TypeDefault::lstm_cell(const Tensor & input, TensorList hx, const Tensor & w_ih, const Tensor & w_hh, const Tensor & b_ih, const Tensor & b_hh) const {
    const DeviceGuard device_guard(input);
    return at::native::lstm_cell(/* native_actuals */ input, hx, w_ih, w_hh, b_ih, b_hh);
}
Tensor TypeDefault::gru_cell(const Tensor & input, const Tensor & hx, const Tensor & w_ih, const Tensor & w_hh, const Tensor & b_ih, const Tensor & b_hh) const {
    const DeviceGuard device_guard(input);
    return at::native::gru_cell(/* native_actuals */ input, hx, w_ih, w_hh, b_ih, b_hh);
}
Tensor TypeDefault::rnn_tanh_cell(const Tensor & input, const Tensor & hx, const Tensor & w_ih, const Tensor & w_hh, const Tensor & b_ih, const Tensor & b_hh) const {
    const DeviceGuard device_guard(input);
    return at::native::rnn_tanh_cell(/* native_actuals */ input, hx, w_ih, w_hh, b_ih, b_hh);
}
Tensor TypeDefault::rnn_relu_cell(const Tensor & input, const Tensor & hx, const Tensor & w_ih, const Tensor & w_hh, const Tensor & b_ih, const Tensor & b_hh) const {
    const DeviceGuard device_guard(input);
    return at::native::rnn_relu_cell(/* native_actuals */ input, hx, w_ih, w_hh, b_ih, b_hh);
}
std::tuple<Tensor,Tensor> TypeDefault::_pack_padded_sequence(const Tensor & input, const Tensor & lengths, bool batch_first) const {
    const DeviceGuard device_guard(input);
    return at::native::_pack_padded_sequence(/* native_actuals */ input, lengths, batch_first);
}
Tensor TypeDefault::_pack_padded_sequence_backward(const Tensor & grad, IntList input_size, const Tensor & batch_sizes, bool batch_first) const {
    const DeviceGuard device_guard(grad);
    return at::native::_pack_padded_sequence_backward(/* native_actuals */ grad, input_size, batch_sizes, batch_first);
}
std::tuple<Tensor,Tensor> TypeDefault::_pad_packed_sequence(const Tensor & data, const Tensor & batch_sizes, bool batch_first, Scalar padding_value, int64_t total_length) const {
    const DeviceGuard device_guard(data);
    return at::native::_pad_packed_sequence(/* native_actuals */ data, batch_sizes, batch_first, padding_value, total_length);
}
int64_t TypeDefault::storage_offset(const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::storage_offset(/* native_actuals */ self);
}
Tensor & TypeDefault::set_(Tensor & self, Storage source) const {
    // DeviceGuard omitted
    return at::native::set_(/* native_actuals */ self, source);
}
Tensor & TypeDefault::set_(Tensor & self, Storage source, int64_t storage_offset, IntList size, IntList stride) const {
    // DeviceGuard omitted
    return at::native::set_(/* native_actuals */ self, source, storage_offset, size, stride);
}
Tensor & TypeDefault::set_(Tensor & self, const Tensor & source) const {
    // DeviceGuard omitted
    return at::native::set_(/* native_actuals */ self, source);
}
Tensor & TypeDefault::set_(Tensor & self) const {
    // DeviceGuard omitted
    return at::native::set_(/* native_actuals */ self);
}
bool TypeDefault::is_contiguous(const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::is_contiguous(/* native_actuals */ self);
}
bool TypeDefault::is_set_to(const Tensor & self, const Tensor & tensor) const {
    // DeviceGuard omitted
    return at::native::is_set_to(/* native_actuals */ self, tensor);
}
Tensor & TypeDefault::masked_fill_(Tensor & self, const Tensor & mask, Scalar value) const {
    // DeviceGuard omitted
    return at::native::masked_fill_(/* native_actuals */ self, mask, value);
}
Tensor & TypeDefault::masked_fill_(Tensor & self, const Tensor & mask, const Tensor & value) const {
    // DeviceGuard omitted
    return at::native::masked_fill_(/* native_actuals */ self, mask, value);
}
Tensor & TypeDefault::masked_scatter_(Tensor & self, const Tensor & mask, const Tensor & source) const {
    // DeviceGuard omitted
    return at::native::masked_scatter_(/* native_actuals */ self, mask, source);
}
Tensor TypeDefault::view(const Tensor & self, IntList size) const {
    // DeviceGuard omitted
    return at::native::view(/* native_actuals */ self, size);
}
Tensor & TypeDefault::put_(Tensor & self, const Tensor & index, const Tensor & source, bool accumulate) const {
    // DeviceGuard omitted
    return at::native::put_(/* native_actuals */ self, index, source, accumulate);
}
Tensor & TypeDefault::index_add_(Tensor & self, int64_t dim, const Tensor & index, const Tensor & source) const {
    // DeviceGuard omitted
    return at::native::index_add_(/* native_actuals */ self, dim, index, source);
}
Tensor & TypeDefault::index_fill_(Tensor & self, int64_t dim, const Tensor & index, Scalar value) const {
    // DeviceGuard omitted
    return at::native::index_fill_(/* native_actuals */ self, dim, index, value);
}
Tensor & TypeDefault::index_fill_(Tensor & self, int64_t dim, const Tensor & index, const Tensor & value) const {
    // DeviceGuard omitted
    return at::native::index_fill_(/* native_actuals */ self, dim, index, value);
}
Tensor & TypeDefault::scatter_(Tensor & self, int64_t dim, const Tensor & index, const Tensor & src) const {
    // DeviceGuard omitted
    return at::native::scatter_(/* native_actuals */ self, dim, index, src);
}
Tensor & TypeDefault::scatter_(Tensor & self, int64_t dim, const Tensor & index, Scalar value) const {
    // DeviceGuard omitted
    return at::native::scatter_(/* native_actuals */ self, dim, index, value);
}
Tensor & TypeDefault::scatter_add_(Tensor & self, int64_t dim, const Tensor & index, const Tensor & src) const {
    // DeviceGuard omitted
    return at::native::scatter_add_(/* native_actuals */ self, dim, index, src);
}
Tensor & TypeDefault::lt_(Tensor & self, Scalar other) const {
    // DeviceGuard omitted
    return at::native::lt_(/* native_actuals */ self, other);
}
Tensor & TypeDefault::lt_(Tensor & self, const Tensor & other) const {
    // DeviceGuard omitted
    return at::native::lt_(/* native_actuals */ self, other);
}
Tensor & TypeDefault::gt_(Tensor & self, Scalar other) const {
    // DeviceGuard omitted
    return at::native::gt_(/* native_actuals */ self, other);
}
Tensor & TypeDefault::gt_(Tensor & self, const Tensor & other) const {
    // DeviceGuard omitted
    return at::native::gt_(/* native_actuals */ self, other);
}
Tensor & TypeDefault::le_(Tensor & self, Scalar other) const {
    // DeviceGuard omitted
    return at::native::le_(/* native_actuals */ self, other);
}
Tensor & TypeDefault::le_(Tensor & self, const Tensor & other) const {
    // DeviceGuard omitted
    return at::native::le_(/* native_actuals */ self, other);
}
Tensor & TypeDefault::ge_(Tensor & self, Scalar other) const {
    // DeviceGuard omitted
    return at::native::ge_(/* native_actuals */ self, other);
}
Tensor & TypeDefault::ge_(Tensor & self, const Tensor & other) const {
    // DeviceGuard omitted
    return at::native::ge_(/* native_actuals */ self, other);
}
Tensor & TypeDefault::eq_(Tensor & self, Scalar other) const {
    // DeviceGuard omitted
    return at::native::eq_(/* native_actuals */ self, other);
}
Tensor & TypeDefault::eq_(Tensor & self, const Tensor & other) const {
    // DeviceGuard omitted
    return at::native::eq_(/* native_actuals */ self, other);
}
Tensor & TypeDefault::ne_(Tensor & self, Scalar other) const {
    // DeviceGuard omitted
    return at::native::ne_(/* native_actuals */ self, other);
}
Tensor & TypeDefault::ne_(Tensor & self, const Tensor & other) const {
    // DeviceGuard omitted
    return at::native::ne_(/* native_actuals */ self, other);
}
Tensor & TypeDefault::lgamma_(Tensor & self) const {
    // DeviceGuard omitted
    return at::native::lgamma_(/* native_actuals */ self);
}
Tensor & TypeDefault::atan2_(Tensor & self, const Tensor & other) const {
    // DeviceGuard omitted
    return at::native::atan2_(/* native_actuals */ self, other);
}
Tensor & TypeDefault::tril_(Tensor & self, int64_t diagonal) const {
    // DeviceGuard omitted
    return at::native::tril_(/* native_actuals */ self, diagonal);
}
Tensor & TypeDefault::triu_(Tensor & self, int64_t diagonal) const {
    // DeviceGuard omitted
    return at::native::triu_(/* native_actuals */ self, diagonal);
}
Tensor & TypeDefault::digamma_(Tensor & self) const {
    // DeviceGuard omitted
    return at::native::digamma_(/* native_actuals */ self);
}
Tensor & TypeDefault::polygamma_(Tensor & self, int64_t n) const {
    // DeviceGuard omitted
    return at::native::polygamma_(/* native_actuals */ self, n);
}
Tensor & TypeDefault::erfinv_(Tensor & self) const {
    // DeviceGuard omitted
    return at::native::erfinv_(/* native_actuals */ self);
}
Tensor & TypeDefault::frac_(Tensor & self) const {
    // DeviceGuard omitted
    return at::native::frac_(/* native_actuals */ self);
}
Tensor & TypeDefault::renorm_(Tensor & self, Scalar p, int64_t dim, Scalar maxnorm) const {
    // DeviceGuard omitted
    return at::native::renorm_(/* native_actuals */ self, p, dim, maxnorm);
}
Tensor & TypeDefault::reciprocal_(Tensor & self) const {
    // DeviceGuard omitted
    return at::native::reciprocal_(/* native_actuals */ self);
}
Tensor & TypeDefault::neg_(Tensor & self) const {
    // DeviceGuard omitted
    return at::native::neg_(/* native_actuals */ self);
}
Tensor & TypeDefault::pow_(Tensor & self, Scalar exponent) const {
    // DeviceGuard omitted
    return at::native::pow_(/* native_actuals */ self, exponent);
}
Tensor & TypeDefault::pow_(Tensor & self, const Tensor & exponent) const {
    // DeviceGuard omitted
    return at::native::pow_(/* native_actuals */ self, exponent);
}
Tensor & TypeDefault::lerp_(Tensor & self, const Tensor & end, Scalar weight) const {
    // DeviceGuard omitted
    return at::native::lerp_(/* native_actuals */ self, end, weight);
}
Tensor & TypeDefault::sign_(Tensor & self) const {
    // DeviceGuard omitted
    return at::native::sign_(/* native_actuals */ self);
}
Tensor & TypeDefault::fmod_(Tensor & self, Scalar other) const {
    // DeviceGuard omitted
    return at::native::fmod_(/* native_actuals */ self, other);
}
Tensor & TypeDefault::fmod_(Tensor & self, const Tensor & other) const {
    // DeviceGuard omitted
    return at::native::fmod_(/* native_actuals */ self, other);
}
Tensor & TypeDefault::remainder_(Tensor & self, Scalar other) const {
    // DeviceGuard omitted
    return at::native::remainder_(/* native_actuals */ self, other);
}
Tensor & TypeDefault::remainder_(Tensor & self, const Tensor & other) const {
    // DeviceGuard omitted
    return at::native::remainder_(/* native_actuals */ self, other);
}
Tensor & TypeDefault::addbmm_(Tensor & self, const Tensor & batch1, const Tensor & batch2, Scalar beta, Scalar alpha) const {
    // DeviceGuard omitted
    return at::native::addbmm_(/* native_actuals */ self, batch1, batch2, beta, alpha);
}
Tensor & TypeDefault::addcmul_(Tensor & self, const Tensor & tensor1, const Tensor & tensor2, Scalar value) const {
    // DeviceGuard omitted
    return at::native::addcmul_(/* native_actuals */ self, tensor1, tensor2, value);
}
Tensor & TypeDefault::addcdiv_(Tensor & self, const Tensor & tensor1, const Tensor & tensor2, Scalar value) const {
    // DeviceGuard omitted
    return at::native::addcdiv_(/* native_actuals */ self, tensor1, tensor2, value);
}
Tensor & TypeDefault::random_(Tensor & self, int64_t from, int64_t to, Generator * generator) const {
    // DeviceGuard omitted
    return at::native::random_(/* native_actuals */ self, from, to, generator);
}
Tensor & TypeDefault::random_(Tensor & self, int64_t to, Generator * generator) const {
    // DeviceGuard omitted
    return at::native::random_(/* native_actuals */ self, to, generator);
}
Tensor & TypeDefault::random_(Tensor & self, Generator * generator) const {
    // DeviceGuard omitted
    return at::native::random_(/* native_actuals */ self, generator);
}
Tensor & TypeDefault::uniform_(Tensor & self, double from, double to, Generator * generator) const {
    // DeviceGuard omitted
    return at::native::uniform_(/* native_actuals */ self, from, to, generator);
}
Tensor & TypeDefault::normal_(Tensor & self, double mean, double std, Generator * generator) const {
    // DeviceGuard omitted
    return at::native::normal_(/* native_actuals */ self, mean, std, generator);
}
Tensor & TypeDefault::cauchy_(Tensor & self, double median, double sigma, Generator * generator) const {
    // DeviceGuard omitted
    return at::native::cauchy_(/* native_actuals */ self, median, sigma, generator);
}
Tensor & TypeDefault::log_normal_(Tensor & self, double mean, double std, Generator * generator) const {
    // DeviceGuard omitted
    return at::native::log_normal_(/* native_actuals */ self, mean, std, generator);
}
Tensor & TypeDefault::exponential_(Tensor & self, double lambd, Generator * generator) const {
    // DeviceGuard omitted
    return at::native::exponential_(/* native_actuals */ self, lambd, generator);
}
Tensor & TypeDefault::geometric_(Tensor & self, double p, Generator * generator) const {
    // DeviceGuard omitted
    return at::native::geometric_(/* native_actuals */ self, p, generator);
}
Tensor & TypeDefault::diag_out(Tensor & result, const Tensor & self, int64_t diagonal) const {
    // DeviceGuard omitted
    return at::native::diag_out(/* native_actuals */ result, self, diagonal);
}
Tensor TypeDefault::diag(const Tensor & self, int64_t diagonal) const {
    // DeviceGuard omitted
    return at::native::diag(/* native_actuals */ self, diagonal);
}
Tensor & TypeDefault::cross_out(Tensor & result, const Tensor & self, const Tensor & other, int64_t dim) const {
    // DeviceGuard omitted
    return at::native::cross_out(/* native_actuals */ result, self, other, dim);
}
Tensor TypeDefault::cross(const Tensor & self, const Tensor & other, int64_t dim) const {
    // DeviceGuard omitted
    return at::native::cross(/* native_actuals */ self, other, dim);
}
Tensor & TypeDefault::triu_out(Tensor & result, const Tensor & self, int64_t diagonal) const {
    // DeviceGuard omitted
    return at::native::triu_out(/* native_actuals */ result, self, diagonal);
}
Tensor TypeDefault::triu(const Tensor & self, int64_t diagonal) const {
    // DeviceGuard omitted
    return at::native::triu(/* native_actuals */ self, diagonal);
}
Tensor & TypeDefault::tril_out(Tensor & result, const Tensor & self, int64_t diagonal) const {
    // DeviceGuard omitted
    return at::native::tril_out(/* native_actuals */ result, self, diagonal);
}
Tensor TypeDefault::tril(const Tensor & self, int64_t diagonal) const {
    // DeviceGuard omitted
    return at::native::tril(/* native_actuals */ self, diagonal);
}
Tensor TypeDefault::trace(const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::trace(/* native_actuals */ self);
}
Tensor & TypeDefault::ne_out(Tensor & result, const Tensor & self, Scalar other) const {
    // DeviceGuard omitted
    return at::native::ne_out(/* native_actuals */ result, self, other);
}
Tensor TypeDefault::ne(const Tensor & self, Scalar other) const {
    // DeviceGuard omitted
    return at::native::ne(/* native_actuals */ self, other);
}
Tensor & TypeDefault::ne_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    // DeviceGuard omitted
    return at::native::ne_out(/* native_actuals */ result, self, other);
}
Tensor TypeDefault::ne(const Tensor & self, const Tensor & other) const {
    // DeviceGuard omitted
    return at::native::ne(/* native_actuals */ self, other);
}
Tensor & TypeDefault::eq_out(Tensor & result, const Tensor & self, Scalar other) const {
    // DeviceGuard omitted
    return at::native::eq_out(/* native_actuals */ result, self, other);
}
Tensor TypeDefault::eq(const Tensor & self, Scalar other) const {
    // DeviceGuard omitted
    return at::native::eq(/* native_actuals */ self, other);
}
Tensor & TypeDefault::eq_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    // DeviceGuard omitted
    return at::native::eq_out(/* native_actuals */ result, self, other);
}
Tensor TypeDefault::eq(const Tensor & self, const Tensor & other) const {
    // DeviceGuard omitted
    return at::native::eq(/* native_actuals */ self, other);
}
Tensor & TypeDefault::ge_out(Tensor & result, const Tensor & self, Scalar other) const {
    // DeviceGuard omitted
    return at::native::ge_out(/* native_actuals */ result, self, other);
}
Tensor TypeDefault::ge(const Tensor & self, Scalar other) const {
    // DeviceGuard omitted
    return at::native::ge(/* native_actuals */ self, other);
}
Tensor & TypeDefault::ge_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    // DeviceGuard omitted
    return at::native::ge_out(/* native_actuals */ result, self, other);
}
Tensor TypeDefault::ge(const Tensor & self, const Tensor & other) const {
    // DeviceGuard omitted
    return at::native::ge(/* native_actuals */ self, other);
}
Tensor & TypeDefault::le_out(Tensor & result, const Tensor & self, Scalar other) const {
    // DeviceGuard omitted
    return at::native::le_out(/* native_actuals */ result, self, other);
}
Tensor TypeDefault::le(const Tensor & self, Scalar other) const {
    // DeviceGuard omitted
    return at::native::le(/* native_actuals */ self, other);
}
Tensor & TypeDefault::le_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    // DeviceGuard omitted
    return at::native::le_out(/* native_actuals */ result, self, other);
}
Tensor TypeDefault::le(const Tensor & self, const Tensor & other) const {
    // DeviceGuard omitted
    return at::native::le(/* native_actuals */ self, other);
}
Tensor & TypeDefault::gt_out(Tensor & result, const Tensor & self, Scalar other) const {
    // DeviceGuard omitted
    return at::native::gt_out(/* native_actuals */ result, self, other);
}
Tensor TypeDefault::gt(const Tensor & self, Scalar other) const {
    // DeviceGuard omitted
    return at::native::gt(/* native_actuals */ self, other);
}
Tensor & TypeDefault::gt_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    // DeviceGuard omitted
    return at::native::gt_out(/* native_actuals */ result, self, other);
}
Tensor TypeDefault::gt(const Tensor & self, const Tensor & other) const {
    // DeviceGuard omitted
    return at::native::gt(/* native_actuals */ self, other);
}
Tensor & TypeDefault::lt_out(Tensor & result, const Tensor & self, Scalar other) const {
    // DeviceGuard omitted
    return at::native::lt_out(/* native_actuals */ result, self, other);
}
Tensor TypeDefault::lt(const Tensor & self, Scalar other) const {
    // DeviceGuard omitted
    return at::native::lt(/* native_actuals */ self, other);
}
Tensor & TypeDefault::lt_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    // DeviceGuard omitted
    return at::native::lt_out(/* native_actuals */ result, self, other);
}
Tensor TypeDefault::lt(const Tensor & self, const Tensor & other) const {
    // DeviceGuard omitted
    return at::native::lt(/* native_actuals */ self, other);
}
Tensor & TypeDefault::take_out(Tensor & result, const Tensor & self, const Tensor & index) const {
    // DeviceGuard omitted
    return at::native::take_out(/* native_actuals */ result, self, index);
}
Tensor TypeDefault::take(const Tensor & self, const Tensor & index) const {
    // DeviceGuard omitted
    return at::native::take(/* native_actuals */ self, index);
}
Tensor & TypeDefault::index_select_out(Tensor & result, const Tensor & self, int64_t dim, const Tensor & index) const {
    // DeviceGuard omitted
    return at::native::index_select_out(/* native_actuals */ result, self, dim, index);
}
Tensor TypeDefault::index_select(const Tensor & self, int64_t dim, const Tensor & index) const {
    // DeviceGuard omitted
    return at::native::index_select(/* native_actuals */ self, dim, index);
}
Tensor & TypeDefault::masked_select_out(Tensor & result, const Tensor & self, const Tensor & mask) const {
    // DeviceGuard omitted
    return at::native::masked_select_out(/* native_actuals */ result, self, mask);
}
Tensor TypeDefault::masked_select(const Tensor & self, const Tensor & mask) const {
    // DeviceGuard omitted
    return at::native::masked_select(/* native_actuals */ self, mask);
}
Tensor & TypeDefault::nonzero_out(Tensor & result, const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::nonzero_out(/* native_actuals */ result, self);
}
Tensor TypeDefault::nonzero(const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::nonzero(/* native_actuals */ self);
}
Tensor & TypeDefault::gather_out(Tensor & result, const Tensor & self, int64_t dim, const Tensor & index) const {
    // DeviceGuard omitted
    return at::native::gather_out(/* native_actuals */ result, self, dim, index);
}
Tensor TypeDefault::gather(const Tensor & self, int64_t dim, const Tensor & index) const {
    // DeviceGuard omitted
    return at::native::gather(/* native_actuals */ self, dim, index);
}
Tensor & TypeDefault::addcmul_out(Tensor & result, const Tensor & self, const Tensor & tensor1, const Tensor & tensor2, Scalar value) const {
    // DeviceGuard omitted
    return at::native::addcmul_out(/* native_actuals */ result, self, tensor1, tensor2, value);
}
Tensor TypeDefault::addcmul(const Tensor & self, const Tensor & tensor1, const Tensor & tensor2, Scalar value) const {
    // DeviceGuard omitted
    return at::native::addcmul(/* native_actuals */ self, tensor1, tensor2, value);
}
Tensor & TypeDefault::addcdiv_out(Tensor & result, const Tensor & self, const Tensor & tensor1, const Tensor & tensor2, Scalar value) const {
    // DeviceGuard omitted
    return at::native::addcdiv_out(/* native_actuals */ result, self, tensor1, tensor2, value);
}
Tensor TypeDefault::addcdiv(const Tensor & self, const Tensor & tensor1, const Tensor & tensor2, Scalar value) const {
    // DeviceGuard omitted
    return at::native::addcdiv(/* native_actuals */ self, tensor1, tensor2, value);
}
std::tuple<Tensor &,Tensor &> TypeDefault::gels_out(Tensor & X, Tensor & qr, const Tensor & self, const Tensor & A) const {
    // DeviceGuard omitted
    return at::native::gels_out(/* native_actuals */ X, qr, self, A);
}
std::tuple<Tensor,Tensor> TypeDefault::gels(const Tensor & self, const Tensor & A) const {
    // DeviceGuard omitted
    return at::native::gels(/* native_actuals */ self, A);
}
std::tuple<Tensor &,Tensor &> TypeDefault::trtrs_out(Tensor & X, Tensor & M, const Tensor & self, const Tensor & A, bool upper, bool transpose, bool unitriangular) const {
    // DeviceGuard omitted
    return at::native::trtrs_out(/* native_actuals */ X, M, self, A, upper, transpose, unitriangular);
}
std::tuple<Tensor,Tensor> TypeDefault::trtrs(const Tensor & self, const Tensor & A, bool upper, bool transpose, bool unitriangular) const {
    // DeviceGuard omitted
    return at::native::trtrs(/* native_actuals */ self, A, upper, transpose, unitriangular);
}
std::tuple<Tensor &,Tensor &> TypeDefault::symeig_out(Tensor & e, Tensor & V, const Tensor & self, bool eigenvectors, bool upper) const {
    // DeviceGuard omitted
    return at::native::symeig_out(/* native_actuals */ e, V, self, eigenvectors, upper);
}
std::tuple<Tensor,Tensor> TypeDefault::symeig(const Tensor & self, bool eigenvectors, bool upper) const {
    // DeviceGuard omitted
    return at::native::symeig(/* native_actuals */ self, eigenvectors, upper);
}
std::tuple<Tensor &,Tensor &> TypeDefault::eig_out(Tensor & e, Tensor & v, const Tensor & self, bool eigenvectors) const {
    // DeviceGuard omitted
    return at::native::eig_out(/* native_actuals */ e, v, self, eigenvectors);
}
std::tuple<Tensor,Tensor> TypeDefault::eig(const Tensor & self, bool eigenvectors) const {
    // DeviceGuard omitted
    return at::native::eig(/* native_actuals */ self, eigenvectors);
}
std::tuple<Tensor &,Tensor &,Tensor &> TypeDefault::svd_out(Tensor & U, Tensor & S, Tensor & V, const Tensor & self, bool some, bool compute_uv) const {
    // DeviceGuard omitted
    return at::native::svd_out(/* native_actuals */ U, S, V, self, some, compute_uv);
}
std::tuple<Tensor,Tensor,Tensor> TypeDefault::svd(const Tensor & self, bool some, bool compute_uv) const {
    // DeviceGuard omitted
    return at::native::svd(/* native_actuals */ self, some, compute_uv);
}
Tensor & TypeDefault::potrf_out(Tensor & result, const Tensor & self, bool upper) const {
    // DeviceGuard omitted
    return at::native::potrf_out(/* native_actuals */ result, self, upper);
}
Tensor TypeDefault::potrf(const Tensor & self, bool upper) const {
    // DeviceGuard omitted
    return at::native::potrf(/* native_actuals */ self, upper);
}
Tensor & TypeDefault::potrs_out(Tensor & result, const Tensor & self, const Tensor & input2, bool upper) const {
    // DeviceGuard omitted
    return at::native::potrs_out(/* native_actuals */ result, self, input2, upper);
}
Tensor TypeDefault::potrs(const Tensor & self, const Tensor & input2, bool upper) const {
    // DeviceGuard omitted
    return at::native::potrs(/* native_actuals */ self, input2, upper);
}
Tensor & TypeDefault::potri_out(Tensor & result, const Tensor & self, bool upper) const {
    // DeviceGuard omitted
    return at::native::potri_out(/* native_actuals */ result, self, upper);
}
Tensor TypeDefault::potri(const Tensor & self, bool upper) const {
    // DeviceGuard omitted
    return at::native::potri(/* native_actuals */ self, upper);
}
std::tuple<Tensor &,Tensor &> TypeDefault::pstrf_out(Tensor & u, Tensor & piv, const Tensor & self, bool upper, Scalar tol) const {
    // DeviceGuard omitted
    return at::native::pstrf_out(/* native_actuals */ u, piv, self, upper, tol);
}
std::tuple<Tensor,Tensor> TypeDefault::pstrf(const Tensor & self, bool upper, Scalar tol) const {
    // DeviceGuard omitted
    return at::native::pstrf(/* native_actuals */ self, upper, tol);
}
std::tuple<Tensor &,Tensor &> TypeDefault::qr_out(Tensor & Q, Tensor & R, const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::qr_out(/* native_actuals */ Q, R, self);
}
std::tuple<Tensor,Tensor> TypeDefault::qr(const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::qr(/* native_actuals */ self);
}
std::tuple<Tensor &,Tensor &> TypeDefault::geqrf_out(Tensor & result0, Tensor & result1, const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::geqrf_out(/* native_actuals */ result0, result1, self);
}
std::tuple<Tensor,Tensor> TypeDefault::geqrf(const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::geqrf(/* native_actuals */ self);
}
Tensor & TypeDefault::orgqr_out(Tensor & result, const Tensor & self, const Tensor & input2) const {
    // DeviceGuard omitted
    return at::native::orgqr_out(/* native_actuals */ result, self, input2);
}
Tensor TypeDefault::orgqr(const Tensor & self, const Tensor & input2) const {
    // DeviceGuard omitted
    return at::native::orgqr(/* native_actuals */ self, input2);
}
Tensor & TypeDefault::ormqr_out(Tensor & result, const Tensor & self, const Tensor & input2, const Tensor & input3, bool left, bool transpose) const {
    // DeviceGuard omitted
    return at::native::ormqr_out(/* native_actuals */ result, self, input2, input3, left, transpose);
}
Tensor TypeDefault::ormqr(const Tensor & self, const Tensor & input2, const Tensor & input3, bool left, bool transpose) const {
    // DeviceGuard omitted
    return at::native::ormqr(/* native_actuals */ self, input2, input3, left, transpose);
}
std::tuple<Tensor &,Tensor &> TypeDefault::btrifact_out(Tensor & A_LU, Tensor & pivots, const Tensor & self, bool pivot) const {
    // DeviceGuard omitted
    return at::native::btrifact_out(/* native_actuals */ A_LU, pivots, self, pivot);
}
std::tuple<Tensor,Tensor> TypeDefault::btrifact(const Tensor & self, bool pivot) const {
    // DeviceGuard omitted
    return at::native::btrifact(/* native_actuals */ self, pivot);
}
std::tuple<Tensor &,Tensor &,Tensor &> TypeDefault::btrifact_with_info_out(Tensor & A_LU, Tensor & pivots, Tensor & info, const Tensor & self, bool pivot) const {
    // DeviceGuard omitted
    return at::native::btrifact_with_info_out(/* native_actuals */ A_LU, pivots, info, self, pivot);
}
std::tuple<Tensor,Tensor,Tensor> TypeDefault::btrifact_with_info(const Tensor & self, bool pivot) const {
    // DeviceGuard omitted
    return at::native::btrifact_with_info(/* native_actuals */ self, pivot);
}
Tensor & TypeDefault::btrisolve_out(Tensor & result, const Tensor & self, const Tensor & LU_data, const Tensor & LU_pivots) const {
    // DeviceGuard omitted
    return at::native::btrisolve_out(/* native_actuals */ result, self, LU_data, LU_pivots);
}
Tensor TypeDefault::btrisolve(const Tensor & self, const Tensor & LU_data, const Tensor & LU_pivots) const {
    // DeviceGuard omitted
    return at::native::btrisolve(/* native_actuals */ self, LU_data, LU_pivots);
}
Tensor & TypeDefault::multinomial_out(Tensor & result, const Tensor & self, int64_t num_samples, bool replacement, Generator * generator) const {
    // DeviceGuard omitted
    return at::native::multinomial_out(/* native_actuals */ result, self, num_samples, replacement, generator);
}
Tensor TypeDefault::multinomial(const Tensor & self, int64_t num_samples, bool replacement, Generator * generator) const {
    // DeviceGuard omitted
    return at::native::multinomial(/* native_actuals */ self, num_samples, replacement, generator);
}
Tensor & TypeDefault::lgamma_out(Tensor & result, const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::lgamma_out(/* native_actuals */ result, self);
}
Tensor TypeDefault::lgamma(const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::lgamma(/* native_actuals */ self);
}
Tensor & TypeDefault::digamma_out(Tensor & result, const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::digamma_out(/* native_actuals */ result, self);
}
Tensor TypeDefault::digamma(const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::digamma(/* native_actuals */ self);
}
Tensor & TypeDefault::polygamma_out(Tensor & result, int64_t n, const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::polygamma_out(/* native_actuals */ result, n, self);
}
Tensor TypeDefault::polygamma(int64_t n, const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::polygamma(/* native_actuals */ n, self);
}
Tensor & TypeDefault::erfinv_out(Tensor & result, const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::erfinv_out(/* native_actuals */ result, self);
}
Tensor TypeDefault::erfinv(const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::erfinv(/* native_actuals */ self);
}
Tensor & TypeDefault::frac_out(Tensor & result, const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::frac_out(/* native_actuals */ result, self);
}
Tensor TypeDefault::frac(const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::frac(/* native_actuals */ self);
}
Tensor TypeDefault::dist(const Tensor & self, const Tensor & other, Scalar p) const {
    // DeviceGuard omitted
    return at::native::dist(/* native_actuals */ self, other, p);
}
Tensor & TypeDefault::reciprocal_out(Tensor & result, const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::reciprocal_out(/* native_actuals */ result, self);
}
Tensor TypeDefault::reciprocal(const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::reciprocal(/* native_actuals */ self);
}
Tensor & TypeDefault::neg_out(Tensor & result, const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::neg_out(/* native_actuals */ result, self);
}
Tensor TypeDefault::neg(const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::neg(/* native_actuals */ self);
}
Tensor & TypeDefault::atan2_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    // DeviceGuard omitted
    return at::native::atan2_out(/* native_actuals */ result, self, other);
}
Tensor TypeDefault::atan2(const Tensor & self, const Tensor & other) const {
    // DeviceGuard omitted
    return at::native::atan2(/* native_actuals */ self, other);
}
Tensor & TypeDefault::lerp_out(Tensor & result, const Tensor & self, const Tensor & end, Scalar weight) const {
    // DeviceGuard omitted
    return at::native::lerp_out(/* native_actuals */ result, self, end, weight);
}
Tensor TypeDefault::lerp(const Tensor & self, const Tensor & end, Scalar weight) const {
    // DeviceGuard omitted
    return at::native::lerp(/* native_actuals */ self, end, weight);
}
Tensor & TypeDefault::histc_out(Tensor & result, const Tensor & self, int64_t bins, Scalar min, Scalar max) const {
    // DeviceGuard omitted
    return at::native::histc_out(/* native_actuals */ result, self, bins, min, max);
}
Tensor TypeDefault::histc(const Tensor & self, int64_t bins, Scalar min, Scalar max) const {
    // DeviceGuard omitted
    return at::native::histc(/* native_actuals */ self, bins, min, max);
}
Tensor & TypeDefault::sign_out(Tensor & result, const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::sign_out(/* native_actuals */ result, self);
}
Tensor TypeDefault::sign(const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::sign(/* native_actuals */ self);
}
Tensor & TypeDefault::fmod_out(Tensor & result, const Tensor & self, Scalar other) const {
    // DeviceGuard omitted
    return at::native::fmod_out(/* native_actuals */ result, self, other);
}
Tensor TypeDefault::fmod(const Tensor & self, Scalar other) const {
    // DeviceGuard omitted
    return at::native::fmod(/* native_actuals */ self, other);
}
Tensor & TypeDefault::fmod_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    // DeviceGuard omitted
    return at::native::fmod_out(/* native_actuals */ result, self, other);
}
Tensor TypeDefault::fmod(const Tensor & self, const Tensor & other) const {
    // DeviceGuard omitted
    return at::native::fmod(/* native_actuals */ self, other);
}
Tensor & TypeDefault::remainder_out(Tensor & result, const Tensor & self, Scalar other) const {
    // DeviceGuard omitted
    return at::native::remainder_out(/* native_actuals */ result, self, other);
}
Tensor TypeDefault::remainder(const Tensor & self, Scalar other) const {
    // DeviceGuard omitted
    return at::native::remainder(/* native_actuals */ self, other);
}
Tensor & TypeDefault::remainder_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    // DeviceGuard omitted
    return at::native::remainder_out(/* native_actuals */ result, self, other);
}
Tensor TypeDefault::remainder(const Tensor & self, const Tensor & other) const {
    // DeviceGuard omitted
    return at::native::remainder(/* native_actuals */ self, other);
}
Tensor & TypeDefault::min_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    // DeviceGuard omitted
    return at::native::min_out(/* native_actuals */ result, self, other);
}
Tensor TypeDefault::min(const Tensor & self, const Tensor & other) const {
    // DeviceGuard omitted
    return at::native::min(/* native_actuals */ self, other);
}
Tensor TypeDefault::min(const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::min(/* native_actuals */ self);
}
Tensor & TypeDefault::max_out(Tensor & result, const Tensor & self, const Tensor & other) const {
    // DeviceGuard omitted
    return at::native::max_out(/* native_actuals */ result, self, other);
}
Tensor TypeDefault::max(const Tensor & self, const Tensor & other) const {
    // DeviceGuard omitted
    return at::native::max(/* native_actuals */ self, other);
}
Tensor TypeDefault::max(const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::max(/* native_actuals */ self);
}
Tensor TypeDefault::median(const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::median(/* native_actuals */ self);
}
std::tuple<Tensor &,Tensor &> TypeDefault::sort_out(Tensor & values, Tensor & indices, const Tensor & self, int64_t dim, bool descending) const {
    // DeviceGuard omitted
    return at::native::sort_out(/* native_actuals */ values, indices, self, dim, descending);
}
std::tuple<Tensor,Tensor> TypeDefault::sort(const Tensor & self, int64_t dim, bool descending) const {
    // DeviceGuard omitted
    return at::native::sort(/* native_actuals */ self, dim, descending);
}
std::tuple<Tensor &,Tensor &> TypeDefault::topk_out(Tensor & values, Tensor & indices, const Tensor & self, int64_t k, int64_t dim, bool largest, bool sorted) const {
    // DeviceGuard omitted
    return at::native::topk_out(/* native_actuals */ values, indices, self, k, dim, largest, sorted);
}
std::tuple<Tensor,Tensor> TypeDefault::topk(const Tensor & self, int64_t k, int64_t dim, bool largest, bool sorted) const {
    // DeviceGuard omitted
    return at::native::topk(/* native_actuals */ self, k, dim, largest, sorted);
}
Tensor TypeDefault::all(const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::all(/* native_actuals */ self);
}
Tensor TypeDefault::any(const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::any(/* native_actuals */ self);
}
Tensor & TypeDefault::renorm_out(Tensor & result, const Tensor & self, Scalar p, int64_t dim, Scalar maxnorm) const {
    // DeviceGuard omitted
    return at::native::renorm_out(/* native_actuals */ result, self, p, dim, maxnorm);
}
Tensor TypeDefault::renorm(const Tensor & self, Scalar p, int64_t dim, Scalar maxnorm) const {
    // DeviceGuard omitted
    return at::native::renorm(/* native_actuals */ self, p, dim, maxnorm);
}
Tensor TypeDefault::unfold(const Tensor & self, int64_t dimension, int64_t size, int64_t step) const {
    // DeviceGuard omitted
    return at::native::unfold(/* native_actuals */ self, dimension, size, step);
}
bool TypeDefault::equal(const Tensor & self, const Tensor & other) const {
    // DeviceGuard omitted
    return at::native::equal(/* native_actuals */ self, other);
}
Tensor & TypeDefault::pow_out(Tensor & result, const Tensor & self, const Tensor & exponent) const {
    // DeviceGuard omitted
    return at::native::pow_out(/* native_actuals */ result, self, exponent);
}
Tensor TypeDefault::pow(const Tensor & self, const Tensor & exponent) const {
    // DeviceGuard omitted
    return at::native::pow(/* native_actuals */ self, exponent);
}
Tensor & TypeDefault::pow_out(Tensor & result, Scalar self, const Tensor & exponent) const {
    // DeviceGuard omitted
    return at::native::pow_out(/* native_actuals */ result, self, exponent);
}
Tensor TypeDefault::pow(Scalar self, const Tensor & exponent) const {
    // DeviceGuard omitted
    return at::native::pow(/* native_actuals */ self, exponent);
}
Tensor & TypeDefault::normal_out(Tensor & output, const Tensor & mean, double std, Generator * generator) const {
    // DeviceGuard omitted
    return at::native::normal_out(/* native_actuals */ output, mean, std, generator);
}
Tensor TypeDefault::normal(const Tensor & mean, double std, Generator * generator) const {
    // DeviceGuard omitted
    return at::native::normal(/* native_actuals */ mean, std, generator);
}
Tensor & TypeDefault::normal_out(Tensor & output, double mean, const Tensor & std, Generator * generator) const {
    // DeviceGuard omitted
    return at::native::normal_out(/* native_actuals */ output, mean, std, generator);
}
Tensor TypeDefault::normal(double mean, const Tensor & std, Generator * generator) const {
    // DeviceGuard omitted
    return at::native::normal(/* native_actuals */ mean, std, generator);
}
Tensor & TypeDefault::normal_out(Tensor & output, const Tensor & mean, const Tensor & std, Generator * generator) const {
    // DeviceGuard omitted
    return at::native::normal_out(/* native_actuals */ output, mean, std, generator);
}
Tensor TypeDefault::normal(const Tensor & mean, const Tensor & std, Generator * generator) const {
    // DeviceGuard omitted
    return at::native::normal(/* native_actuals */ mean, std, generator);
}
Tensor TypeDefault::alias(const Tensor & self) const {
    // DeviceGuard omitted
    return at::native::alias(/* native_actuals */ self);
}

}
