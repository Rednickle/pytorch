// @generated by aten/src/ATen/copy_wrapper.py

#include "ATen/Config.h"

#include "TH/TH.h"

#include "ATen/Utils.h"
#include "ATen/CPUByteType.h"
#include "ATen/CPUCharType.h"
#include "ATen/CPUDoubleType.h"
#include "ATen/CPUFloatType.h"
#include "ATen/CPUIntType.h"
#include "ATen/CPULongType.h"
#include "ATen/CPUShortType.h"
#include "ATen/CPUHalfType.h"
#include "ATen/SparseCPUByteType.h"
#include "ATen/SparseCPUCharType.h"
#include "ATen/SparseCPUDoubleType.h"
#include "ATen/SparseCPUFloatType.h"
#include "ATen/SparseCPUIntType.h"
#include "ATen/SparseCPULongType.h"
#include "ATen/SparseCPUShortType.h"
#include "ATen/core/TensorImpl.h"

namespace at {

Tensor & CPUByteType::s_copy_(Tensor & dst, const Tensor & src, bool non_blocking) const {
  // code generated by copy_wrapper
  checked_tensor_unwrap(dst, "dst", 0, false, Backend::CPU, ScalarType::Byte);
  switch (src.type().ID()) {
    case TypeID::CPUByte:
        THByteTensor_copyByte(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUChar:
        THByteTensor_copyChar(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUDouble:
        THByteTensor_copyDouble(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUFloat:
        THByteTensor_copyFloat(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUInt:
        THByteTensor_copyInt(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPULong:
        THByteTensor_copyLong(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUShort:
        THByteTensor_copyShort(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUHalf:
        THByteTensor_copyHalf(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    default:
      return src.type()._s_copy_from(src, dst, non_blocking);
  }
  dst.unsafeGetTensorImpl()->maybe_zero_dim(src.dim() == 0);
  return dst;
}
Tensor & CPUByteType::_s_copy_from(const Tensor & src, Tensor & dst, bool non_blocking) const {
  AT_ERROR("copy does not support ", src.type().toString(), " to ", dst.type().toString(), " copy (s_copy_from case).");
}
Tensor & CPUCharType::s_copy_(Tensor & dst, const Tensor & src, bool non_blocking) const {
  // code generated by copy_wrapper
  checked_tensor_unwrap(dst, "dst", 0, false, Backend::CPU, ScalarType::Char);
  switch (src.type().ID()) {
    case TypeID::CPUByte:
        THCharTensor_copyByte(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUChar:
        THCharTensor_copyChar(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUDouble:
        THCharTensor_copyDouble(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUFloat:
        THCharTensor_copyFloat(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUInt:
        THCharTensor_copyInt(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPULong:
        THCharTensor_copyLong(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUShort:
        THCharTensor_copyShort(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUHalf:
        THCharTensor_copyHalf(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    default:
      return src.type()._s_copy_from(src, dst, non_blocking);
  }
  dst.unsafeGetTensorImpl()->maybe_zero_dim(src.dim() == 0);
  return dst;
}
Tensor & CPUCharType::_s_copy_from(const Tensor & src, Tensor & dst, bool non_blocking) const {
  AT_ERROR("copy does not support ", src.type().toString(), " to ", dst.type().toString(), " copy (s_copy_from case).");
}
Tensor & CPUDoubleType::s_copy_(Tensor & dst, const Tensor & src, bool non_blocking) const {
  // code generated by copy_wrapper
  checked_tensor_unwrap(dst, "dst", 0, false, Backend::CPU, ScalarType::Double);
  switch (src.type().ID()) {
    case TypeID::CPUByte:
        THDoubleTensor_copyByte(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUChar:
        THDoubleTensor_copyChar(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUDouble:
        THDoubleTensor_copyDouble(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUFloat:
        THDoubleTensor_copyFloat(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUInt:
        THDoubleTensor_copyInt(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPULong:
        THDoubleTensor_copyLong(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUShort:
        THDoubleTensor_copyShort(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUHalf:
        THDoubleTensor_copyHalf(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    default:
      return src.type()._s_copy_from(src, dst, non_blocking);
  }
  dst.unsafeGetTensorImpl()->maybe_zero_dim(src.dim() == 0);
  return dst;
}
Tensor & CPUDoubleType::_s_copy_from(const Tensor & src, Tensor & dst, bool non_blocking) const {
  AT_ERROR("copy does not support ", src.type().toString(), " to ", dst.type().toString(), " copy (s_copy_from case).");
}
Tensor & CPUFloatType::s_copy_(Tensor & dst, const Tensor & src, bool non_blocking) const {
  // code generated by copy_wrapper
  checked_tensor_unwrap(dst, "dst", 0, false, Backend::CPU, ScalarType::Float);
  switch (src.type().ID()) {
    case TypeID::CPUByte:
        THFloatTensor_copyByte(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUChar:
        THFloatTensor_copyChar(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUDouble:
        THFloatTensor_copyDouble(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUFloat:
        THFloatTensor_copyFloat(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUInt:
        THFloatTensor_copyInt(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPULong:
        THFloatTensor_copyLong(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUShort:
        THFloatTensor_copyShort(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUHalf:
        THFloatTensor_copyHalf(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    default:
      return src.type()._s_copy_from(src, dst, non_blocking);
  }
  dst.unsafeGetTensorImpl()->maybe_zero_dim(src.dim() == 0);
  return dst;
}
Tensor & CPUFloatType::_s_copy_from(const Tensor & src, Tensor & dst, bool non_blocking) const {
  AT_ERROR("copy does not support ", src.type().toString(), " to ", dst.type().toString(), " copy (s_copy_from case).");
}
Tensor & CPUIntType::s_copy_(Tensor & dst, const Tensor & src, bool non_blocking) const {
  // code generated by copy_wrapper
  checked_tensor_unwrap(dst, "dst", 0, false, Backend::CPU, ScalarType::Int);
  switch (src.type().ID()) {
    case TypeID::CPUByte:
        THIntTensor_copyByte(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUChar:
        THIntTensor_copyChar(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUDouble:
        THIntTensor_copyDouble(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUFloat:
        THIntTensor_copyFloat(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUInt:
        THIntTensor_copyInt(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPULong:
        THIntTensor_copyLong(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUShort:
        THIntTensor_copyShort(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUHalf:
        THIntTensor_copyHalf(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    default:
      return src.type()._s_copy_from(src, dst, non_blocking);
  }
  dst.unsafeGetTensorImpl()->maybe_zero_dim(src.dim() == 0);
  return dst;
}
Tensor & CPUIntType::_s_copy_from(const Tensor & src, Tensor & dst, bool non_blocking) const {
  AT_ERROR("copy does not support ", src.type().toString(), " to ", dst.type().toString(), " copy (s_copy_from case).");
}
Tensor & CPULongType::s_copy_(Tensor & dst, const Tensor & src, bool non_blocking) const {
  // code generated by copy_wrapper
  checked_tensor_unwrap(dst, "dst", 0, false, Backend::CPU, ScalarType::Long);
  switch (src.type().ID()) {
    case TypeID::CPUByte:
        THLongTensor_copyByte(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUChar:
        THLongTensor_copyChar(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUDouble:
        THLongTensor_copyDouble(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUFloat:
        THLongTensor_copyFloat(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUInt:
        THLongTensor_copyInt(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPULong:
        THLongTensor_copyLong(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUShort:
        THLongTensor_copyShort(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUHalf:
        THLongTensor_copyHalf(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    default:
      return src.type()._s_copy_from(src, dst, non_blocking);
  }
  dst.unsafeGetTensorImpl()->maybe_zero_dim(src.dim() == 0);
  return dst;
}
Tensor & CPULongType::_s_copy_from(const Tensor & src, Tensor & dst, bool non_blocking) const {
  AT_ERROR("copy does not support ", src.type().toString(), " to ", dst.type().toString(), " copy (s_copy_from case).");
}
Tensor & CPUShortType::s_copy_(Tensor & dst, const Tensor & src, bool non_blocking) const {
  // code generated by copy_wrapper
  checked_tensor_unwrap(dst, "dst", 0, false, Backend::CPU, ScalarType::Short);
  switch (src.type().ID()) {
    case TypeID::CPUByte:
        THShortTensor_copyByte(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUChar:
        THShortTensor_copyChar(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUDouble:
        THShortTensor_copyDouble(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUFloat:
        THShortTensor_copyFloat(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUInt:
        THShortTensor_copyInt(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPULong:
        THShortTensor_copyLong(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUShort:
        THShortTensor_copyShort(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUHalf:
        THShortTensor_copyHalf(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    default:
      return src.type()._s_copy_from(src, dst, non_blocking);
  }
  dst.unsafeGetTensorImpl()->maybe_zero_dim(src.dim() == 0);
  return dst;
}
Tensor & CPUShortType::_s_copy_from(const Tensor & src, Tensor & dst, bool non_blocking) const {
  AT_ERROR("copy does not support ", src.type().toString(), " to ", dst.type().toString(), " copy (s_copy_from case).");
}
Tensor & CPUHalfType::s_copy_(Tensor & dst, const Tensor & src, bool non_blocking) const {
  // code generated by copy_wrapper
  checked_tensor_unwrap(dst, "dst", 0, false, Backend::CPU, ScalarType::Half);
  switch (src.type().ID()) {
    case TypeID::CPUByte:
        THHalfTensor_copyByte(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUChar:
        THHalfTensor_copyChar(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUDouble:
        THHalfTensor_copyDouble(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUFloat:
        THHalfTensor_copyFloat(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUInt:
        THHalfTensor_copyInt(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPULong:
        THHalfTensor_copyLong(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUShort:
        THHalfTensor_copyShort(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    case TypeID::CPUHalf:
        THHalfTensor_copyHalf(dst.unsafeGetTensorImpl(), src.unsafeGetTensorImpl());
        break;
    default:
      return src.type()._s_copy_from(src, dst, non_blocking);
  }
  dst.unsafeGetTensorImpl()->maybe_zero_dim(src.dim() == 0);
  return dst;
}
Tensor & CPUHalfType::_s_copy_from(const Tensor & src, Tensor & dst, bool non_blocking) const {
  AT_ERROR("copy does not support ", src.type().toString(), " to ", dst.type().toString(), " copy (s_copy_from case).");
}
Tensor & SparseCPUByteType::s_copy_(Tensor & dst, const Tensor & src, bool non_blocking) const {
  // code generated by copy_wrapper

  switch (src.type().ID()) {

    default:
      AT_ERROR("copy does not support ", src.type().toString(), " to ", toString(), " copy.");
  }
  dst.unsafeGetTensorImpl()->maybe_zero_dim(src.dim() == 0);
  return dst;
}
Tensor & SparseCPUByteType::_s_copy_from(const Tensor & src, Tensor & dst, bool non_blocking) const {
  AT_ERROR("copy does not support ", src.type().toString(), " to ", dst.type().toString(), " copy (s_copy_from case).");
}
Tensor & SparseCPUCharType::s_copy_(Tensor & dst, const Tensor & src, bool non_blocking) const {
  // code generated by copy_wrapper

  switch (src.type().ID()) {

    default:
      AT_ERROR("copy does not support ", src.type().toString(), " to ", toString(), " copy.");
  }
  dst.unsafeGetTensorImpl()->maybe_zero_dim(src.dim() == 0);
  return dst;
}
Tensor & SparseCPUCharType::_s_copy_from(const Tensor & src, Tensor & dst, bool non_blocking) const {
  AT_ERROR("copy does not support ", src.type().toString(), " to ", dst.type().toString(), " copy (s_copy_from case).");
}
Tensor & SparseCPUDoubleType::s_copy_(Tensor & dst, const Tensor & src, bool non_blocking) const {
  // code generated by copy_wrapper

  switch (src.type().ID()) {

    default:
      AT_ERROR("copy does not support ", src.type().toString(), " to ", toString(), " copy.");
  }
  dst.unsafeGetTensorImpl()->maybe_zero_dim(src.dim() == 0);
  return dst;
}
Tensor & SparseCPUDoubleType::_s_copy_from(const Tensor & src, Tensor & dst, bool non_blocking) const {
  AT_ERROR("copy does not support ", src.type().toString(), " to ", dst.type().toString(), " copy (s_copy_from case).");
}
Tensor & SparseCPUFloatType::s_copy_(Tensor & dst, const Tensor & src, bool non_blocking) const {
  // code generated by copy_wrapper

  switch (src.type().ID()) {

    default:
      AT_ERROR("copy does not support ", src.type().toString(), " to ", toString(), " copy.");
  }
  dst.unsafeGetTensorImpl()->maybe_zero_dim(src.dim() == 0);
  return dst;
}
Tensor & SparseCPUFloatType::_s_copy_from(const Tensor & src, Tensor & dst, bool non_blocking) const {
  AT_ERROR("copy does not support ", src.type().toString(), " to ", dst.type().toString(), " copy (s_copy_from case).");
}
Tensor & SparseCPUIntType::s_copy_(Tensor & dst, const Tensor & src, bool non_blocking) const {
  // code generated by copy_wrapper

  switch (src.type().ID()) {

    default:
      AT_ERROR("copy does not support ", src.type().toString(), " to ", toString(), " copy.");
  }
  dst.unsafeGetTensorImpl()->maybe_zero_dim(src.dim() == 0);
  return dst;
}
Tensor & SparseCPUIntType::_s_copy_from(const Tensor & src, Tensor & dst, bool non_blocking) const {
  AT_ERROR("copy does not support ", src.type().toString(), " to ", dst.type().toString(), " copy (s_copy_from case).");
}
Tensor & SparseCPULongType::s_copy_(Tensor & dst, const Tensor & src, bool non_blocking) const {
  // code generated by copy_wrapper

  switch (src.type().ID()) {

    default:
      AT_ERROR("copy does not support ", src.type().toString(), " to ", toString(), " copy.");
  }
  dst.unsafeGetTensorImpl()->maybe_zero_dim(src.dim() == 0);
  return dst;
}
Tensor & SparseCPULongType::_s_copy_from(const Tensor & src, Tensor & dst, bool non_blocking) const {
  AT_ERROR("copy does not support ", src.type().toString(), " to ", dst.type().toString(), " copy (s_copy_from case).");
}
Tensor & SparseCPUShortType::s_copy_(Tensor & dst, const Tensor & src, bool non_blocking) const {
  // code generated by copy_wrapper

  switch (src.type().ID()) {

    default:
      AT_ERROR("copy does not support ", src.type().toString(), " to ", toString(), " copy.");
  }
  dst.unsafeGetTensorImpl()->maybe_zero_dim(src.dim() == 0);
  return dst;
}
Tensor & SparseCPUShortType::_s_copy_from(const Tensor & src, Tensor & dst, bool non_blocking) const {
  AT_ERROR("copy does not support ", src.type().toString(), " to ", dst.type().toString(), " copy (s_copy_from case).");
}

}
