// required for old g++ to compile PRId64 macros, see
// https://github.com/pytorch/pytorch/issues/3571
// for context
#define __STDC_FORMAT_MACROS

#include "ATen/CPUHalfType.h"

// @generated by aten/src/ATen/gen.py

#include <TH/TH.h>
#include <TH/THTensor.hpp>
#include <THNN/THNN.h>
#undef THNN_
#include "ATen/core/TensorImpl.h"
#include "ATen/CPUGenerator.h"
#include "ATen/Allocator.h"
#include "ATen/DeviceGuard.h"
#include "ATen/NativeFunctions.h"
#include "ATen/Utils.h"
#include "ATen/WrapDimUtils.h"
#include "ATen/core/Half.h"
#include "ATen/core/TensorImpl.h"
#include "ATen/core/UndefinedTensorImpl.h"
#include "c10/util/Optional.h"

#include <cstddef>
#include <functional>
#include <memory>
#include <utility>

#include "ATen/Config.h"


namespace at {

CPUHalfType::CPUHalfType()
  : CPUTypeDefault(CPUTensorId(), /*is_variable=*/false, /*is_undefined=*/false) {}

ScalarType CPUHalfType::scalarType() const {
  return ScalarType::Half;
}

caffe2::TypeMeta CPUHalfType::typeMeta() const {
    return caffe2::TypeMeta::Make<Half>();
}

Backend CPUHalfType::backend() const {
  return Backend::CPU;
}

const char * CPUHalfType::toString() const {
  return "CPUHalfType";
}

TypeID CPUHalfType::ID() const {
  return TypeID::CPUHalf;
}

size_t CPUHalfType::elementSizeInBytes() const {
  return sizeof(Half);
}

/* example
Tensor * CPUHalfType::add(Tensor & a, Tensor & b) {
  std::cout << "add CPUHalfTensor\n";
  return &a;
}
*/

int64_t CPUHalfType::_th_storage_offset(const Tensor & self) const {
    // DeviceGuard omitted
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Half);
    return static_cast<int64_t>(THHalfTensor_storageOffset(self_));
}
int64_t CPUHalfType::_th_ndimension(const Tensor & self) const {
    // DeviceGuard omitted
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Half);
    return static_cast<int64_t>(THHalfTensor_nDimension(self_));
}
Tensor & CPUHalfType::_th_set_(Tensor & self, Storage source) const {
    // DeviceGuard omitted
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Half);
    auto source_ = checked_storage(source,"source",2, DeviceType::CPU, at::scalarTypeToDataType(ScalarType::Half));
    THHalfTensor_setStorage(self_, source_.unsafeGetStorageImpl(), 0, {static_cast<int64_t>(source.size())}, {});
    self_->maybe_zero_dim(false);
    return self;
}
Tensor & CPUHalfType::_th_set_(Tensor & self, Storage source, int64_t storage_offset, IntList size, IntList stride) const {
    // DeviceGuard omitted
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Half);
    auto source_ = checked_storage(source,"source",2, DeviceType::CPU, at::scalarTypeToDataType(ScalarType::Half));
    THHalfTensor_setStorage(self_, source_.unsafeGetStorageImpl(), storage_offset, size, stride);
    self_->maybe_zero_dim(size.size() == 0);
    return self;
}
Tensor & CPUHalfType::_th_set_(Tensor & self, const Tensor & source) const {
    // DeviceGuard omitted
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Half);
    auto source_ = checked_tensor_unwrap(source,"source",2, false, Backend::CPU, ScalarType::Half);
    THHalfTensor_set(self_, source_);
    self_->maybe_zero_dim(source_->dim() == 0);
    return self;
}
Tensor & CPUHalfType::_th_set_(Tensor & self) const {
    // DeviceGuard omitted
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Half);
    THHalfTensor_setStorage(self_, NULL, 0, {0}, {});
    self_->maybe_zero_dim(false);
    return self;
}
bool CPUHalfType::_th_is_contiguous(const Tensor & self) const {
    // DeviceGuard omitted
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Half);
    return THHalfTensor_isContiguous(self_);
}
bool CPUHalfType::_th_is_set_to(const Tensor & self, const Tensor & tensor) const {
    // DeviceGuard omitted
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Half);
    auto tensor_ = checked_tensor_unwrap(tensor,"tensor",2, false, Backend::CPU, ScalarType::Half);
    return THHalfTensor_isSetTo(self_, tensor_);
}
Tensor CPUHalfType::_th_clone(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Half);
    return Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim((THHalfTensor_newClone(self_))->maybe_zero_dim(self_->dim() == 0)));
}
Tensor CPUHalfType::_th_unfold(const Tensor & self, int64_t dimension, int64_t size, int64_t step) const {
    // DeviceGuard omitted
    auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(CPUTensorId(), caffe2::TypeMeta::Make<Half>(), allocator(), false).release();
    auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Half);
    dimension = maybe_wrap_dim(dimension, self_);
    THHalfTensor_unfold(result_, self_, dimension, size, step);
    result_->maybe_zero_dim(self_->dim() == 0);
    return result;
}
void* CPUHalfType::data_ptr(const Tensor & self) const {
    // DeviceGuard omitted
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Half);
    return THHalfTensor_data(self_);
}
Tensor CPUHalfType::tensor(Storage storage, int64_t storageOffset, IntList size, IntList stride) const {
    // DeviceGuard omitted
    auto storage_ = checked_storage(storage,"storage",1, DeviceType::CPU, at::scalarTypeToDataType(ScalarType::Half));
    return Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim((THHalfTensor_newWithStorage(storage_.unsafeGetStorageImpl(), storageOffset, size, stride))->maybe_zero_dim(size.size() == 0)));
}
Tensor CPUHalfType::tensor(IntList size, IntList stride) const {
    // DeviceGuard omitted
    return Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim((THHalfTensor_newWithSize(size, stride))->maybe_zero_dim(size.size() == 0)));
}
Tensor CPUHalfType::_th_alias(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    auto self_ = checked_tensor_unwrap(self,"self",1, false, Backend::CPU, ScalarType::Half);
    return Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim((THHalfTensor_newWithTensor(self_))->maybe_zero_dim(self_->dim() == 0)));
}
Tensor CPUHalfType::empty(IntList size, const TensorOptions & options) const {
    const DeviceGuard device_guard(options.device());
    return at::native::empty_cpu(/* actuals */ size, options);
}
Tensor & CPUHalfType::resize_(Tensor & self, IntList size) const {
    // DeviceGuard omitted
    return at::native::resize_cpu_(/* actuals */ self, size);
}
Scalar CPUHalfType::_local_scalar_dense(const Tensor & self) const {
    const DeviceGuard device_guard(self);
    return at::native::_local_scalar_dense_cpu(/* actuals */ self);
}

}
